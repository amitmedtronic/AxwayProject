const contentTypeParser = require('content-type');
const debug = require('debug');
const buildForm = require('../form');
const { isBuffer, isString, isNull } = require('../utils');

const log = debug('api-builder:request');

/**
 * Configures the `httpOptions.body`, depending on the current value of `body`
 * and the content-type header (if provided).  If the content-type header is
 * "application/json" (or derivative) and the body is an `Object`, then the
 * body will be JSON encoded, and set in `httpOptions.body`.
 *
 * If the content-type header is "multipart/form-data" or
 * "application/x-www-form-urlencoded" and the body is an `Object`, then the
 * body will be encoded and set in `httpOptions.body`. Any additional headers
 * will be added to `httpOptions.headers`.
 *
 * @param {object} httpOptions - HTTP request options:
 * https://nodejs.org/api/http.html#httprequestoptions-callback
 * @returns {object} The modified `httpOptions`.
 */
async function configureBody(httpOptions) {
	const { _reqId: reqId } = httpOptions;
	log(reqId, 'configure body');
	const header = httpOptions.headers && httpOptions.headers['content-type'];
	const encoded = {
		body: httpOptions.body
	};
	if (header && httpOptions.body !== undefined) {
		const contentType = parseContentType(header);
		if (isJSON(contentType) && !isBuffer(httpOptions.body)) {
			log(reqId, 'encoding JSON body');
			try {
				encoded.body = JSON.stringify(httpOptions.body);
				encoded.headers = {
					'content-length': encoded.body.length
				};
			} catch (ex) {
				log(reqId, ex);
				// FIXME: not necessarily circular...
				throw new Error(`Request can not be made with content type ${header} and provided body. Circular reference detected.`);
			}
		} else if ((isFormURL(contentType) || isMultipartForm(contentType))
			&& (!isString(httpOptions.body))) {
			log(reqId, 'encoding form body');
			const built = buildForm(httpOptions.body, header);
			encoded.headers = built.headers;
			if (built.form) {
				encoded.body = built.form;
				// ugh - this getLength interface.
				await new Promise((resolve, reject) => {
					built.form.getLength((err, length) => {
						if (err) {
							log(reqId, 'cannot get length', err);
							return reject(err);
						}
						log(reqId, 'content-length', length);
						encoded.headers['content-length'] = length;
						resolve();
					});
				});
			} else {
				encoded.body = built.body;
				encoded.headers['content-length'] = built.body.length;
			}
			log(reqId, 'form headers:', built.headers);
		} else if (!isValidBody(httpOptions.body)) {
			throw new Error(`Request can not be made with content type ${header} and body that is not string or Buffer`);
		} else if (isNull(encoded.body)) {
			log(reqId, 'body is: null');
		} else {
			log(reqId, 'body type:', typeof httpOptions.body, encoded.body.length, 'bytes');
			encoded.headers = {
				'content-length': encoded.body.length
			};
		}
	}
	if (encoded.body !== undefined) {
		httpOptions.body = encoded.body;
	} else {
		// remove unwanted
		delete httpOptions.body;
	}
	if (encoded.headers && Object.keys(encoded.headers).length) {
		httpOptions.headers = {
			...httpOptions.headers,
			...encoded.headers
		};
	}
	return httpOptions;
}

/**
 * Parse the content type with the help of content-type library.
 *
 * @param {string} contentType the content type
 * @returns {object|undefined} object with the information for the parsed content type or undefined
 * 		in case of exception
 */
function parseContentType(contentType) {
	try {
		return contentTypeParser.parse(contentType);
	} catch (e) {
		// content-type library could fail on wrong types so returned undefined in that case
		// https://github.com/jshttp/content-type#contenttypeparsestring
		return undefined;
	}
}

/**
 * @param {object} parsed the parsed content type with https://www.npmjs.com/package/content-type
 * @returns {boolean} true if it is of JSON family
 */
function isJSON(parsed) {
	if (!parsed) {
		return false;
	}
	return (parsed.type.startsWith('application/')
		&& parsed.type.match(/\+?json$/) !== null);
}

/**
 * Test if the parsed content-type is form URL encoded
 * @param {object} parsed the parsed content type with https://www.npmjs.com/package/content-type
 * @returns {boolean} true if it is form URL encoded format
 */
function isFormURL(parsed) {
	if (!parsed) {
		return false;
	}
	return parsed.type === 'application/x-www-form-urlencoded';
}

/**
 * Test if the parsed content-type is multipart form data
 * @param {object} parsed the parsed content type with https://www.npmjs.com/package/content-type
 * @returns {boolean} true if it is multipart form data format
 */
function isMultipartForm(parsed) {
	if (!parsed) {
		return false;
	}
	return parsed.type === 'multipart/form-data';
}

/**
 * Tests if `value` is a valid HTTP body.
 * @param {*} value - The value to check.
 * @returns {boolean} True if `value` is a string.
 */
function isValidBody(value) {
	return value === undefined
		|| value === null
		|| value instanceof Buffer
		|| (typeof value === 'string');
}

module.exports = configureBody;
