const debug = require('debug');
const FormData = require('form-data');
const { URLSearchParams } = require('url');
const {
	isStream,
	isBuffer,
	isObject,
	isString,
	isBoolean,
	isNumber,
	isNull
} = require('./utils');

const log = debug('api-builder:request');

/**
 * Builds a form given `formData` and a `contentType` that is either
 * "multipart/form-data" or "application/x-www-form-urlencoded".  The `formData`
 * is always an object, but the property values can be provided in different
 * ways.
 *
 * For urlencoded forms, the property values must always be a primitive (i.e.
 * one of: string, boolean, number, or null). Returns `{ body, headers }` after
 * encoding.
 *
 * For multipart forms, the property values can be a primitive (i.e. one of:
 * string, boolean, number, or null), but can also support `Buffer` and stream.
 * In addition, the property value can also be an object with a property
 * (at a minimum) `value`, and `options`. For more information, see:
 * https://github.com/form-data/form-data#void-append-string-field-mixed-value--mixed-options-
 * Returns `{ form, headers }` after encoding.
 *
 * @param {object} formData - An object of key property values to encode.
 * @param {string} contentType - The form content-type to use for encoding the
 * form data.
 * @returns {object} Either `{ body, headers }` when urlencoded, or
 * `{ form, headers }` when multipart. The `body` would be suitable to use as a
 * `req.write(body)`. The `form` would be suitable to pass as a
 * `req.stream(form)`.
 */
function buildForm(formData, contentType) {
	log('building form');
	if (contentType === 'application/x-www-form-urlencoded') {
		return buildUrlencoded(formData);
	} else {
		return buildMultipartForm(formData);
	}
}

function addItemToForm(form, name, value, options = {}) {
	if (value === undefined) {
		return;
	}
	log('adding to form:', name, '=', value);

	if (isString(value) || isBuffer(value) || isStream(value)) {
		log('writing multipart/form-data buffer:', name);
		return form.append(name, value, options);
	} else if (isNumber(value) || isBoolean(value)) {
		log('writing multipart/form-data buffer:', name);
		return form.append(name, `${value}`, options);
	} else if (value === null) {
		return form.append(name, '', options);
	} else if (isObject(value) && value.hasOwnProperty('value')) {
		log('writing object:', name);
		const {
			value: data,
			options = {}
		} = value;
		return addItemToForm(form, name, data, options);
	}
	throw new Error(`Invalid payload provided for form data parameter "${name}": Expected string, boolean, number, buffer or stream.`);
}

function buildMultipartForm(formData) {
	log('building multipart/form-data body');
	if (!isObject(formData) || isBuffer(formData)) {
		throw new Error('Invalid payload provided for form data: Expected object.');
	}

	let headers = {};
	const form = new FormData();
	for (const name in formData) {
		const value = formData[name];
		if (Array.isArray(value)) {
			for (const item of value) {
				addItemToForm(form, name, item);
			}
		} else {
			addItemToForm(form, name, value);
		}
	}
	headers = {
		...headers,
		...form.getHeaders()
	};
	return {
		form,
		headers
	};
}

function buildUrlencoded(formData) {
	log('building application/x-www-form-urlencoded body');
	// FIXME: I think isBuffer can be removed
	if (isBuffer(formData) || !isObject(formData)) {
		throw new Error('Invalid payload provided for form data: Expected object.');
	}

	const form = new URLSearchParams();
	for (const name in formData) {
		const value = formData[name];
		if (value === undefined) {
			// ignore
			continue;
		}
		if (!isString(value) && !isBoolean(value) && !isNumber(value) && !isNull(value)) {
			throw new Error(`Invalid payload provided for form data parameter "${name}": Expected string, boolean, number, or null.`);
		}
		addItemToForm(form, name, value);
	}
	return {
		body: form.toString(),
		headers: {
			'content-type': 'application/x-www-form-urlencoded'
		}
	};
}

module.exports = buildForm;
