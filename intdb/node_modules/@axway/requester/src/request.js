const debug = require('debug');
const chalk = require('chalk');
const configure = require('./configure');
const { destroyAgents } = require('./configure/agent');
const { isStream, isBuffer, isString, isObject } = require('./utils');
const Decoder = require('./decoder');

const log = debug('api-builder:request');
let globalRequestIds = 0;

/**
 * An asynchronous HTTP/HTTP request client that supports:
 * - proxy
 * - keep-alive
 * - follow-redirects
 * - insecure SSL
 *
 * Uses process.env.HTTP_PROXY or `process.env.HTTPS_PROXY` if set. The
 * keep-alive option can be enabled or disabled using
 * `process.env.API_BUILDER_KEEP_ALIVE` (defaults to enabled).
 *
 * @param {object} httpOptions - HTTP request options:
 * https://nodejs.org/api/http.html#httprequestoptions-callback
 * @param {object} [options] - Additional options.
 * @param {boolean} [options.decode = true] - Enables auto-decode of response
 * based on content-type.  If `decode` is not "auto", or if the content-type is
 * unknown, it will return a `Buffer`.
 * @param {boolean} [options.followRedirects = true] - Allows HTTP redirect.
 * @param {boolean} [options.insecureSSL = false] - Enable insecure SSL.
 * @param {boolean} [options.keepAlive = true] - Enable keep-alive.
 * @param {number} [options.limit] - Options for limits.
 * @param {number} [options.limit.download = Infinity] - Limits the amount of
 * bytes, up to and including this limit.
 * @param {number} [options.maxRedirects = 10] - Maximum HTTP redirects.
 * @param {string} [options.proxy] - A proxy URL.
 * @example <caption>GET</caption>
 * request({ url: 'http://a.io' });
 * @example <caption>POST</caption>
 * request({
 *   method: 'POST',
 *   url: 'http://a.io',
 *   headers: { 'content-type': 'application/x-www-form-urlencoded' },
 *   body: { fruit: 'Banana', quantity: 1 }
 * });
 * @example <caption>POST (file-upload)</caption>
 * request({
 *   method: 'POST',
 *   url: 'http://a.io',
 *   headers: { 'content-type': 'multipart/form-data' },
 *   body: {
 *     image: {
 *       value: fs.createReadStream('teapot.png'),
 *       contentType: 'image/png'
 *     }
 *   }
 * });
 * @async
 * @returns {Promise<{status, headers, body}>}
 */
async function request(httpOptions, options = {}) {
	const reqId = ++globalRequestIds;
	if (!isObject(httpOptions)) {
		throw new Error('Invalid argument: httpOptions');
	}
	// clone options because we're going to modify them
	const _httpOptions = { ...httpOptions, _reqId: reqId };
	if (!isObject(options)) {
		throw new Error('Invalid argument: options');
	}
	const decode
		= (options.decode === undefined) ? true : options.decode === 'auto';
	log(reqId, 'auto-decode:', decode);

	const downloadLimit = getDownloadLimit(options);

	// normalize headers
	configure.headers(_httpOptions);

	// protocol, hostname, port, pathname
	configure.url(_httpOptions);

	// encodes the body according to content-type (e.g. JSON.stringify) and
	// returns new node.http options to use (i.e. with appropriate headers).
	await configure.body(_httpOptions);

	// keep-alive, proxy
	configure.agent(_httpOptions, options);

	// follow-redirects
	const client = configure.followRedirects(_httpOptions, options);

	// There is an opportunity to add a feature to add additional decoding
	// through options, e.g.
	// `decoders: [{ type: /application\/xml/, decode: decodeXML }]`
	const decoder = new Decoder();

	logRequest(reqId, _httpOptions, options);

	return new Promise((resolve, reject) => {
		const req = client.request(_httpOptions, (res) => {
			const chunks = [];
			let currentSize = 0;
			res.on('data', (chunk) => {
				log(reqId, 'received data:', chunk.length, 'bytes');
				const size = chunk.length + currentSize;
				if (size > downloadLimit) {
					reject(new Error(
						`Exceeded maximimum download size of ${downloadLimit}B (received ${size}B)`
					));
				}
				currentSize += chunk.length;
				chunks.push(chunk);
			});

			// "close" is supposed to be somewhat abnormal - when the underlying
			// connection was terminated before `res.end()` was called, but it
			// is being called almost every time (i.e. end, then close). so,
			// ensure the response is only handled / resolved once, but both are
			// needed: end - because `nock` uses "end"; close - because there is
			// a case where "close" is emitted but not "end" (i.e. when we send
			// a 204 and data with empty /api/testuser.csv collection).
			res.once('end', handleResponse);
			res.once('close', handleResponse);
			function handleResponse() {
				res.removeListener('end', handleResponse);
				res.removeListener('close', handleResponse);
				log(reqId, 'handle response');
				try {
					let decoded = Buffer.concat(chunks);
					if (decode) {
						log(reqId, 'decoding', decoded.length, 'bytes');
						try {
							decoded = decoder.decode(
								decoded, res.headers['content-type']);
						} catch (ex) {
							return reject(ex);
						}
					}
					const response = {
						status: res.statusCode,
						headers: { ...res.headers },
						body: decoded
					};
					// Provide a handy pre-converted content-length
					for (const name in response.headers) {
						if (name.toLowerCase() !== 'content-length') {
							continue;
						}
						response.headers[name] = parseInt(
							response.headers[name], 10);
						break;
					}
					log(reqId, 'response', res.statusCode);
					logResponse(response, options);
					resolve(response);
				} catch (ex) {
					reject(ex);
				}
			}
		});

		req.once('error', (err) => {
			log(reqId, 'error', err);
			if (err.message === 'Maximum number of redirects exceeded') {
				const url = _httpOptions._lastRedirect;
				const ex = new Error(
					`Exceeded maxRedirects. Probably stuck in a redirect loop ${url}`);
				reject(ex);
			} else {
				reject(err);
			}
		});

		const { body: requestBody } = _httpOptions;
		if (isStream(requestBody)) {
			log(reqId, 'writing form:', requestBody._streams);
			// FIXME: probably need a req.on error handler?
			requestBody.pipe(req);
			// NOTE: do not use `req.end()` with stream
		} else if (requestBody) {
			if (!isBuffer(requestBody) && !isString(requestBody)) {
				log(reqId, 'ending request');
				req.end();
				throw new Error('Request can not be made with content type undefined and body that is not string or Buffer');
			}
			log(reqId, 'writing', requestBody.length, 'bytes of', typeof requestBody, 'data');
			log(requestBody);
			req.write(requestBody);
			log(reqId, 'ending request');
			req.end();
		} else {
			log(reqId, 'ending request');
			req.end();
		}
	});
}

function formatURL({ protocol, hostname, port, path }) {
	return `${protocol}//${hostname}:${port}${path}`;
}

function logRequest(reqId, httpOptions, options) {
	const {
		method,
		headers,
		body
	} = httpOptions;
	const { logger } = options;

	const sbody = (body) ? '(has body)' : '(empty body)';
	const ucMethod = method.toUpperCase();
	const url = formatURL(httpOptions);

	log({ ...httpOptions, agent: 'omitted' });
	log(reqId, ucMethod, url, sbody);

	if (!logger) {
		return;
	}

	const isTrace = logger.willLogAt('TRACE');
	const isDebug = logger.willLogAt('DEBUG');
	if (isDebug) {
		const inputLog = {
			method,
			url,
			headers
		};
		logger.debug('request', chalk.grey(JSON.stringify(inputLog)));
		if (isTrace) {
			const advOpts = { ...options };
			delete advOpts.logger;
			logger.trace('request body', chalk.grey(body));
			logger.trace('request options', chalk.grey(JSON.stringify(advOpts)));
		}
	}
}

function logResponse({ status, headers, body }, { logger }) {
	log(headers);
	if (body) {
		log(body);
	}
	if (!logger) {
		return;
	}
	const isTrace = logger.willLogAt('TRACE');
	const isDebug = logger.willLogAt('DEBUG');
	if (isDebug) {
		logger.debug('response', status, chalk.grey(JSON.stringify(headers)));
		if (isTrace) {
			logger.trace('response body', chalk.grey(body));
		}
	}
}

function getDownloadLimit(options) {
	if (options.limit && options.limit.download !== undefined) {
		return options.limit.download;
	}
	return Infinity;
}

module.exports = {
	request,
	destroy: destroyAgents
};
