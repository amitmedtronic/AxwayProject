const allSettled = require('promise.allsettled');

/**
 * Action method.
 *
 * @param {object} params - A map of all the parameters passed from the flow.
 * @param {object} options - The additional options provided from the flow
 *  engine.
 * @param {object} options.pluginConfig - The service configuration for this
 *  plugin from API Builder
 *  config.pluginConfig['api-builder-plugin-pluginName']
 * @param {object} options.logger - The API Builder logger which can be used
 *  to log messages to the console. When run in unit-tests, the messages are
 *  not logged.  If you wish to test logging, you will need to create a
 *  mocked logger (e.g. using `simple-mock`) and override in
 *  `MockRuntime.loadPlugin`.  For more information about the logger, see:
 *  https://docs.axway.com/bundle/api-builder/page/docs/developer_guide/project/logging/index.html
 * @example
 *  Log errors with logger.error('Your error message');
 * @param {*} [options.pluginContext] - The data provided by passing the
 *  context to `sdk.load(file, actions, { pluginContext })` in `getPlugin`
 *  in `index.js`.
 * @return {*} The response value (resolves to "next" output, or if the method
 *  does not define "next", the first defined output).
 */
async function invokeFlow(params, { pluginContext: flowMap, logger }) {
	const { id: listenerId, data } = params;
	if (!listenerId) {
		throw new Error('Missing required parameter: id');
	}
	if (typeof listenerId !== 'string') {
		throw new Error(`Invalid id parameter type: ${typeof listenerId}`);
	}
	if (!flowMap.hasOwnProperty(listenerId)) {
		throw new Error(`Unknown Flow Listener ID: ${listenerId}`);
	}

	const startInvoke = flowMap[listenerId];
	const { error, value: response } = await startInvoke(data);
	if (error) {
		throw response;
	}

	// if response is not an object, or it doesn't have an 'error' property,
	// then it not a "proper" flow response.
	if (!isResponseObject(response)) {
		const msg
			= `Invoked Flow Listener "${listenerId}" did not end with 'Flow response'`;
		logger.error(`${msg}:`, response);
		throw new Error(msg);
	}
	if (response.isError) {
		throw response.data;
	}
	return response.data;
}

async function setResponse(params) {
	if (params.isError !== undefined
		&& typeof params.isError !== 'boolean') {
		throw new Error('Invalid parameter: isError');
	}
	return {
		isError: false,
		...params
	};
}

async function invokeFlowForEach(params, { pluginContext: flowMap, logger }) {
	const { id: listenerId, items, concurrency, breakOnError } = params;
	const startInvoke = flowMap[listenerId];
	if (!listenerId) {
		throw new Error('Missing required parameter: id');
	}
	if (typeof listenerId !== 'string') {
		throw new Error(`Invalid id parameter type: ${typeof listenerId}`);
	}
	if (!flowMap.hasOwnProperty(listenerId)) {
		throw new Error(`Unknown Flow Listener ID: ${listenerId}`);
	}
	if (!Array.isArray(items)) {
		throw new Error(`Invalid items parameter type: ${typeof items}`);
	}
	const chunks = (concurrency === 0) ? items.length : concurrency || 10;
	// Throw if concurrency is negative or not a whole number
	if (concurrency < 0 || chunks % 1 !== 0) {
		throw new Error(`Invalid concurrency: ${concurrency}`);
	}
	logger.trace(`invoking for-each ${items.length} item(s), chunk size ${chunks}`);

	let index = 0;
	let size = items.length;
	const active = [];
	const resolvedItems = [];
	const failures = [];
	const successes = [];

	for (const item of items) {
		size--;
		logger.trace(`enqueing item ${index} to invoke listener "${listenerId}"`);
		active.push(startInvokeForItem({
			listenerId,
			startInvoke,
			item,
			index,
			logger
		}));
		++index;

		// queue up all of the item into active array until we reach
		// the chunk size, then await for the active promises to settle
		if (!(active.length === chunks || !size)) {
			// keep queing...
			continue;
		}

		// got a full chunk or ran out of items, await their results
		logger.trace(`Await ${active.length} invoke`);
		const resps = await allSettled(active);
		logger.trace(`Got ${active.length} responses`);

		// push the rejects/fulfilled into your final response
		for (const resp of resps) {
			if (resp.status === 'rejected') {
				logger.debug(`Item ${resp.reason.index} was rejected:`, item);
				const respDetails = {
					item: resp.reason.item,
					index: resp.reason.index,
					response: resp.reason.response
				};
				failures.push(respDetails);
			} else {
				const respDetails = {
					item: resp.value.item,
					index: resp.value.index,
					response: resp.value.response
				};
				successes.push(respDetails);
				resolvedItems.push(respDetails.response);
			}
		}
		// clear array
		active.length = 0;
		if (breakOnError && failures.length) {
			break;
		}
	}

	if (failures.length) {
		const error = new Error(
			`There were ${failures.length} failure(s) and ${successes.length} success(es)`);
		error.successes = successes;
		error.failures = failures;
		error.items = resolvedItems;
		throw error;
	}
	return resolvedItems;
}

function isResponseObject(response) {
	return (typeof response === 'object') && ('isError' in response);
}

async function startInvokeForItem({ listenerId, startInvoke, item, index, logger }) {
	const { error, value: response } = await startInvoke(item);
	const result = { item, index, response };
	if (error) {
		// when the trigger errors, this is a big deal.  the response is an
		// Error and we need to simulate the response.data so as to preserve
		// the exception.
		logger.trace('startInvoke failed', response);
		throw result;
	}
	// if response is not an object, or it doesn't have an 'error' property,
	// then it not a "proper" flow response.
	if (!isResponseObject(response)) {
		const msg
			= `Invoked Flow Listener "${listenerId}" did not end with 'Flow response'`;
		logger.error(`${msg}:`, response);
		result.response = new Error(msg);
		throw result;
	}
	result.response = response.data;
	if (response.isError) {
		throw result;
	}
	return result;
}

module.exports = {
	invokeFlow,
	setResponse,
	invokeFlowForEach
};
