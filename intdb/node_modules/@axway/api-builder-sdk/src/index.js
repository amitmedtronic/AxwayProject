const fs = require('fs');
const Ajv = require('ajv');
const path = require('path');
const yaml = require('js-yaml');
const uriUtils = require('@axway/api-builder-uri-utils');
const validate = require('./validate');
const draft06schema = require('ajv/lib/refs/json-schema-draft-06.json');

/**
 * Flow node specs defined here:
 * https://git.ecd.axway.int/amplify/api-builder/-/tree/master/packages%2Faxway-flow-schema
 *
 * The SDK generates flow-nodes compatible with this schema version.
 * @private
 */
const SCHEMA_VERSION = '2';

/**
 * Forbidden method names are the identifiers used to name the functions
 * and instance variables in FlowNode class. See:
 * https://git.ecd.axway.int/amplify/api-builder/-/blob/master/packages/flow/lib/flownode.js#L9
 * @private
 */
const forbiddenMethodNames = [
	'node',
	'id',
	'spec',
	'flow',
	'title',
	'_getActionMethod',
	'_resolveInputs',
	'curryOutputCallbacks',
	'_getDisplayName',
	'invoke'
];

const knownFormats = [ 'multiline', 'mustache', 'xml', 'javascript' ];
/* istanbul ignore next */
const noOp = () => {};

/**
 * A programmatic API to build flow-nodes.
 */
class SDK {
	/**
	 * Constructs the SDK to build flow-node(s) and prepares the `SDK` to
	 * accept the following operations:
	 *  * {@link SDK#add .add(key, [options])} used to add a flow-node
	 *    programmatically.
	 *  * {@link SDK#load .load(file, actions, [options])} used to add
	 *    flow-nodes via an external plugin specification document.
	 *
	 * When done with your flow-node definition, you can call
	 * {@link SDK#getPlugin} and export this from the entry point of your main
	 * module so that your plugin may be imported by API Builder on startup.
	 *
	 * @param {object} [options] - The options for the builder.
	 * @param {boolean} [options.validate=false] - Enables parameter
	 * validation. Disable if you need to use refs.
	 * @param {object} [options.pluginConfig] - Configuration object passed
	 * from API Builder to `getPlugin` in `index.js`. This will be available
	 * in all action methods.
	 */
	constructor(options) {
		this.flownodes = {};
		this._name = null;
		this._method = null;
		this._group = null;
		this.setOptions(options);
	}

	/**
	 * Sets options for the builder.
	 *
	 * @private
	 * @param {object} [options] - The options for the builder.
	 * @param {boolean} [options.validate=false] - Enables parameter
	 * validation. Disable if you need to use refs.
	 * @param {object} [options.pluginConfig] - Configuration object passed
	 * from API Builder to getPlugin. This will be available in all actions.
	 * @param {boolean} [options.allowAuthClash] - Allows defining parameters
	 * and authorizations with the same name [Internal and subject to change]
	 */
	setOptions(options = {}) {
		this._validate = !!options.validate;
		this._pluginConfig = options.pluginConfig;
		this._allowAuthClash = !!options.allowAuthClash;
	}

	/**
	 * Adds a new flow-node and prepares the `SDK` to accept the following
	 * SDK operations:
	 *  * {@link SDK#method .method(key, [options])} used to add a method to
	 *    flow-node.
	 *
	 * The `key` parameter is used to uniquely identify the flow-node and
	 * represents a distinct instance of a node for the flow editor.
	 *
	 * The `options` provide additional settings for the flow-node.
	 * The flow-node will use `key` as the `name` if the `name` option is not
	 * provided. The `icon` option can be bmp, jpeg, png, gif, tiff, or svg
	 * file. The new node will appear under the "general" category by default,
	 * or under the provided `category` option.
	 *
	 * @public
	 * @param {string} key - A unique key identifier for the node.
	 * @param {object} [options] - Options for the node.
	 * @param {string} [options.name] - A friendly name for the node as it
	 * will appear in the UI.  Defaults to `key` if not provided.
	 * @param {string} [options.icon] - The absolute path to an icon file.
	 * @param {string} [options.description] - A description for the flow-node.
	 * @param {string} [options.category=general] - A category under which the
	 * node will appear in the UI.
	 * @return {SDK} The current object (this).
	 *
	 * @example
	 * sdk.add('encodeURI', {
	 *	icon: path.join(__dirname, 'encode.svg'),
	 *	name: 'Encode URI',
	 *	description: 'Encodes a URI string',
	 *	category: 'utils'
	 * });
	 */
	add(key, options = {}) {
		if (this.flownodes[key]) {
			throw new Error(`node already exists: ${key}`);
		}
		if (this._name && this._method) {
			// Note: calling `.action` clears `_method`, so we know that a
			// method has been created, but not finalized with `action`.
			throw new Error(`method requires \`action\`: ${this._method}`);
		}
		if (!key) {
			throw new Error('missing required parameter: key');
		}

		this._name = key;
		this._method = null;

		this.flownodes[key] = {
			schemaVersion: SCHEMA_VERSION,
			name: options.name || key,
			type: 'nodehandler://', // This is updated by API Builder on load
			icon: 'icon-GG-question-sign',
			category: options.category || 'general',
			methods: {}
		};

		if (options.icon) {
			const uri = this._iconFileToDataImageUri(options.icon);
			this.flownodes[this._name].icon = uri;
		}

		if (options.description) {
			this.flownodes[key].description = options.description;
		}
		return this;
	}

	_iconFileToDataImageUri(file) {
		if (!path.isAbsolute(file)) {
			throw new Error(`file must be an absolute path: ${file}`);
		}
		if (!fs.existsSync(file)) {
			throw new Error(`file does not exist: ${file}`);
		}
		return uriUtils.iconFileToDataImageURISync(file);
	}

	/**
	 * Adds a new method to the current node flow-node and prepares the `SDK`
	 * to accept the following method operations:
	 * - {@link SDK#parameter .parameter(name, schema, [options])} used to add
	 *   a parameter to the method.
	 * - {@link SDK#output .output(key, options)} used to add an output to
	 *   the method.
	 * - {@link SDK#action .action(handler, options)} used to assign an action
	 *   handler function to the method and finish the method definition.
	 *
	 * {@link SDK#add .add(key, [options])} must be called prior to this.
	 *
	 * The `key` uniquely identifies the method for the node and will be used
	 * as the name unless the `name` option is provided.
	 *
	 * The `options` provide additional settings for the method.
	 *
	 * Calling {@link SDK#action} terminates the method definition.
	 *
	 * @public
	 * @param {string} key - A unique key identifier for the method.
	 * @param {object} [options] - Options for the method.
	 * @param {string} [options.name] - A friendly name for the method as it
	 * will appear in the UI.  If not set, defaults to `key`.
	 * @param {string} [options.description] - A description for the method.
	 * @return {SDK} The current object (this).
	 *
	 * @example
	 * sdk.add('encodeURI')
	 *	.method('encode', { name: 'Encode URI' });
	 * @example <caption>Enable parameter JSON schema validation</caption>
	 * sdk.add('encodeURI')
	 *	.method('encode', { $ref: '#/definitions/foo' });
	 */
	method(key, options = {}) {
		if (!this._name) {
			throw new Error('need to start a flow-node using: `node`');
		}
		if (!key) {
			throw new Error('missing required parameter: key');
		}
		if (forbiddenMethodNames.includes(key)) {
			throw new Error(`disallowed method name: ${key}`);
		}
		this.flownodes[this._name].methods[key] = {
			name: options.name,
			description: options.description || '',
			parameter: {
				type: 'object',
				properties: {},
				required: [],
				additionalProperties: false
			},
			outputs: {}
		};
		if (!this.flownodes[this._name].methods[key].name) {
			// remove unused
			delete this.flownodes[this._name].methods[key].name;
		}
		this._group = null;
		this._method = key;
		return this;
	}

	/**
	 * Adds a parameter group to the {@link SDK#method} and prepares the `SDK`
	 * and affects the following methods:
	 * - {@link SDK#parameter .parameter(name, schema, [options])} used to add
	 *   a parameter to the method.
	 *
	 * {@link SDK#method .method(key, [options])} must be called prior to this.
	 *
	 * Any {@link SDK#parameter} added after adding a group will automatically
	 * be added to the group.  Therefore, you need to add all your ungrouped
	 * parameters first, before calling {@link SDK#group}.
	 *
	 * Calling {@link SDK#action} terminates the method definition and the
	 * parameter group.
	 *
	 * @public
	 * @param {string} name - A unique name for the parameter group as it will
	 * appear in the UI.  The name _Authorization_ has special meaning in that
	 * it begins a group for Authorization parameters that allows credential
	 * type inputs.
	 * @return {SDK} The current object (this).
	 *
	 * @example
	 * sdk.add('encodeURI')
	 *	.method('encode', { name: 'Encode URI' })
	 *	.group('Advanced')
	 *	.parameter('uri', { type: 'string' });
	 */
	group(name) {
		if (!this._name) {
			throw new Error('need to start a flow-node using: `node`');
		}
		if (!this._method) {
			throw new Error('need to start a method using: `method`');
		}
		if (!name) {
			throw new Error('missing required parameter: name');
		}
		// Changing the group, once it have been set to Authorization is
		// not allowed
		if (this._group === 'Authorization') {
			throw new Error('parameters in the \'Authorization\' group must be defined last');
		}
		this._group = name;
		return this;
	}

	/**
	 * Adds a new parameter to the current method. Any number of parameters can
	 * be added to a method.
	 *
	 * {@link SDK#method .method(key, [options])} must be called prior to this.
	 *
	 * The `name` uniquely identifies the parameter. The `schema` is a valid
	 * {@link http://json-schema.org JSON Schema} definition (both
	 * {@link http://json-schema.org/draft-04/schema draft-04} and
	 * {@link http://json-schema.org/draft-06/schema draft-06} are supported).
	 *
	 * The `options` provide additional settings for the parameter.
	 *
	 * @public
	 * @param {string} name - A unique name for the parameter as it will appear
	 * in the UI.
	 * @param {object} schema - A schema used to validate the parameter.
	 * @param {object} [options] - Specifies additional options to configure
	 * the parameter.
	 * @param {boolean} [options.required=true] - specifies that the parameter
	 * is required.
	 * @param {object} [options.multilineWrapper] - Describes the before and
	 * after parts that surrounds user provided value in the UI.
	 * @param {string} options.multilineWrapper.before - Read-only string
	 * that is placed before the user provided value in the UI.
	 * @param {string} options.multilineWrapper.after - Read-only string
	 * that is placed after the user provided value in the UI.
	 * @param {string} [options.initialType] - The type to display by default
	 * in the UI for this parameter. Allowed values are object, array,
	 * string, selector, null, boolean, and number.
	 * @return {SDK} The current object (this).
	 *
	 * @example
	 * sdk.add('encodeURI')
	 *	.method('encode', { name: 'Encode URI' })
	 *	.parameter('uri', { type: 'string' });
	 */
	parameter(name, schema, options) {
		let type = 'parameter';
		if (this._group === 'Authorization') {
			type = 'authorization';
		}
		return this._inputParameter(type, name, schema, options);
	}

	// eslint-disable-next-line valid-jsdoc
	/**
	 * Adds a new authorization parameter to the current method.
	 * See {@link SDK#parameter}.
	 * @private
	 */
	authorization(name, schema, options) {
		return this._inputParameter('authorization', name, schema, options);
	}

	/**
	 * Adds a new pure parameter or authorization parameter to a method.
	 * Any number of parameters can be added.
	 *
	 * {@link SDK#method .method(key, [options])}
	 * 	must be called prior to adding a parameter.
	 *
	 * The `name` uniquely identifies the parameter. The `schema` is a valid
	 * {@link http://json-schema.org JSON Schema} definition (both
	 * {@link http://json-schema.org/draft-04/schema draft-04} and
	 * {@link http://json-schema.org/draft-06/schema draft-06} are supported).
	 *
	 * @private
	 * @param {string} type - Type of the parameter could be 'parameter or
	 * 'authorization'.
	 * @param {string} name - A unique name for the parameter as it will
	 * appear in the UI.
	 * @param {object} schema - A schema used to validate the parameter.
	 * @param {object} [options] - Specifies additional
	 * options to configure the parameter.
	 * @param {boolean} [options.required=true] - specifies that the parameter is
	 * required.
	 * @param {object} [options.multilineWrapper] - describes the before and
	 * after parts that surrounds user provided value in the UI.
	 * @param {string} options.multilineWrapper.before - read-only string
	 * that is placed before the user provided value in the UI.
	 * @param {string} options.multilineWrapper.after - read-only string
	 * that is placed after the user provided value in the UI.
	 * @param {string} [options.initialType] - The type to display by default
	 * in the UI for this parameter. Allowed values are object, array,
	 * string, selector, null, boolean, and number.
	 * @return {SDK} The current object (this).
	 *
	 * @example
	 * sdk.add('encodeURI')
	 *	.method('encode', { name: 'Encode URI' })
	 *	.parameter('uri', { type: 'string' });
	 */
	_inputParameter(type, name, schema, options = {}) {
		const isParameterType = type === 'parameter';

		if (!this._name) {
			throw new Error('need to start a flow-node using: `node`');
		}
		if (!this._method) {
			throw new Error('need to start a method using: `method`');
		}
		if (!name) {
			throw new Error('missing required parameter: name');
		}
		if (!schema) {
			throw new Error('missing required parameter: schema');
		}
		const optionsType = (options === null) ? 'null' : typeof options;
		if (optionsType !== 'object') {
			throw new Error(`options must be of type object, got: ${optionsType}`);
		}

		// Create schema.options with allowed options
		if (isParameterType) {
			for (const option of [ 'multilineWrapper', 'initialType' ]) {
				if (options[option] !== undefined) {
					// only initialise schema.options if we have something to add
					schema.options = schema.options || {};
					schema.options[option] = options[option];
				}
			}
		}

		if (this._group && isParameterType) {
			schema.group = this._group;
		}

		// Optional validation. Not used if using yaml descriptor
		if (this._validate) {
			// Flow-node schemas are draft 06 right now
			const ajv = new Ajv({
				meta: false,
				// Stops AJV throwing errors when encountering unknown formats.
				// Will log warnings instead.
				unknownFormats: 'ignore'
			});
			for (const format of knownFormats) {
				// Register all known formats. They don't do any additional
				// validation, this just suppresses any unknown format warnings.
				ajv.addFormat(format, noOp);
			}
			ajv.addMetaSchema(draft06schema);
			ajv._opts.defaultMeta = draft06schema.$id;
			ajv.compile(schema);
		}

		// "parameter" is required by spec so the section is created in 'method'
		// function. However 'authorization' is not required so its section is
		// added on first invocation of `authorization` function.
		if (!this.flownodes[this._name].methods[this._method][type]) {
			this.flownodes[this._name].methods[this._method][type] = {
				type: 'object',
				properties: {},
				required: [],
				additionalProperties: false
			};
		}

		if (!this._allowAuthClash) {
			// If it is not an OAS flow-node, we'd need to check if that
			// parameter is in either places as we don't allow duplicates
			for (const restrictedType of [ 'parameter', 'authorization' ]) {
				const method = this.flownodes[this._name].methods[this._method];
				// We might not have method['authorization'] yet
				if (!method[restrictedType]) {
					continue;
				}
				if (name in method[restrictedType].properties) {
					throw new Error(`A parameter already exists with the name: '${name}'`);
				}
			}
		}

		this.flownodes[this._name].methods[this._method][type].properties[name] = schema;

		const required = options.required === undefined ? true : options.required;
		if (required) {
			this.flownodes[this._name]
				.methods[this._method][type].required.push(name);
		}

		return this;
	}

	/**
	 * Adds a new output to the current method.  Any number of outputs can be
	 * added to a method, but for usability-sake, you should limit this.  The
	 * `output` represents one of the possible callback routes for your method.
	 * For example, if your method tested if a number was a prime number, then
	 * the first output should be `next`, meaning it was a prime number, and
	 * the other output `error`, would mean that there was some kind of
	 * unexpected error.
	 *
	 * {@link SDK#method .method(key, [options])} must be called prior to this.
	 *
	 * The `key` uniquely identifies the output route.  The `schema` is a
	 * valid
	 * {@link http://json-schema.org JSON Schema} definition (both
	 * {@link http://json-schema.org/draft-04/schema draft-04} and
	 * {@link http://json-schema.org/draft-06/schema draft-06} are supported).
	 * If `schema` is not provided, then the output type is effectively _any_
	 * type.
	 *
	 * The `options` provide additional settings for the output.  The `context`
	 * is a valid {@link https://github.com/json-path/JsonPath JSON Path}
	 * and is used as the default by the flow editor.  When the output is
	 * invoked, the configured context is where the output value will be
	 * written.
	 *
	 * @public
	 * @param {string} key - A unique key for the output.
	 * @param {object} [options] - output options
	 * @param {string} [options.name] - A friendly name for the output as it
	 * will appear in the UI.
	 * @param {string} [options.description] - The output description.
	 * @param {string} [options.context] - The default context string.
	 * @param {object} [options.schema] - The expected JSON schema for the
	 * output value.
	 * @return {SDK} The current object (this).
	 *
	 * @example
	 * sdk.add('encodeURI')
	 *	.method('encode', { name: 'Encode URI' })
	 *	.parameter('uri', { type: 'string' })
	 *	.output('next', { context: '$.encodedURI', schema: { type: 'string' } });
	 */
	output(key, options = {}) {
		if (!this._name) {
			throw new Error('need to start a flow-node using: `node`');
		}
		const outputs = this.flownodes[this._name].methods[this._method].outputs;

		if (key === 'error' && !Object.keys(outputs).length) {
			// We prevent `error` to be the first output because returning
			// from the action calls next or the first output by default
			// and we don't want that to be the error output
			throw new Error('\'error\' cannot be the first output');
		}

		// Enable setOutput in action when a custom output is provided
		this._enableSetOutput = this._enableSetOutput
			|| ![ 'next', 'error' ].includes(key);

		const output = this.flownodes[this._name].methods[this._method].outputs[key] = {};
		[ 'name', 'description', 'context', 'schema' ].forEach(
			a => options[a] && (output[a] = options[a])
		);

		return this;
	}

	/**
	 * Assigns an action {@link actionHandler `handler`} to the current method.
	 * The method can only have one action handler. Assigning an action will
	 * terminate the current method definition.
	 *
	 * {@link SDK#method .method(key, [options])} must be called prior to this.
	 *
	 * @public
	 * @param {actionHandler} handler - The action {@link actionHandler} that
	 * implements the flow-node method.
	 * @param {Object} [options={}] - The action options.
	 * @param {*} [options.pluginContext] - The pluginContext value.
	 * @return {SDK} The current object (this).
	 *
	 * The `options` provide additional settings for the action.  The
	 * `pluginContext` can be used to provide a global context to the action
	 * method at runtime.
	 *
	 * @example
	 * sdk.add('encodeURI')
	 *	.method('encode', { name: 'Encode URI' })
	 *	.parameter('uri', { type: 'string' })
	 *	.output('next', { context: '$.encodedURI', schema: { type: 'string' } })
	 *	.action(async params => encodeURI(params.uri));
	 *
	 * @example
	 * sdk.add('decodeURI')
	 *	.method('decode', { name: 'Decode URI' })
	 *	.parameter('uri', { type: 'string' })
	 *	.output('next', { context: '$.decodedURI', schema: { type: 'string' } })
	 *	.action(action.decode, { pluginContext });
	 */
	action(handler, options = {}) {
		if (!this._name) {
			throw new Error('need to start a flow-node using: `node`');
		}
		if (!handler) {
			throw new Error('missing required parameter: handler');
		}
		if (typeof handler !== 'function') {
			throw new Error('expected handler to be a function');
		}

		const optionsType = typeof options;
		if (optionsType !== 'object') {
			throw new Error(`options must be of type object, got: ${optionsType}`);
		}

		const { pluginContext } = options;
		const enableSetOutput = this._enableSetOutput;

		const methodName = this._method;
		const method = this.flownodes[this._name].methods[this._method];

		// A wrapper for the SDK action handler.
		// The interface of the SDK action handler differs from the standard
		// flow-node action interface.
		method.action = async (req, outputs, options) => {
			let customOutput, setOutput;

			if (enableSetOutput) {
				/**
				 * Triggers a custom output in the flow.
				 * Use this when you want to route to an output other than next or error.
				 * @param {string} output - The name of the output to trigger. Can not be 'next'
				 * or 'error'.
				 * @param {*} [value] - The value to resolve with.
				 * @returns {object} The custom output data for the SDK to resolve.
				 * @example
				 * return setOutput('3xx', value);
				 */
				setOutput = (output, value) => {
					if (customOutput !== undefined) {
						// Clear the output that was previously set so that this thrown error
						// takes priority.
						customOutput = undefined;
						throw new Error('setOutput was already called in action');
					}
					if (!method.outputs[output]) {
						throw new Error(`method '${methodName}' does not have an output with key: '${output}'`);
					}
					if (output === 'error') {
						throw new Error('do not setOutput(\'error\', error). `throw error` instead');
					}
					if (output === 'next') {
						throw new Error('do not setOutput(\'next\', value). `return value` instead');
					}
					customOutput = { output, value };
					return customOutput;
				};
			}

			// Provide pluginConfig to the SDK action without modifying the
			// original options object.
			const newOptions = {
				pluginConfig: this._pluginConfig,
				pluginContext,
				setOutput,
				...options
			};

			let params;

			if (this._allowAuthClash) {
				// This flag enables SDK developers to separate out their
				// authorization parameters from their normal parameters in
				// the event they have no control over their keys and may
				// clash.  The action method will receive the authorization
				// parameters in the `options`.
				newOptions.authorizations = req.authorizations || {};

				// Clean up the interface - the parameters should not contain
				// any authorizations if the flag is set. They'll be read from
				// the options as noted above.
				params = req.params || {};
			} else {
				// Without the flag, params should contain parameters of both types.
				params = {
					...req.authorizations,
					...req.params
				};
			}

			const resp = {};
			let hasError = false;
			try {
				resp.result = await handler(params, newOptions);
			} catch (err) {
				resp.error = err;
				// Alternative to checking ('error' in resp)
				// it could throw something falsy
				hasError = true;
			}

			// Was triggered using setOutput
			if (customOutput && resp.result === customOutput) {
				return outputs[customOutput.output](undefined, customOutput.value);
			} else if (customOutput) {
				// Trigger error and overwrite the existing one since setOutput
				// was called first. Unless setOutput triggered the error.
				resp.error = new Error('setOutput called without `return`');
				hasError = true;
			}

			// If the action threw an error and we don't have a handler,
			// we have to kill the flow using the default output
			// (output choice makes no difference here)
			if (hasError && !outputs.error) {
				return outputs(resp.error);
			} else if (hasError) {
				// Otherwise use the error output
				return outputs.error(undefined, resp.error);
			}

			// If setOutput wasn't called, and we have next, use it.
			if (outputs.next) {
				return outputs.next(undefined, resp.result);
			} else {
				// Otherwise fall back to the default output.
				return outputs(undefined, resp.result);
			}
		};

		// finish the method
		delete this._method;
		return this;
	}

	/**
	 * Loads a plugin via a specification file.
	 *
	 * The `file` supports both JSON or YAML.  The `actions` is an object where
	 * each {@link SDK#method} key that is defined in the `file` has a
	 * corresponding function that defines the method implementation.
	 *
	 * The `options` provide additional settings for the loader.  You can
	 * provide a `pluginContext` through the load `options` that would be
	 * available to all action methods via their `options` parameter.
	 *
	 * @public
	 * @param {string} file - The absolute path to the JSON or YAML file.
	 * @param {object} actions - An object where each key name corresponds
	 * to a method key defined in the specification.
	 * @param {Object} [options={}] - The plugin options.
	 * @param {*} [options.pluginContext] - The context that will be passed
	 * to all `action` methods.
	 * @return {SDK} The current object (this).
	 *
	 * @example
	 * sdk.load(path.join(__dirname, 'flow-nodes.yaml'), { encode });
	 */
	load(file, actions, options = {}) {
		if (!file) {
			throw new Error('missing required parameter: file');
		}
		if (!path.isAbsolute(file)) {
			throw new Error(`file must be an absolute path: ${file}`);
		}
		if (!actions) {
			throw new Error('missing required parameter: actions');
		}

		const optionsType = typeof options;
		if (optionsType !== 'object') {
			throw new Error(`options must be of type object, got: ${optionsType}`);
		}

		const { pluginContext } = options;

		const extension = path.extname(file);
		const data = fs.readFileSync(file, 'utf-8');
		const dirname = path.dirname(file);
		let parsed;
		if ([ '.yaml', '.yml' ].includes(extension)) {
			parsed = yaml.safeLoad(data);
		} else {
			parsed = JSON.parse(data);
		}

		// Validate the YAML file
		validate(parsed);

		for (const [ type ] of Object.entries(parsed)) {
			// istanbul ignore else
			if (type === 'flow-nodes') {
				for (const [ name, flowNode ]
					of Object.entries(parsed['flow-nodes'])) {
					// Add the new flow-node
					this.add(name, {
						name: flowNode.name,
						description: flowNode.description,
						icon: flowNode.icon ? path.join(dirname, flowNode.icon) : null,
						category: flowNode.category
					});

					// Process the flow-node's methods
					for (const [ methodName, method ]
						of Object.entries(flowNode.methods)) {
						this.method(methodName, {
							name: method.name,
							description: method.description
						});

						// Process the method parameters
						for (const [ paramName, param ]
							of Object.entries(method.parameters || {})) {
							const spec = {
								...param.schema,
								title: param.name,
								description: param.description
							};
							if (param.group) {
								spec.group = param.group;

								if (param.group === 'Authorization') {
									this.authorization(
										paramName,
										spec,
										{
											required: param.required
										}
									);
									continue;
								}
							}
							this.parameter(
								paramName,
								spec,
								{
									required: param.required,
									initialType: param.initialType,
									multilineWrapper: param.multilineWrapper
								}
							);
						}

						// Process the method outputs
						if (method.outputs) {
							for (const [ outputName, output ]
								of Object.entries(method.outputs)) {
								this.output(outputName, output);
							}
						} else {
							this.output('next', method.returns);
							this.output('error', method.throws);
						}

						if (!actions.hasOwnProperty(methodName)) {
							throw new Error(`Method "${methodName}" not defined in ${path.join('src', 'actions.js')}`);
						}
						this.action(actions[methodName], { pluginContext });
					}
				}
			}
			// TODO: type === 'schema'
		}

		return this;
	}

	/**
	 * Gets the plugin specification.
	 *
	 * @public
	 * @return {object} Returns the plugin specification.
	 */
	getPlugin() {
		return {
			flownodes: this.flownodes
		};
	}
}

// THIS IS OKAY - this defines a function
/**
 * An async function that implements an flow-node method and is assigned via
 * {@link SDK#action}.
 *
 * @async
 * @function actionHandler
 * @param {object} params - A map of all the parameters passed from the flow.
 * @param {object} options - The additional options provided from the flow
 * engine.
 * @param {object} options.pluginConfig - The service configuration for this
 * plugin from API Builder config.pluginConfig['api-builder-plugin-pluginName']
 * @param {object} options.logger - The API Builder logger which can be used
 * to log messages to the console. When run in unit-tests, the messages are
 * not logged.  If you wish to test logging, you will need to create a
 * mocked logger (e.g. using `simple-mock`) and override in
 * `MockRuntime.loadPlugin`.  For more information about the logger, see:
 * https://docs.axway.com/bundle/api-builder/page/docs/developer_guide/project/logging/index.html
 * @param {*} [options.pluginContext] - The data provided by calling
 * `sdk.setContext(pluginContext)` in `getPlugin` in `index.js`.
 * @return {*} The response value (resolves to "next" output, or if the method
 * does not define "next", the first defined output).
 */

module.exports = {
	SDK
};
