const { FlowManager } = require('@axway/flow');
const ArrowQueryOptions = require('./arrowqueryoptions');
const apiBuilderConfig = require('@axway/api-builder-config');

/**
 * Get the APIs that are supported by the model/connector.
 * @param {APIBuilder} apibuilder - the API Builder instance
 * @param {object} model - the model to generate a spec for
 * @returns {array} array of APIs supported by the model
 */
function _getSupportedAPIs(apibuilder, model) {
	const apis = [];
	const connector = model.connector && typeof model.connector === 'string' ? apibuilder.getConnector(model.connector) : model.connector;

	if (!connector) {
		return apis;
	}

	for (const key in model) {
		// APIBuilder expects the model to advertise it's supported APIs by providing methods
		// that have an API suffix. Here we're using the same logic - any method on Model with
		// an API suffix is a potential API - with some caveats.
		//
		// Models may have custom APIs beyond what is described in Arrow ORM - these are not
		// supported by this node handler and will be ignored. Also the connector must also
		// support all the method dependencies for that API.
		//
		// e.g. Model.findAndModifyAPI advertises the 'findAndModify' from the Model API but as
		// there is a dependsOnAll: ['query', 'create', 'save'] in the API descriptor, the API
		// is only supported if the connector supports 'query, 'create' and 'save' methods.
		//
		if (model[key] && (key.slice(-3) === 'API')) {
			const name = key.slice(0, -3);
			if (model[name] && Object.getPrototypeOf(model).hasOwnProperty(name)) {
				// Check to see if the underlying connector has the necessary methods to support
				// this API.
				const apiDef = model[key]();
				const reqConnectorMethods = apiDef.dependsOnAny || apiDef.dependsOnAll || [ name ];
				const connectorMethods = reqConnectorMethods.filter(method => {
					if (method === 'findByID') {
						// Some connectors use old mappings, to maintain support remap to the
						// standard action.
						return !!connector[method]
							|| !!connector['findById']
							|| !!connector['findOne'];
					}
					return !!connector[method];
				});

				if (connectorMethods.length
					>= (apiDef.dependsOnAll ? reqConnectorMethods.length : 1)) {
					apis.push(name);
				} else {
					apibuilder.logger.trace(`  unsupported API on Connector: ${name}`);
				}
			} else {
				apibuilder.logger.trace(`  unsupported API on Model: ${name}`);
			}
		}
	}

	return apis;
}

/**
 * Check if the model has an autogenerated primary key.
 * @param {Model} model The model to check.
 * @returns {boolean} true if this Models primary key is autogenerated.
 */
function _isAutoGeneratedPK(model) {
	let autogenerated = true; // Assume it is for legacy reasons
	if (model.metadata
		&& model.metadata.primarykey
		&& model.metadata.hasOwnProperty('primaryKeyDetails')) {
		autogenerated = !!model.metadata.primaryKeyDetails.autogenerated;
	}
	return autogenerated;
}

/**
 * Get the spec for the model method.
 * @param {APIBuilder} apibuilder - the API Builder instance
 * @param {object} model - the model to generate a spec for
 * @param {string} methodName - the name of the method to get a spec for
 * @returns {object} generated node handler spec
 */
function _getMethodSpec(apibuilder, model, methodName) {
	let spec;
	const pkName = model.getPrimaryKeyName();
	let pkType = model.getPrimaryKeyType();

	// JSON schema does not support "date" as a type, so it needs to be coerced to "string"
	// when made into a spec for a model flow-node (see RDPP-5819).
	if (pkType === 'date') {
		pkType = 'string';
	}

	switch (methodName) {
		case 'count':
			spec = {
				name: 'Count',
				description: 'Gets a count of records.',
				parameter: {
					type: 'object',
					properties: {
						where: ArrowQueryOptions.where
					},
					additionalProperties: false
				},
				outputs: {
					next: {
						name: 'Next',
						description: `Successfully counted records of ${model.name}.`,
						context: '$.count',
						schema: {
							type: 'number'
						}
					}
				}
			};
			break;
		case 'create':
			spec = {
				name: 'Create',
				description: 'Creates a new model object.',
				parameter: {
					type: 'object',
					properties: {
						data: {
							$ref: _isAutoGeneratedPK(model)
								? apibuilder.getModelSchemaId(model)
								: apibuilder.getModelSchemaFullId(model)
						}
					},
					additionalProperties: false,
					required: [ 'data' ]
				},
				outputs: {
					next: {
						name: 'Next',
						description: `Successfully created a ${model.name}.`,
						context: '$.created',
						schema: {
							$ref: apibuilder.getModelSchemaFullId(model)
						}
					}
				}
			};
			break;
		case 'delete':
			spec = {
				name: 'Delete',
				description: 'Deletes the model object.',
				parameter: {
					type: 'object',
					properties: {
						[pkName]: {
							type: pkType
						}
					},
					required: [ pkName ],
					additionalProperties: false
				},
				outputs: {
					next: {
						name: 'Next',
						description: `Successfully deleted the ${model.name}.`,
						context: '$.deleted',
						schema: {
							$ref: apibuilder.getModelSchemaFullId(model)
						}
					},
					notfound: {
						name: 'Not Found',
						description: 'No model instance found.'
					}
				}
			};
			break;
		case 'deleteAll':
			spec = {
				name: 'Delete all',
				description: 'Deletes all the model objects.',
				parameter: {
					properties: {},
					additionalProperties: false
				},
				outputs: {
					next: {
						name: 'Next',
						description: `Successfully deleted all the ${model.name}.`,
						context: '$.deletedAll',
						schema: {
							type: 'array',
							items: {
								$ref: apibuilder.getModelSchemaFullId(model)
							}
						}
					}
				}
			};
			break;
		case 'distinct':
			const distinctOpts = { ...ArrowQueryOptions };
			delete distinctOpts.sel;
			delete distinctOpts.unsel;
			spec = {
				name: 'Distinct',
				description: 'Finds unique values using the provided field.',
				parameter: {
					type: 'object',
					properties: {
						...distinctOpts,
						field: {
							type: 'string',
							description: 'The field that must be distinct.',
							enum: pkName ? [ pkName, ...Object.keys(model.fields) ]
								: Object.keys(model.fields)
						}
					},
					required: [ 'field' ],
					additionalProperties: false
				},
				outputs: {
					next: {
						name: 'Next',
						description: `Successfully found all unique values of ${model.name}.`,
						context: '$.distinct',
						schema: {
							type: 'array',
							items: {
								$ref: apibuilder.getModelSchemaFullId(model)
							}
						}
					}
				}
			};
			delete spec.parameter.properties.sel;
			delete spec.parameter.properties.unsel;
			break;
		case 'findAll':
			spec = {
				name: 'Find all',
				description: 'Finds all model instances.',
				parameter: {
					properties: {},
					additionalProperties: false
				},
				outputs: {
					next: {
						name: 'Next',
						description: `Successfully found all ${model.name}.`,
						context: '$.foundAll',
						schema: {
							type: 'array',
							items: {
								$ref: apibuilder.getModelSchemaFullId(model)
							}
						}
					}
				}
			};
			break;
		case 'findAndModify':
			spec = {
				name: 'Find and modify',
				description: 'Modifies a single instance. Although the query may match multiple instances, only the first one will be modified.',
				parameter: {
					type: 'object',
					properties: {
						...ArrowQueryOptions,
						args: {
							type: 'object',
							description: 'Optional parameters.',
							properties: {
								new: {
									type: 'boolean',
									description: 'Set to true to return the new model instead of the original model.'
								},
								upsert: {
									type: 'boolean',
									description: 'Set to true to allow the method to create a new model.'
								}
							}
						},
						data: {
							$ref: apibuilder.getModelSchemaId(model)
						}
					},
					required: [ 'data' ],
					additionalProperties: false
				},
				outputs: {
					next: {
						name: 'Next',
						description: `Successfully found and modified ${model.name}.`,
						context: '$.foundAndModified',
						schema: {
							$ref: apibuilder.getModelSchemaFullId(model)
						}
					},
					notfound: {
						name: 'Not Found',
						description: 'No matching model found.'
					}

				}
			};
			break;
		case 'findByID':
			spec = {
				name: 'Find by ID',
				description: 'Finds model instance by ID.',
				parameter: {
					type: 'object',
					properties: {
						[pkName]: {
							type: pkType
						}
					},
					required: [ pkName ],
					additionalProperties: false
				},
				outputs: {
					next: {
						name: 'Next',
						description: `Successfully found instance of ${model.name} by ID.`,
						context: '$.foundByID',
						schema: {
							$ref: apibuilder.getModelSchemaFullId(model)
						}
					},
					notfound: {
						name: 'Not Found',
						description: 'No model instance found.'
					}
				}
			};
			break;
		case 'query':
			spec = {
				name: 'Query',
				description: 'Queries for particular model records.',
				parameter: {
					type: 'object',
					properties: {
						...ArrowQueryOptions
					},
					additionalProperties: false
				},
				outputs: {
					next: {
						name: 'Next',
						description: `Successfully queried the ${model.name}.`,
						context: '$.queried',
						schema: {
							type: 'array',
							items: {
								$ref: apibuilder.getModelSchemaFullId(model)
							}
						}
					}
				}
			};
			break;
		case 'update':
			spec = {
				name: 'Update',
				description: 'Updates a model instance.',
				parameter: {
					type: 'object',
					properties: {
						[pkName]: {
							type: pkType
						},
						data: {
							$ref: apibuilder.getModelSchemaId(model)
						}
					},
					required: [ pkName, 'data' ],
					additionalProperties: false
				},
				outputs: {
					next: {
						name: 'Next',
						description: `Successfully updated the ${model.name}.`,
						context: '$.updated',
						schema: {
							$ref: apibuilder.getModelSchemaFullId(model)
						}
					},
					notfound: {
						name: 'Not Found',
						description: 'No model instance found.'
					}
				}
			};
			break;
		case 'upsert':
			spec = {
				name: 'Upsert',
				description: 'Creates a model record if not found, or updates the model record if found.',
				parameter: {
					type: 'object',
					properties: {
						data: {
							$ref: apibuilder.getModelSchemaFullId(model)
						}
					},
					required: [ 'data' ],
					additionalProperties: false
				},
				outputs: {
					update: {
						name: 'Update',
						description: 'Successfully updated the model.',
						context: '$.model',
						schema: {
							$ref: apibuilder.getModelSchemaFullId(model)
						}
					},
					insert: {
						name: 'Insert',
						description: 'Successfully inserted the model.',
						context: '$.model',
						schema: {
							$ref: apibuilder.getModelSchemaFullId(model)
						}
					}
				}
			};
			break;
	}
	if (spec && apiBuilderConfig.flags.enableModelErrorOutputs) {
		spec.outputs.error = {
			name: 'Error',
			description: `Unexpected error in method ${methodName} of ${model.name}.`,
			context: '$.error',
			schema: {
				type: 'object',
				properties: {
					message: {
						type: 'string'
					}
				}
			}
		};
	}
	return spec;
}

/**
 * Returns the schema function for the model specific node handler.
 * @param {APIBuilder} apibuilder - the API Builder instance
 * @param {object} model - the model to generate a spec for
 * @returns {object} generated node handler spec
 */
const getSpec = (apibuilder, model) => {
	apibuilder.logger.trace(`Generating Model spec for ${model.name}`);

	const handlerSpec = {
		schemaVersion: '1',
		type: FlowManager.formatNodeHandlerUri('api-builder-flow-invoke', `model/${model.name}`),
		name: model.name,
		icon: 'icon-GG-cube',
		category: 'Model',
		methods: {
		}
	};

	const supportedAPIs = _getSupportedAPIs(apibuilder, model);
	supportedAPIs.forEach((methodName) => {
		const spec = _getMethodSpec(apibuilder, model, methodName);
		apibuilder.logger.trace(`  adding Model method to spec: ${methodName}`);
		handlerSpec.methods[methodName] = spec;
	});
	return handlerSpec;
};

module.exports = getSpec;
