const ArrowNode = require('./arrowNode');

class ArrowModelNode extends ArrowNode {
	constructor(apibuilder, model, name, node, spec, flow) {
		super(apibuilder, name, node, spec, flow);
		this.model = model;
		this.primaryKey = model.getPrimaryKeyName();
	}

	/**
	 * Objectify the model response - convert it from a model to a
	 * plain object.
	 * @private
	 * @param {function} cb - The callback function to objectify.
	 * @returns {function} - The wrapped callback that does the conversion.
	 */
	_objectify(cb) {
		const objectify = (value) => {
			if (!value) {
				return;
			}
			// Using the array prototype to avoid the ArrowOrm collection overrides.
			return Array.isArray(value)
				? Array.prototype.map.call(value, (v) => JSON.parse(JSON.stringify(v)))
				: JSON.parse(JSON.stringify(value));
		};

		return (err, result) => cb(err, objectify(result));
	}

	count(req, cb) {
		this.model.count(req.params, cb.next);
	}

	create(req, cb) {
		cb.next = this._objectify(cb.next);
		this.model.create(req.params.data, cb.next);
	}

	delete(req, cb) {
		cb.next = this._objectify(cb.next);
		this.model.delete(req.params[this.primaryKey], (err, result) => {
			// Not great but ORM layer doesn't just return null when not found
			if (err && err.message.startsWith('trying to remove, couldn\'t find record with primary key:')) {
				cb.notfound();
			} else {
				cb.next(err, result);
			}
		});
	}

	deleteAll(req, cb) {
		cb.next = this._objectify(cb.next);
		this.model.deleteAll(cb.next);
	}

	distinct(req, cb) {
		cb.next = this._objectify(cb.next);
		const field = req.params.field;
		delete req.params.field;
		this.model.distinct(field, req.params, cb.next);
	}

	findAll(req, cb) {
		cb.next = this._objectify(cb.next);
		this.model.findAll(cb.next);
	}

	findAndModify(req, cb) {
		cb.next = this._objectify(cb.next);
		const args = req.params.args || {};
		const model = req.params.data;
		delete req.params.args;
		delete req.params.data;
		this.model.findAndModify(req.params, model, args, (err, modified) => {
			if (modified) {
				cb.next(err, modified);
			} else {
				// note, this `err` must be null/undefined or else this
				// would have terminated the flow.
				cb.notfound(err);
			}
		});
	}

	findByID(req, cb) {
		cb.next = this._objectify(cb.next);
		this.model.findByID(req.params[this.primaryKey], (err, result) => {
			if (result) {
				cb.next(err, result);
			} else {
				// note, this `err` must be null/undefined or else this
				// would have terminated the flow.
				cb.notfound(err);
			}
		});
	}

	query(req, cb) {
		cb.next = this._objectify(cb.next);
		this.model.query(req.params, (err, result) => {
			cb.next(err, result || []);
		});
	}

	update(req, cb) {
		cb.next = this._objectify(cb.next);
		const data = Object.assign(
			{}, req.params.data, { [this.primaryKey]: req.params[this.primaryKey] });
		this.model.update(data, (err, result) => {
			// Not great but ORM layer doesn't just return null when not found
			if (err && err.message.startsWith('trying to update, couldn\'t find record with primary key:')) {
				cb.notfound();
			} else {
				cb.next(err, result);
			}
		});
	}

	upsert(req, cb) {
		cb.update = this._objectify(cb.update);
		cb.insert = this._objectify(cb.insert);
		if (!req.params.data || !req.params.data.hasOwnProperty(this.primaryKey)) {
			cb({ error: `missing required parameter: ${this.primaryKey}` });
			return;
		}

		const modelData = req.params.data;
		const id = modelData[this.primaryKey];

		// Upsert is expected to differentiate between new and update
		// the model upsert doesn't so do it manually.
		this.model.findByID(id, (err, result) => {
			if (err) {
				cb(err);
				return;
			}

			const update = !!result;

			this.model.upsert(id, modelData, (upsertErr, model) => {
				if (update) {
					cb.update(upsertErr, model);
				} else {
					cb.insert(upsertErr, model);
				}
			});
		});
	}
}

module.exports = ArrowModelNode;
