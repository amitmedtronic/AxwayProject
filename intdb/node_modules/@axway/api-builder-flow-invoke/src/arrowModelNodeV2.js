const ArrowNode = require('./arrowNode');

const PKERRSTR = 'couldn\'t find record with primary key';

function convertOrmToObject(value) {
	if (!(value instanceof Object)) {
		// e.g. 1, '1', null, undefined
		return value;
	}
	// Using the array prototype to avoid the ArrowOrm collection overrides.
	return Array.isArray(value)
		? Array.prototype.map.call(value, (v) => JSON.parse(JSON.stringify(v)))
		: JSON.parse(JSON.stringify(value));
}

class ArrowModelNode extends ArrowNode {
	constructor(apibuilder, model, name, node, spec, flow) {
		super(apibuilder, name, node, spec, flow);
		this.model = model;
		this.logger = apibuilder.logger;
		this.primaryKey = model.getPrimaryKeyName();
	}

	/**
	 * Invokes a model `method`.
	 * @param {string} method - The model method to invoke.
	 * @param {object} options - The options.
	 * @param {object} options.cb - The callback from the flow.
	 * @param {*} options.params - The parameters to pass to `method`.
	 * @param {boolean} options.notfound - Indicates that the `method` supports
	 * the `notfound` output.
	 * @param {boolean} options.array - Indicates that the `method` expects an
	 * array in the callback response.
	 * @param {boolean} options.upsert - Indicates that the `method` supports
	 * the `update` and `insert` outputs.
	 * @param {boolean} options.updated - Used with `options.upsert`, this
	 * indicates that the record was updated and will trigger the `update`
	 * output if true, otherwise, will trigger the `insert` output.
	 */
	_invokeModel(method, options) {
		const {
			cb,
			params,
			notfound,
			array,
			upsert,
			updated
		} = options;
		const args = (params instanceof Array) ? params : [ params ];

		const promise = new Promise((resolve, reject) => {
			try {
				this.model[method].call(this.model, ...args, (err, result) => {
					if (err) {
						// Not great - ORM layer does not return null when not
						// found, so need to check the error message.
						if (notfound && err.message.includes(PKERRSTR)) {
							return resolve([ 'notfound' ]);
						}
						return reject(err);
					} else {
						if (notfound && !result) {
							return resolve([ 'notfound' ]);
						}
						if (array && !result) {
							return resolve([ 'next', []]);
						}
						if (upsert) {
							const converted = convertOrmToObject(result);
							if (updated) {
								return resolve([ 'update', converted ]);
							} else {
								return resolve([ 'insert', converted ]);
							}
						}
						return resolve([
							'next',
							convertOrmToObject(result)
						]);
					}
				});
			} catch (ex) {
				this.logger.debug(`Error invoking ${this.model.name}`, ex);
				reject(ex);
			}
		});
		return promise
			.then(([ output, result ]) => {
				if (output === 'notfound') {
					cb.notfound();
				} else {
					cb[output](null, result);
				}
			}, (ex) => {
				cb.error(null, ex);
			});
	}

	count(req, cb) {
		this._invokeModel('count', { cb, params: req.params });
	}

	create(req, cb) {
		this._invokeModel('create', { cb, params: req.params.data });
	}

	delete(req, cb) {
		this._invokeModel('delete', {
			cb,
			params: req.params[this.primaryKey],
			notfound: true
		});
	}

	deleteAll(req, cb) {
		this._invokeModel('deleteAll', { cb, params: [] });
	}

	distinct(req, cb) {
		const field = req.params.field;
		const params = Object.assign({}, req.params);
		delete params.field;
		this._invokeModel('distinct', { cb, params: [ field, params ] });
	}

	findAll(req, cb) {
		this._invokeModel('findAll', { cb, params: [] });
	}

	findAndModify(req, cb) {
		const args = req.params.args || {};
		const model = req.params.data;
		delete req.params.args;
		delete req.params.data;

		this._invokeModel('findAndModify', {
			cb,
			params: [ req.params, model, args ],
			notfound: true
		});
	}

	findByID(req, cb) {
		this._invokeModel('findByID', {
			cb,
			params: req.params[this.primaryKey],
			notfound: true
		});
	}

	query(req, cb) {
		this._invokeModel('query', {
			cb,
			params: req.params,
			array: true
		});
	}

	update(req, cb) {
		const data = Object.assign(
			{},
			req.params.data,
			{
				[this.primaryKey]: req.params[this.primaryKey]
			}
		);
		this._invokeModel('update', {
			cb,
			params: data,
			notfound: true
		});
	}

	async upsert(req, cb) {
		if (!req.params.data
			|| !req.params.data.hasOwnProperty(this.primaryKey)) {
			cb.error(null, new Error(`missing required parameter: ${this.primaryKey}`));
			return;
		}
		const modelData = req.params.data;
		const id = modelData[this.primaryKey];

		// fake an output so that we can use the findByID wrapped by a promise
		const findCB = {
			error: function (err, result) {
				this.output = 'error';
				this.result = result;
			},
			next: function (err, result) {
				this.output = 'next';
				this.result = result;
			},
			notfound: function () {
				this.output = 'notfound';
			}
		};

		// Upsert is expected to differentiate between new and update, but
		// upsert doesn't do it for us.  We need to see if the model exists
		// first, and then invoke upsert with `updated`.
		await this._invokeModel('findByID', {
			cb: findCB,
			params: id,
			notfound: true
		});

		const { output, result } = findCB;

		if (output === 'error') {
			cb.error(null, result);
		} else {
			await this._invokeModel('upsert', {
				cb,
				params: [ id, modelData ],
				upsert: true,
				updated: !!result
			});
		}
	}
}

module.exports = ArrowModelNode;
