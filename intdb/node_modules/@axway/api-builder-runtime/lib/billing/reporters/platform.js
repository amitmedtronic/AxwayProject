const requester = require('@axway/requester');
const uuid = require('uuid');

const GATEKEEPER_HOSTS = {
	production: 'https://gatekeeper.platform.axway.com',
	staging: 'https://gatekeeper.platform.axwaytest.net'
};

// Platform Environment GUID can be in different formats (with or without dashes)
// Be aware this could be subject to change at any time.
const ENVIRONMENT_ID_REGEX = /^[0-9a-f]{8}-?([0-9a-f]{4}-?){3}[0-9a-f]{12}$/i;

class GatekeeperReporter {
	async init(options) {
		this.logger = options.logger;
		this.proxy = options.proxy;
		this.timeout = options.timeout;

		const sessionStart = Date.now();
		const { org, environment } = this.reportInfo = {
			org: options.org,
			runtimeVersion: options.runtimeVersion,
			version: options.appVersion,
			appName: options.appName,
			environment: options.environment,
			session: options.session,
			sessionStart
		};

		// Note this is intentionally using ENVIRONMENT_ID_REGEX which isn't 100% correct for
		// Organization GUIDs. (the GUID always has dashes). This is just to make sure that users
		// aren't providing Organization ID by accident.
		if (!ENVIRONMENT_ID_REGEX.test(org)) {
			throw new Error('config.subscriptionUsageTracking.org is not a valid Organization GUID');
		}

		if (!ENVIRONMENT_ID_REGEX.test(environment)) {
			throw new Error('config.subscriptionUsageTracking.environment is not a valid Environment ID');
		}

		this.gatekeeperHost = options.platformURL || GATEKEEPER_HOSTS[options.platformEnv];
		if (!this.gatekeeperHost) {
			throw new Error('config.subscriptionUsageTracking.platformEnv configured incorrectly. Must be production or staging');
		}

		if (typeof this.timeout !== 'number' || this.timeout <= 0) {
			throw new Error('config.subscriptionUsageTracking.timeout configured incorrectly.  Must be a number greater than 0');
		}

		this._startTransactionInterval(sessionStart);
	}

	countTransaction() {
		this.currentTransactions.count++;
	}

	async onInterval() {
		if (!this.currentTransactions.count) {
			return;
		}
		await this._endTransactionInterval();
	}

	_startTransactionInterval(timestamp) {
		this.currentTransactions = {
			start: timestamp,
			count: 0
		};
	}

	async _endTransactionInterval() {
		const timestamp = Date.now();
		const tx = this.currentTransactions;
		this._startTransactionInterval(timestamp);
		tx.end = timestamp;
		await this._reportTransactions(tx);
	}

	async _reportTransactions(tx) {
		const {
			org,
			runtimeVersion,
			appName,
			session,
			sessionStart,
			environment,
			version
		} = this.reportInfo;
		const report = {
			id: uuid.v4(), // unique id of the event
			version: '4', // version of the event spec
			event: 'usage.APIB.Transactions', // event name. *capitalization matters*
			app: org, // GUID of the org that we are reporting the event against
			timestamp: tx.end, // time that the event was created
			session: {
				id: session, // id of current session
				duration: tx.end - sessionStart // duration of current session
			},
			distribution: {
				environment, // environment id
				version // app version
			},
			data: {
				// Force the usage to be categorised as 'Customer Managed'.
				// Governance is a function of the associated environment. No env, no known gov.
				// no known gov, treats as SaaS. In practice, it seems to always default to SaaS
				// so we need to hardcode it here, even if env is always provided by us.
				governance: 'Customer Managed',
				value: tx.count, // number of transactions
				observedEnd: tx.end,
				observedStart: tx.start,
				// Additional metadata
				runtimeVersion, // API Builder version
				appName // project name
			}
		};

		try {
			await this._post(report);
			this.logger.info(`Reported ${tx.count} transactions`);
		} catch (err) {
			// Add the missing transactions back to the current count
			this.currentTransactions.count += tx.count;
			// amend the interval start time
			this.currentTransactions.start = tx.start;
			this.logger.error(`Failed to report ${tx.count} transactions`, err);
		}
	}

	async _post(body) {
		const { proxy, timeout } = this;
		const url = `${this.gatekeeperHost}/v4/event`;
		this.logger.debug(`Sending report to ${url}${proxy ? ` via proxy ${proxy}` : ''}`, body);

		const response = await requester.request({
			method: 'POST',
			headers: {
				'content-type': 'application/json'
			},
			url,
			body
		}, {
			proxy,
			timeout
		});
		if (response.status !== 204) {
			throw new Error(`Unexpected status: ${response.status}`);
		}
	}
}

module.exports = GatekeeperReporter;
