const fs = require('fs');
const path = require('path');
const util = require('util');
const YAML = require('js-yaml');
const Ajv = require('ajv');
const { getByJsonPath } = require('@axway/flow/lib/jsonpath');
const uuid = require('uuid');
const chalk = require('chalk');
const utils = require('../utils');
const triggerConfigSchema = require('./triggerconfigschema-v1.json');
const draft06schema = require('ajv/lib/refs/json-schema-draft-06.json');
const triggerSchema = require('./triggerschema-v1.json');
const channelSchema = require('./channelschema-v1.json');
const pluginTriggerSchema = require('./plugintriggerschema-v1.json');
const { PluginError, ProductionError } = require('./errors');
const validateTriggers = require('./validateTriggers');
const validateParams = require('./validateParams');

const stoppedMessage = 'Flow-trigger was triggered after the server stopped';

const afs = {
	readFile: util.promisify(fs.readFile),
	writeFile: util.promisify(fs.writeFile),
	mkdir: util.promisify(fs.mkdir)
};

class TriggerManager {
	constructor() {
		this._triggersInfo = {
			definitions: {},
			triggers: {}
		};
		this._instances = {
			channels: {},
			triggers: {}
		};

		// Flow-trigger config, chanel, and trigger schemas defined in this
		// package are draft-07. Ajv knows how to validate those by default.
		// The schemas exported by each flow-trigger plugin are draft 06 and
		// this is the reason to add draft 06 meta schema in addition.
		this.ajv = new Ajv();
		this.ajv.addMetaSchema(draft06schema);
		this.ajv._opts.metaSchema = draft06schema.$id;
		this.ajv.addSchema(triggerSchema);
		this.ajv.addSchema(channelSchema);
		this.ajv.addSchema(triggerConfigSchema);
		this.ajv.addSchema(pluginTriggerSchema);
	}

	/**
	 * Sets the API Builder instance necessary to collectively set various
	 * shared components, namely: logger, config, and flowManager.
	 * @param {Object} apibuilder - The API Builder instance.
	 */
	setAPIBuilder(apibuilder) {
		this._apibuilder = apibuilder;
		this._logger = apibuilder.logger;
		this._config = apibuilder.config;
		this._flowManager = apibuilder.flowManager;
		// False if the Admin UI is not available
		this._isDeveloperMode = !!this._apibuilder.admin;
		this._triggersDir = path.join(this._apibuilder.config.dir, 'triggers');
	}

	/**
	 * Constructs an object with the global locations where trigger/channel
	 * parameters could obtain their values from and resolves parameters with
	 * JSONPath selectors from those locations.
	 * @param {Object} parameters - parameters to be resolved.
	 * @param {Object} request - `request` is additional location to config
	 * and env that is relevant during runtime flow execution.
	 * @returns {Object} resolved parameters.
	*/
	getResolvedParameters(parameters, request) {
		return resolveParameters(
			{
				env: process.env,
				config: this._config,
				request
			},
			parameters
		);
	}

	/**
	 * Sets the plugins.  Plugins are validated before their definitions are
	 * registered.  This must be set on this manager before the manager can be
	 * used.
	 * @param {Object} plugins - The API Builder plugins.
	 * @throws {Error} when trigger definition fails validation.
	 */
	setPlugins(plugins) {
		for (const pluginName in plugins) {
			const { triggers } = plugins[pluginName].components;
			if (!triggers) {
				continue;
			}
			for (const triggerType in triggers) {
				const definition = triggers[triggerType];
				// validate definition (throws)
				this.pluginValidation(pluginName, triggerType, definition);
				// register the plugin definition
				this.addDefinitionInfo(triggerType, definition);
			}
		}
	}

	/**
	 * Returns the definition info for a given type of triggers.
	 *
	 * @param {string} triggerType - The trigger type.
	 * @returns {Object} The definition info.
	 */
	getDefinitionInfo(triggerType) {
		return this._triggersInfo.definitions[triggerType];
	}

	/**
	 * Adds a trigger's plugin definition to `_triggersInfo`. This includes a
	 * skeleton/template containing the initial values needed for creating new
	 * triggers of that type.
	 *
	 * @param {string} triggerType - The trigger type.
	 * @param {Object} definition - The plugin's definition.
	 */
	addDefinitionInfo(triggerType, definition) {
		// Makes a shallow copy, so we don't pollute the original.
		this._triggersInfo.definitions[triggerType] = {
			...definition
		};

		// Creates an initial (stub) template without config.  Later, it will
		// be updated if the configuration file is registered.
		this.assignTriggerTemplate(triggerType, definition, {});
	}

	/**
	 * Updates a trigger's plugin definition.  The `config` is used to
	 * generate a template that can be used when adding new triggers of
	 * `triggerType`.
	 * @param {string} triggerType - The trigger type.
	 * @param {Object} definition - The plugin's definition.
	 * @param {Object} config - The whole trigger configuration.
	 */
	assignTriggerTemplate(triggerType, definition, config) {
		const triggerTemplate = {
			enabled: false, // All new triggers would be disabled
			flowId: null,
			instanceName: definition.name, // the flow-trigger's friendly name
			flowInputsMap: {},
			triggerParameters: {},
			status: {
				valid: true
			}
		};

		setInitialValuesForEnumParameters(
			definition.triggerParameters,
			triggerTemplate.triggerParameters
		);

		if (definition.createChannel) {
			const channels = Object.keys(config.channels || {});
			// Always pick the first channel if there is one.
			const channelId = (channels.length) ? channels[0] : null;
			const channel = (channelId) ? config.channels[channelId] : null;
			// Set the template channelId to the existing channelId, or use
			// the trigger type as the default channelId.
			triggerTemplate.channelId = channelId || triggerType;
			// Use existing channel parameters or empty set
			triggerTemplate.channelParameters = channel ? channel.parameters : {};
			setInitialValuesForEnumParameters(
				definition.channelParameters,
				triggerTemplate.channelParameters
			);
		}

		this._triggersInfo.definitions[triggerType].triggerTemplate
			= triggerTemplate;
	}

	/**
	 * Creates a trigger object that will be used to persist information
	 * about the trigger.  This data structure is used internally, used
	 * by the API, used by the front-end, and the same object is passed
	 * as part of `processTriggerUpdates`.
	 */
	addTriggerInfo({ triggerType, triggerId, triggerConfig, config }) {
		if (!this._triggersInfo.triggers[triggerType]) {
			this._triggersInfo.triggers[triggerType] = {};
		}
		const info = {
			enabled: triggerConfig.enabled,
			instanceName: triggerConfig.name,
			flowId: triggerConfig.invoke.flow,
			flowInputsMap: triggerConfig.invoke.parameters,
			triggerParameters: triggerConfig.parameters,
			channelId: triggerConfig.channel,
			channelParameters: triggerConfig.channel
				&& config.channels
				&& config.channels[triggerConfig.channel].parameters,
			status: {
				valid: true
			}
		};
		this._triggersInfo.triggers[triggerType][triggerId] = info;
		return info;
	}

	/**
	 * Sets the state on a trigger information object.  The property `valid`
	 * is assumed to be false, unless explicitly specified otherwise.
	 * Calling this method will automatically set the trigger as being
	 * invalid (`valid: false`), and having an `error` details.
	 */
	setState(info, error, options = { valid: false }) {
		info.status = {
			// it is possible to be valid and reason is 'disabled'
			valid: options.valid,
			error
		};
	}

	/**
	 * Adds an instance of a channel or trigger.
	 * @param {string} instanceType - One of: channels | triggers.
	 * @param {string} type - The trigger type.
	 * @param {string} id - The channel id.
	 * @param {string} instance - The channel instance.
	 */
	addInstance(instanceType, type, id, instance) {
		this._instances[instanceType][type]
			= this._instances[instanceType][type] || {};
		this._instances[instanceType][type][id] = instance;
	}

	/**
	 * Gets a channel instance.  The `instance` is the entity returned by
	 * the plugin's `createChannel` function.
	 * @param {string} type - The trigger type.
	 * @param {string} id - The channel id.
	 */
	getChannelInstance(type, id) {
		return this._instances.channels[type]
			&& this._instances.channels[type][id];
	}

	/**
	 * Gets the triggers Info object.
	 */
	getInfo() {
		return this._triggersInfo;
	}

	/**
	 * Creates a flow-trigger that is used to invoke flows.
	 * @param {object} options - Create trigger options.
	 * @param {string} options.type - The trigger type.
	 * @param {string} options.id - The trigger instance id.
	 * @param {Object} options.triggerConfig - The trigger config.
	 * @param {Object} [options.definition] - The flow-trigger definition.
	 * @returns {Object} A trigger instance.
	 * @throws {PluginError|Error} PluginError if the plugin handle is not
	 * as expected or an Error if the creation failed.
	 * @async
	 */
	async createTrigger({ type, id, triggerConfig, definition }) {
		const {
			channel: channelId,
			parameters
		} = triggerConfig;

		const triggerInfo = {
			parameters: this.getResolvedParameters(parameters),
			id
		};

		// Ensure parameters are validated with draft-06. Cloning the
		// parameters here might not be as efficient as doing it once, but the
		// alternative is a massive change to the trigger tests.
		const isValid = this.ajv.validate(
			{
				...definition.triggerParameters,
				$schema: 'http://json-schema.org/draft-06/schema#'
			},
			triggerInfo.parameters
		);

		if (!isValid) {
			const ajvErrors = JSON.stringify(this.ajv.errors);
			throw new ProductionError(
				`Invalid flow-trigger parameters: ${ajvErrors}`
			);
		}

		if (triggerConfig.channel !== undefined) {
			// The channel is checked in semanticValidation - the channel must
			// exist and must be enabled, and the trigger must also be same.
			const channel = this.getChannelInstance(type, channelId);
			if (!channel) {
				throw new Error(`Channel '${channelId}' has an error`);
			}
			triggerInfo.channel = channel.channel;
		}

		const options = {
			logger: this._logger.getScoped(`[${type}: ${id}]`),
			pathManager: this._apibuilder._internal.getPathManager()
		};

		// createTrigger can throw an exception
		const trigger = await definition.createTrigger(triggerInfo, options);

		try {
			if (typeof trigger !== 'object' || trigger === null) {
				throw new PluginError(
					'createTrigger should return an object.');
			}
			if (typeof trigger.start !== 'function') {
				throw new PluginError(
					'createTrigger should return an object with a start function.');
			}
			if (typeof trigger.onInvoke !== 'function') {
				throw new PluginError(
					'createTrigger should return an object with a onInvoke function.');
			}
			if (typeof trigger.destroy !== 'function') {
				throw new PluginError(
					'createTrigger should return an object with a destroy function.');
			}
			if (trigger.description !== undefined && typeof trigger.description !== 'string') {
				throw new PluginError(
					'createTrigger should return an object with a string description.');
			}
			if (trigger.external !== undefined) {
				if (typeof trigger.external !== 'boolean') {
					throw new PluginError(
						'createTrigger should return an object with a boolean "external" property.');
				}
			} else {
				trigger.external = true;
			}
		} catch (ex) {
			// call destroy if possible before throwing
			if (trigger
				&& trigger.destroy
				&& typeof trigger.destroy === 'function') {
				await trigger.destroy();
			}
			throw ex;
		}

		// bits used by TM
		trigger.type = type;
		trigger.id = id;
		trigger.config = triggerConfig;
		// bits that are used by UI
		trigger.flowId = triggerConfig.invoke.flow;
		trigger.enabled = true;
		trigger.status = {
			valid: true
		};

		return trigger;
	}

	/**
	 * Creates an instance of a channel that is used by trigger instances.
	 * Examples might be to bind to a port, or to bind to a queue. Channels are
	 * optional with flow-triggers. Not every trigger will use instances.
	 * @param {object} options - Create channel options.
	 * @param {string} options.triggerType - The trigger type.
	 * @param {string} options.channelId - The channel instance id.
	 * @param {object} options.channelConfig - The channel instance portion of
	 * the configuration.
	 * @param {object} options.definition - The flow-trigger definition.
	 * @example
	 * channels:
	 *   my-instance:
	 *     parameters:
	 *       color: yellow
	 * @returns {Object} A channel instance.
	 * @throws {PluginError|ProductionError|Error} PluginError if the plugin
	 * handle is not as expected or an Error if the creation failed.
	 * @async
	 */
	async createChannel({ triggerType, channelId, channelConfig, definition }) {
		if (!definition) {
			throw new ProductionError(`No plugin registered for flow-trigger type: ${triggerType}`);
		}

		const channelInfo = {
			id: channelId,
			parameters: this.getResolvedParameters(channelConfig.parameters)
		};

		// Ensure parameters are validated with draft-06. Cloning the
		// parameters here might not be as efficient as doing it once, but the
		// alternative is a massive change to the trigger tests.
		const isValid = this.ajv.validate(
			{
				...definition.channelParameters,
				$schema: 'http://json-schema.org/draft-06/schema#'
			},
			channelInfo.parameters
		);
		if (!isValid) {
			const ajvErrors = JSON.stringify(this.ajv.errors);
			throw new ProductionError(`Invalid channel parameters: ${ajvErrors}`);
		}

		const logger = this._logger.getScoped(
			`[type: ${triggerType}] [${definition.channelFriendlyName}: ${channelId}]`);

		const options = {
			// FIXME: this is different than the `createTrigger` `onUnstable`.
			// ideally, these should get the same implementation.  However, as
			// it turns out, this isn't used by any trigger, and we wouldn't
			// know what the edge-cases are.  There might be a fraction of a
			// second between `createChannel` and `createTrigger` where the
			// channel can become unstable.  It is possibly something that
			// we do not really need on the interface.  Or perhaps we haven't
			// discovered the need yet.
			onUnstable: message => {
				this._apibuilder.emit('unstable', message);
			},
			logger
		};

		// createChannel can throw an exception
		const channel = await definition.createChannel(channelInfo, options);

		if (typeof channel !== 'object' || channel === null) {
			throw new PluginError('createChannel should return an object.');
		}
		if (typeof channel.destroy !== 'function') {
			throw new PluginError('createChannel should return an object with a destroy function.');
		}

		return channel;
	}

	/**
	 * Checks for startup.  If any check fails, it will abort startup.
	 * @param {object} options - Options.
	 * @param {string} options.file - The path to the trigger config file.
	 * @param {string} options.triggerType - The trigger type.
	 * @param {object} options.config - The trigger config that was loaded from
	 * `file`.
	 * @param {object} options.definition - The trigger plugin definition.
	 * @throw {Error} if any check fails, an error will be thrown and abort
	 * startup.
	 */
	checkAbortStartup(options) {
		this.semanticValidation(options);
	}

	/**
	 * Validates the plugin `definition` to ensure that it is exporting
	 * functions consistent with its specification.
	 * @param {string} pluginName - The plugin name.
	 * @param {string} triggerType - The trigger type.
	 * @param {object} definition - The trigger plugin definition.
	 * @throw {Error} if the validation fails, an error will be thrown and abort
	 * startup.
	 */
	pluginValidation(pluginName, triggerType, definition) {
		if (!this.ajv.validate(pluginTriggerSchema.$id, definition)) {
			const ajvError = JSON.stringify(this.ajv.errors[0]);
			throw new Error(
				`'${pluginName}' plugin provided invalid '${triggerType}' flow-trigger definition: ${ajvError}.`
			);
		}
	}

	/**
	 * Semantic validation of the trigger config file.
	 * @param {object} options - Options.
	 * @param {string} options.file - The trigger file that loaded `config`.
	 * @param {string} [options.definition] - The trigger plugin definition.
	 * @param {Object} options.config - The whole trigger configuration.
	 * @param {boolean} options.isNewFlow - true if the flow is new and is not
	 * registered yet. Can be used to exclude the flow portion of the validation.
	 * @throws {Error} - When the trigger's configuration is semantically
	 * invalid. The semantic errors should abort the start up.
	 */
	semanticValidation({ file, definition, config, isNewFlow = false }) {
		if (config.channels) {
			if (!definition.createChannel) {
				throw new Error(
					`The ${definition.name} plugin does not manage channels, but channels have been defined: ${file} > channels`);
			}

			for (const channelId in config.channels) {
				if (!isValidID(channelId)) {
					throw new Error(
						`Invalid channel ID: ${file} > channels: ${channelId}`
					);
				}
			}
		}

		for (const triggerId in config.triggers) {
			const triggerConfig = config.triggers[triggerId];
			const { channel } = triggerConfig;
			const { channels } = config;

			if (!isValidID(triggerId)) {
				throw new Error(
					`Invalid trigger ID: ${file} > triggers > ${triggerId}`
				);
			} else if (!channel && definition.createChannel) {
				// trigger has no channel and requires one
				throw new Error(
					`Channel is required, but trigger did not provide one: ${file} > triggers > ${triggerId}`
				);
			} else if (channel && !definition.createChannel) {
				throw new Error(
					`Plugin does not manage channels, but trigger is using one: ${file} > triggers > ${triggerId} > channel: ${channel}`
				);
			} else if (channel && !(channels && channels[channel])) {
				throw new Error(
					`Trigger references a channel that does not exist: ${file} > triggers > ${triggerId} > channel: ${channel}`
				);
			} else if (channel && triggerConfig.enabled && channels[channel].enabled === false) {
				throw new Error(
					`Trigger cannot use a disabled channel: ${file} > triggers > ${triggerId} > channel: ${channel}`
				);
			} else if (!isNewFlow) {
				const flowId = triggerConfig.invoke.flow;
				const flow = this._apibuilder.getFlow(flowId);
				if (!flow) {
					throw new Error(
						`Trigger references a Flow that does not exist. ${file} > triggers > ${triggerId} > flow: ${flowId}`
					);
				}
			}
		}
	}

	/**
	 * Handle errors from flow-trigger/channel validation below
	 * @param {object} options - Options.
	 * @param {string} options.type - The type (channel/flow-trigger)
	 * @param {string} options.crumbs - The crumbs to the data that was validated.
	 * @param {object} options.info - The validation info returned by validateParams
	 */
	_handleValidationError({ type, crumbs, info }) {
		const { code, name, errors } = info;
		const msgs = [
			`Invalid ${type} parameter:`,
			`${crumbs} > parameters > ${name}: ${code}`
		];

		// Add all the validation errors
		if (errors) {
			msgs.push(JSON.stringify(errors));
		}

		const message = msgs.join(' ');
		if (this._isDeveloperMode) {
			this._logger.warn(message);
		} else {
			throw new Error(message);
		}
	}

	/**
	 * Validates the channel configuration.  Each parameter is validated
	 * against it the channel's parameter schema, and will detect if any
	 * parameters are missing, invalid, or not a valid JSON path.  It does
	 * _not_ resolve the JSON path parameters.  If the channel is disabled,
	 * it does not perform this validation and will return successfully.
	 * @param {object} options - Options.
	 * @param {string} options.file - The trigger file that loaded `config`.
	 * @param {string} options.channelId - The trigger plugin definition.
	 * @param {object} options.channConfig - The channel configuration to be
	 * validated.
	 * @param {string} [options.definition] - The trigger plugin definition.
	 * @throws {Error} In production and fails validation.
	 */
	channelValidation(options) {
		const {
			file,
			definition,
			channelId,
			channConfig
		} = options;
		if (!definition) {
			return;
		}

		if (!channConfig.enabled) {
			// this allows users to explicitly disable channels if they
			// have a problem with their parameters.
			return;
		}
		validateParams({
			ajv: this.ajv,
			schema: definition.channelParameters,
			onError: (info) => {
				this._handleValidationError({
					type: 'channel',
					crumbs: `${file} > channels > ${channelId}`,
					info
				});
			}
		})
			.validate(channConfig.parameters);
	}

	/**
	 * Validates the trigger configuration if a `definition` is provided.
	 * Each parameter is validated against the trigger's parameter schema,
	 * and will detect if any parameters are missing, invalid, or not a valid
	 * JSON path.  It does _not_ resolve the JSON path parameters.  If the
	 * trigger is disabled this function should not be called.
	 *
	 * @param {object} options - Trigger validation options.
	 * @param {string} options.file - The trigger file that loaded `config`.
	 * @param {string} options.triggerId - The trigger id.
	 * @param {object} options.config - The whole trigger config.
	 * @param {string} [options.definition] - The trigger plugin definition.
	 *
	 * @returns {boolean} - True if valid, false if invalid.
	 * @throws {ProductionError} If any parameters are not valid.
	 */
	triggerValidation({ file, definition, triggerId, config }) {
		if (!definition) {
			return true;
		}

		let isValid = true;
		const onParameterError = (info) => {
			isValid = false;
			this._handleValidationError({
				type: 'flow-trigger',
				crumbs: `${file} > triggers > ${triggerId}`,
				info
			});
		};

		const onInputParameterError = (info) => {
			isValid = false;
			this._handleValidationError({
				type: 'flow-trigger',
				crumbs: `${file} > triggers > ${triggerId} > invoke`,
				info
			});
		};

		const triggerConfig = config.triggers[triggerId];
		validateParams({
			ajv: this.ajv,
			schema: definition.triggerParameters,
			onError: onParameterError
		}).validate(triggerConfig.parameters);

		const flowId = triggerConfig.invoke.flow;
		// We already verified that this flow exists in the earlier stages of
		// the validation process.
		const flow = this._apibuilder.getFlow(flowId);

		// Validate the trigger to flow inputs map
		validateParams({
			ajv: this.ajv,
			schema: flow.parameter,
			onError: onInputParameterError
		}).validate(triggerConfig.invoke.parameters);

		if (!isValid) {
			throw new ProductionError(
				`Trigger parameter(s) are not valid: ${file} > triggers > ${triggerId}`
			);
		}

		// Verify the flow is valid
		const validation = flow['x-validation'];
		if (!validation || !validation.valid) {
			throw new ProductionError(
				`Trigger references an invalid Flow: ${file} > triggers > ${triggerId} > invoke > flow: ${flowId}`);
		}
		return true;
	}

	/**
	 * Registers a trigger given its decoded configuration.
	 * On registration, it will create all configured channels and create
	 * flow-triggers that use those instances.
	 * @param {string} file - The trigger file that loaded `config`.
	 * @param {Object} config - The whole trigger config.
	 * @throws {Error} - When the configuration is semantically invalid or
	 * a problem occurred with the trigger or the required channels. This error
	 * should abort the start up.
	 * @async
	 */
	async register(file, config) {
		// FIXME: many unit tests rely on `register`, and then check some other
		// aspect, e.g. `validateTriggerUpdates`.  However, there is no way to
		// ensure that `register` completed correctly.  _Any_ exception could
		// have happened, caught, and all it does is set the trigger state to
		// error.  We need feedback from here to know if it was successful or
		// if errors were encountered.  This should be verified in the tests.

		const triggerType = getTypeFromFile(file);
		// FIXME: the channels could be a bit more sophisticated where they
		// are not created unless there are triggers that use them.
		const definition = this.getDefinitionInfo(triggerType);
		if (!definition) {
			// This should abort in production.
			// The difference between this error and the one below with the same
			// message is that this one will be caught in prod and dev, the other
			// one will be caught in dev and is more prominent (you get the error
			// log). The cause is the same.
			const msg
				= `No plugin registered for flow-trigger type: ${triggerType}`;
			if (!this._isDeveloperMode) {
				throw new Error(msg);
			}
			// FIXME: This will by silent for most people, and suddenly fail in prod.
			// We should probably not care about a file with a missing plugin if
			// there are no triggers/channels in it. We can probably just have
			// a single error (the "no plugin registered" below) for triggers and
			// channels which is handled with an error message in dev and thrown
			// error in prod.
			this._logger.trace(msg);
			// We didn't manage to find a plugin for that particular type of
			// triggers. This could be due to the fact that the plugin have
			// been uninstalled and as we do not do clean up, the respective
			// conf file is still on disk. We would like to register all
			// channels/triggers, but disable them so the users are aware of
			// this in the UI.
		} else {
			// we have a plugin definition, validate it
			this.checkAbortStartup({ file, triggerType, definition, config });
			this.assignTriggerTemplate(triggerType, definition, config);
		}

		// create channels
		for (const channelId in config.channels) {
			const channConfig = config.channels[channelId];

			this.channelValidation({
				file,
				definition,
				channelId,
				channConfig
			});
			const channelCrumbs = `${file} > channels > ${channelId}`;
			if (!channConfig.enabled) {
				this._logger.debug(
					`Channel disabled: ${channelCrumbs}`);
				continue;
			}
			// create and persist instance
			this._logger.trace(
				`Creating channel: ${channelCrumbs}`);
			try {
				const channel = await this.createChannel({
					triggerType,
					channelId,
					channelConfig: channConfig,
					definition
				});
				this.addInstance('channels', triggerType, channelId, channel);
				this._logger.debug(
					`Created channel: ${channelCrumbs}`
				);
			} catch (err) {
				// Can throw the error in prod, or just continue.
				this.handleTriggerError(
					err, `Failed to start channel: ${channelCrumbs}`);
			}
		}

		// create flow-triggers
		for (const triggerId in config.triggers) {
			const triggerConfig = config.triggers[triggerId];
			const info = this.addTriggerInfo({
				triggerType,
				triggerId,
				triggerConfig,
				config
			});
			const triggerCrumbs = `${file} > triggers > ${triggerId}`;

			if (definition && triggerConfig.enabled === false) {
				this._logger.debug(
					`Trigger disabled: ${triggerCrumbs}`
				);
				this.setState(info, 'Disabled at source.', { valid: true });
				continue;
			}

			try {
				this.triggerValidation({
					file,
					definition,
					triggerId,
					config
				});
			} catch (err) {
				if (this._isDeveloperMode && err instanceof ProductionError) {
					// If in development mode and this is a production error,
					// then add the trigger in an error state.
					this._logger.warn(err);
					this.setState(info, err.message);
					continue;
				} else {
					throw err;
				}
			}

			try {
				this._logger.trace(`Creating trigger: ${triggerCrumbs}`);

				if (!definition) {
					// We'll actually never get here in production. There's a duplicate
					// error above which will be caught first. ProductionError
					// lets this get logged in the same way as other errors in the catch
					// below.
					throw new ProductionError(
						`No plugin registered for flow-trigger type: ${triggerType}`
					);
				}

				const triggerInstance = await this.createTrigger({
					file,
					triggerConfig,
					type: triggerType,
					id: triggerId,
					definition
				});

				this._logger.trace(`Created trigger: ${triggerCrumbs}`);

				this.addInstance(
					'triggers', triggerType, triggerId, triggerInstance);

				this._logger.trace(`Starting trigger: ${triggerCrumbs}`);

				// start the trigger instance
				await this.startTriggerInstance(triggerInstance);

				this._logger.debug(`Started trigger: ${triggerCrumbs}`);
			} catch (err) {
				// Can throw the error or return the reason for failure.
				const reason = this.handleTriggerError(
					err, `Failed to start flow-trigger: ${triggerCrumbs}`);
				// If we're not aborting then update the trigger state.
				this.setState(info, reason);
			}
		}
	}

	/**
	 * Handles errors when creating/starting flow-trigger/channels.
	 * The error is logged with a message.
	 * If the error is a PluginError or if the service is in production
	 * a new error will get thrown. Otherwise, the error message will
	 * be returned as "reason".
	 * @param {*} err - the thrown error
	 * @param {string} message - the message to log with the error.
	 * @returns {string} The reason (most of the time err.message)
	 */
	handleTriggerError(err, message) {
		this._logger.error(`${message}.`, err || 'Unknown error');
		// Handle it if the error is undefined/null
		const reason = err && err.message || 'Unknown error';
		if (!this._isDeveloperMode || err instanceof PluginError) {
			// In production, or if we get a PluginError, we want to
			// throw and abort the start up. Otherwise, continue.
			throw new Error(`${message}. ${reason}`);
		}
		return reason;
	}

	/**
	 * Starts a trigger instance.
	 * @param {object} instance - The instance to start.
	 * @return {Promise} Resolves when started.
	 * @async
	 */
	async startTriggerInstance(instance) {
		/**
		 * Callback that is used to start the invoke.
		 * @param {*} data - The request to pass to the instance `onInvoke`.
		 * @param {object} [options] - invoke options
		 * @param {string} [options.requestId] - A unique request ID to use
		 * instead of generating a new ID. Used when a trigger has an existing
		 * ID for traceability.
		 * @return {Object} Resolves with { value } when successful or with
		 * `{ value, error: true }` when an error occurred (the `value` is
		 * the exception).
		 * @async
		 */
		const startInvoke = async (data, options = {}) => {
			if (this._stopped) {
				// Server stopped before startInvoke.  Do not use the logger
				// here as TM is destroyed.  Just return an error.
				return {
					error: true,
					value: new Error('startInvoke called after server stopped')
				};
			}

			const requestId = options.requestId || uuid.v4();

			// Scope a new logger for logging a unique flow invocation.
			const logger = this._logger.getScoped(
				`[${instance.type}: ${instance.id}] [request-id: ${requestId}]`
			);

			const response = {};

			try {
				// keep a local copy of apibuilder in case TM is destroyed
				const apibuilder = this._apibuilder;
				// It is possible for flow-triggers to start invoking requests
				// while the service is actually starting.  This blocks until
				// the service started.
				try {
					await apibuilder._internal.state.started;
					// only count triggers that are triggered by something outside builder
					if (instance.external) {
						apibuilder._internal.countTransaction();
					}
				} catch (ex) {
					logger.info('Triggered');
					throw ex;
				}

				logger.info('Triggered');

				if (apibuilder.stopped || apibuilder.shuttingdown) {
					logger.error('Finished (failed)', stoppedMessage);
					// Server started, but was stopped while this code was
					// waiting for the promise to resolve.
					return {
						error: true,
						value: new Error(stoppedMessage)
					};
				}
				const { parameters, flow: flowId } = instance.config.invoke;
				const invoke = bindInvoke({
					logger,
					parameters,
					flowId,
					flowManager: this._flowManager,
					triggerManager: this
				});

				response.value = await instance.onInvoke({ logger, invoke, data });
				logger.info('Finished');
			} catch (ex) {
				logger.error('Finished (failed)', ex);
				response.error = true;
				response.value = ex;
			}
			return response;
		};

		const options = {
			onUnstable: message => {
				if (this._stopped) {
					// `onUnstable` called too late. Trigger manager instance
					// is stopped. This could happen when plugin is not
					// handling onUnstable invocations properly. At this stage
					// we don't have logger anymore. Log this anomaly and exit.
					// eslint-disable-next-line no-console
					console.error(
						`onUnstable called after destroying trigger "${instance.type}/${instance.id}"`);
				} else {
					const msg = `Unstable trigger "${instance.id}": ${message}`;
					this._logger.warn(msg);
					this._apibuilder.emit('unstable', msg);
				}
			}
		};

		return instance.start(startInvoke, options);
	}

	/**
	 * Gets a path to the trigger config file for `triggerType`.
	 * @param {string} triggerType - The type of flow-trigger.
	 * @returns {string} A path to the trigger config file.
	 */
	getTriggerConfigPath(triggerType) {
		return path.join(this._triggersDir, `${triggerType}.yaml`);
	}

	/**
	 * Reads and decodes a trigger configuration file
	 * @param {string} file - The full path to the trigger file to load.
	 * @throws {Error} - Throws an error if a trigger file is invalid or
	 * doesn't exist
	 * @async
	 */
	async readTrigger(file) {
		const data = await afs.readFile(file);
		const config = YAML.safeLoad(data);
		if (!this.ajv.validate(triggerConfigSchema.$id, config)) {
			const ajvError = JSON.stringify(this.ajv.errors[0]);
			throw new Error(`Invalid flow-trigger file '${file}': ${ajvError}`);
		}
		return config;
	}

	/**
	 * Gets the current configuration by flow-trigger `type`.  If the config
	 * file exists, it is returned.  If it does not exist, an empty config is
	 * generated according to the `definition` if provided.
	 * @param {string} triggerType - The trigger type.
	 * @param {object} [definition] - The trigger definition.
	 * @returns {object} The trigger config.
	 * @throws {Error} if the definition for `type` does not exist.
	 */
	async getCurrentConfig(triggerType, definition) {
		const configPath = this.getTriggerConfigPath(triggerType);
		let config;
		if (await utils.exists(configPath)) {
			config = await this.readTrigger(configPath);
		} else {
			// ensure config has triggers if we are just creating the config
			config = {
				triggers: {}
			};
		}
		// ensure config has channels if it's in the definition.
		if (definition && definition.createChannel && !config.channels) {
			config.channels = {};
		}
		return config;
	}

	/**
	 * Reads, decodes, and validates a trigger configuration file
	 * and once loaded, calls `register`.
	 * @param {string} file - The full path to the trigger file to load.
	 * @throws {Error} - Throws an error if a trigger couldn't successfully
	 * register. If an error is thrown, we should abort the start up.
	 * @async
	 */
	async loadTrigger(file) {
		this._logger.trace('Loading trigger config:', file);
		const config = await this.readTrigger(file);
		// Any errors encountered during the registering of the triggers should
		// abort the start up
		await this.register(file, config);
	}

	/**
	 * Stops managed instances of type `triggers` or `channels`.
	 * @param {string} instanceType - The managed item type to stop, one of:
	 * triggers|channels.
	 * @return {number} The number of rejected promises.
	 */
	async _stopManaged(instanceType) {
		const stopPromises = [];
		for (const type in this._instances[instanceType]) {
			for (const id in this._instances[instanceType][type]) {
				const instance = this._instances[instanceType][type][id];
				this._logger.debug(`Stopping ${instanceType}: ${type} > ${id}`);
				stopPromises.push(instance.destroy());
			}
		}

		const results = await utils.allSettled(stopPromises);
		const rejected = results.filter(a => a.status === 'rejected');
		for (const reject of rejected) {
			this._logger.error(
				`There were ${rejected.length} error(s) stopping ${instanceType}:`,
				reject.reason
			);
		}
		return rejected.length;
	}

	/**
	 * Stops all trigger channels and instances.  Once stopped, this
	 * TriggerManager instance can no longer be used.
	 * @async
	 */
	async stop() {
		this._stopped = true;
		this._logger.debug('Stopping flow-triggers');
		let rejectedCount = await this._stopManaged('triggers');
		rejectedCount += await this._stopManaged('channels');

		// Cleanup references.  The most important bit is the circular
		// reference to apibuilder.
		delete this._apibuilder;
		delete this._logger;
		delete this._config;
		delete this._flowManager;
		delete this._triggersInfo;
		delete this._instances;
		delete this.ajv;

		if (rejectedCount) {
			throw new Error('Error stopping flow-triggers');
		}
	}

	/**
	 * Deletes all triggers for a particular flow.
	 * @param {object} flowId - The id of the flow that is bound.
	 * @async
	 */
	async deleteTriggersForFlow(flowId) {
		const triggerUpdates = {};

		// Our update object to just removes all known triggers. processTriggerUpdates
		// is responsible for only modifying those related to the specified flowId
		for (const type in this._triggersInfo.triggers) {
			// Specify that the flow has no triggers of this type.
			triggerUpdates[type] = {};
		}

		// Process the updates and write the changes to disk
		await this.processTriggerUpdates(flowId, triggerUpdates);
	}

	/**
	 * Writes modifications to trigger config on disk for the triggers
	 * provided. Batches all modifications for a type into a single write.
	 *
	 * @param {object} flowId - The id of the flow that is updated.
	 * @param {object} triggerInfoUpdates - Triggers info updates that needs to
	 * be applied ordered by trigger type.
	 * @async
	 */
	async processTriggerUpdates(flowId, triggerInfoUpdates) {

		/**
		 * Based on a list of existing triggers it generates the next available
		 * trigger id. It has the format of: `{type}-{next-available-number}`.
		 *
		 * @param {string} type - The type of the trigger - i.e. 'solace'.
		 * @param {Object} triggers - The existing triggers.
		 */
		function getNextInstanceID(type, triggers) {
			let nodeId;
			let i = 0;
			do {
				nodeId = `${type}-${++i}`;
			} while (triggers[nodeId]);

			return nodeId;
		}

		this._logger.debug('Saving changes to flow-triggers');

		const configs = {};
		// The triggerInfoUpdates always include all of the triggers for that
		// particular flow, regardless if they had changes or not - we always
		// send everything.
		for (const type in triggerInfoUpdates) {
			// The current configuration as is on disk.
			const definition = this.getDefinitionInfo(type);
			const currentConfig = await this.getCurrentConfig(type, definition);

			// All the updates for that given type - i.e. solace.
			const updatesForType = triggerInfoUpdates[type];

			// Walk over each trigger in the existing config
			for (const triggerId in currentConfig.triggers) {
				const triggerConfig = currentConfig.triggers[triggerId];
				if (triggerConfig.invoke.flow !== flowId) {
					// do not touch triggers that invoke another flow
					continue;
				}

				const triggerInfoUpdate = updatesForType[triggerId];
				if (triggerInfoUpdate) {
					// Allow updates only if there is a trigger definition available
					// for this type of trigger. This would prevent making updates
					// to uninstalled triggers.
					if (definition) {
						// apply updated info to the trigger config
						triggerConfig.name = triggerInfoUpdate.instanceName;
						if (triggerInfoUpdate.triggerParameters) {
							triggerConfig.parameters
								= triggerInfoUpdate.triggerParameters;
						}

						if (triggerInfoUpdate.channelParameters) {
							currentConfig.channels[triggerInfoUpdate.channelId]
								.parameters = triggerInfoUpdate.channelParameters;
						}

						if (triggerInfoUpdate.flowInputsMap) {
							triggerConfig.invoke.parameters
								= triggerInfoUpdate.flowInputsMap;
						}
					}

					// Remove all trigger entries from the update that we found, so
					// the remaining triggers in the list are considered NEW.
					delete updatesForType[triggerId];
				} else {
					// delete triggers that are not present in the updates
					delete currentConfig.triggers[triggerId];
				}
			}

			let isNewFlow = false;

			// Iterate over the NEW triggers
			for (const triggerId in updatesForType) {

				// Create new triggers ONLY for the ones who have definition.
				if (definition) {
					const trigger = updatesForType[triggerId];

					// We have the notion of setting the flowId in the UI to
					// this temporary value when the flow is new and does not
					// exist yet. We need to use that to determine if the flow
					// that these triggers have been added to is new so we could
					// exclude the portion of the semantic validation that
					// validates it. This is required as the semantic validation
					// doesn't have that info as the flowId passed with the
					// configuration is the newly generated flowId and no longer
					// this temporary id.
					if (trigger.flowId === '$$_new_flow') {
						isNewFlow = true;
					}

					const newTrigger = {
						name: trigger.instanceName,
						parameters: trigger.triggerParameters,
						enabled: true, // Enable it by default on creation
						invoke: {
							// Use flowId rather than what comes from the trigger
							// as it will not work for newly created flows
							// which have their IDs after saving
							flow: flowId
						}
					};

					// The creation of channels happens only when we create new
					// triggers. All legacy triggers would already have channels
					// otherwise we wouldn't have started...
					const channelId = trigger.channelId;
					if (channelId) {
						newTrigger.channel = channelId;

						// If there is an already existing channel, update it
						if (currentConfig.channels[channelId]) {
							currentConfig.channels[channelId]
								.parameters = trigger.channelParameters;
						} else {
							currentConfig.channels[channelId] = {
								enabled: true,
								name: definition.name,
								parameters: trigger.channelParameters
							};
						}
					}

					if (trigger.flowInputsMap) {
						newTrigger.invoke.parameters = trigger.flowInputsMap;
					}

					// Find the next available instance id so we know how to insert
					// the new trigger as.
					const newId = getNextInstanceID(type, currentConfig.triggers);

					currentConfig.triggers[newId] = newTrigger;
				}
			}

			// Do validate only if we have trigger definition for this type.
			// If we don't, the only allowed action was delete.
			if (definition) {
				// Validate the configuration before we attempt to persist it on disk
				this.semanticValidation({
					// Normally, this is the file name, however as we do not have
					// anything on disk yet, we are using the trigger type.
					file: type,
					definition,
					config: currentConfig,
					isNewFlow
				});
			}

			configs[type] = currentConfig;
		}

		if (Object.keys(configs).length) {
			return this.writeTriggerConfigUpdates(configs);
		}
	}

	/**
	 * Writes changes for provided configs to disk for each type, as yaml.
	 * Will preserve the original filename by looking up the path from _files
	 * that was set when the config was registered.
	 * @internal
	 * @param {object} configs - map of config files to convert to yaml and write
	 * to disk. The key is the type of flow-trigger, the value is the data.
	 * @throws {Error} if flow-trigger write failed or data could not be
	 * stringified as yaml.
	 */
	async writeTriggerConfigUpdates(configs) {
		const pathExists = await utils.exists(this._triggersDir);
		if (!pathExists) {
			// ensure "triggers" directory; cannot use mkdir recursive yet as
			// it is only in node 10+.
			await afs.mkdir(this._triggersDir);
		}

		let errors = false;
		await Promise.all(Object.keys(configs).map(async type => {
			const file = this.getTriggerConfigPath(type);
			this._logger.trace(`Writing ${type} flow-trigger changes to ${file}`);
			// write out the YAML skipping keys with undefined values
			try {
				const yaml = YAML.safeDump(configs[type], { skipInvalid: true });
				await afs.writeFile(file, yaml);
			} catch (err) {
				this._logger.error(`Failed to write flow-trigger ${type} changes to ${file}`, err);
				errors = true;
			}
		}));
		if (errors) {
			throw new Error('Failed to write flow-trigger config changes');
		}
	}

	/**
	 * Validate trigger updates.  The `triggers` input is a map of nested
	 * objects: _trigger_ : _type_ : _id_.  Returns a validation response.
	 * The `response.valid` is a boolean that indicates whether or not any
	 * error(s) were detected.  The `response.errors` is an array of objects
	 * where each object details the type of error found.  i.e. NOT_IN_SPEC,
	 * INVALID_JSONPATH or MISSING_VALUE.
	 *
	 * @param {Object} [triggers] - An object map of trigger updates.
	 * @param {Object} [flowInputSchema] - The flow input parameters portion
	 * of the flow schema.  The flow input parameter is optional:
	 * https://git.ecd.axway.org/amplify/api-builder/-/blob/0170f198a67369c89e4797cc269f33cfe0b301b2/packages/axway-flow-schema/flowschema-v4.json#L40
	 *
	 * @return {Object} A validation response `{ valid: true, errors: [] }`.
	 * @example
	 * ```js
	 * const result = tm.validateTriggerUpdates({
	 *   timer: {
	 *     mytimer: {
	 *       instanceName: 'Timer',
	 *       parameters: { interval: 'what' }
	 *     }
	 *   }
	 * });
	 * console.log(result.valid); // => false
	 * console.log(result.errors); //
	 * ```
	 */
	validateTriggerUpdates(triggers, flowInputSchema) {
		const result = { valid: true, errors: [] };

		validateTriggers({
			ajv: this.ajv,
			triggers,
			definitions: this._triggersInfo.definitions,
			flowInputSchema,
			onError: (info) => {
				const { id, type, code, name, errorType, errors } = info;
				const error = {
					type: errorType,
					code,
					detail: {
						id,
						type
					}
				};
				if (name !== undefined) {
					error.detail.parameter = name;
				}
				if (errors !== undefined) {
					error.detail.errors = errors;
				}
				result.errors.push(error);
			}
		});

		result.valid = !result.errors.length;
		return result;
	}
}

function getTypeFromFile(file) {
	return path.basename(file, path.extname(file));
}

/**
 * Creates a `invoke` function that can be used to invoke a flow.
 * @param {Object} options - The bind options.
 * @param {string} flowId - The id of the flow.
 * @param {Object} flowManager - The `FlowManager` instance.
 * @param {Object} parameters - The flow parameters.
 * @returns {Promise} Resolves when the flow completes.
 * @async
 */
function bindInvoke(options) {
	const {
		logger,
		flowId,
		flowManager,
		parameters,
		triggerManager
	} = options;

	/**
	 * Invokes the flow that corresponds to the current flow-trigger
	 * @param {*} request - The trigger request ($.request)
	 * @returns {*} The flow response
	 * @throws {*} An error thrown by the flow
	 */
	return async function invoke(request) {
		const data = triggerManager.getResolvedParameters(parameters, request);

		try {
			const { name: flowName } = flowManager.getFlow(flowId).info;
			const nameAndId = chalk.green(`${flowName} (id: ${flowId})`);
			const args = [
				'Invoking flow:',
				nameAndId
			];
			if (request) {
				args.push('$.request is\x1b[33m', request, '\x1b[0m');
			} else {
				args.push('$.request has no value');
			}
			logger.debug(...args);
			const response = await flowManager.flow(flowId, data, { logger });
			logger.debug('Flow completed:', nameAndId);
			return response;
		} catch (ex) {
			// The AJV errors comes back as an object, we need to transform this
			// into something that makes sense and throw a new Error with it.
			if (!(ex instanceof Error)) {
				const errors = JSON.stringify(ex.errors || ex);
				throw new Error(`Error invoking flow '${flowId}'. Errors: ${errors}`);
			}

			logger.error('Error triggering flow:', ex);
			// Rethrow the error and let the flow-trigger plugin handle the
			// exception.
			throw ex;
		}
	};
}

/**
 * Checks if the provided id is valid. Ids must be simple with no encoding required.
 * They will fail the check if the ID contains RFC3986 unsafe characters.
 * @param {string} id the id to validate
 * @returns {boolean} The validation status
 */
function isValidID(id) {
	return id === utils.encodeNameForURI(id);
}

/**
 * Replace parameters that use selectors with their corresponding values
 * taken from global places like config, env, and request.
 */
function resolveParameters(globals, parameters) {
	const data = {};
	for (const name in parameters) {
		const param = parameters[name];
		data[name] = param;
		// note that `$` is here for compatibility with the UI, which is a
		// valid jsonpath, but is not in this context because it would
		// resolve to an object, which is not valid.
		if (isJSONPath(param)) {
			const value = getByJsonPath(param, globals);
			data[name] = value;
		}
	}
	return data;
}

function isJSONPath(value) {
	return value
		&& value.startsWith
		&& (value === '$' || value.startsWith('$.'));
}

/**
 * We would like to preselect and display the default value of the enum
 * properties if such value is set on the schema with fallback to the first
 * example or the first item in the enum. Examples makes sense in cases where
 * the enum contain a lot of values and we want to the most commonly used rather
 * than the first one. Setting the value here will remove remove the needs to
 * render those properties as selectors initially.
 *
 * @param {Object} definitionParameters - Definition parameters.
 * @param {Object} parameters - Trigger/channel parameters.
 */
function setInitialValuesForEnumParameters(definitionParameters, parameters) {
	const properties = definitionParameters.properties;
	for (const propName in properties) {
		const prop = properties[propName];
		if (prop.enum && definitionParameters.required
			&& definitionParameters.required.includes(propName)) {
			if (prop.default !== undefined) {
				parameters[propName] = prop.default;
			} else if (prop.examples !== undefined && prop.examples.length > 0) {
				parameters[propName] = prop.examples[0];
			} else {
				parameters[propName] = prop.enum[0];
			}
		}
	}
}

module.exports = TriggerManager;
