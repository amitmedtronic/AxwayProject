const fs = require('fs');
const util = require('util');
const _ = require('lodash');
const semverSatisfies = require('semver/functions/satisfies');
const strictUriEncode = require('strict-uri-encode');
const findUp = require('find-up');
const APIBuilder = require('./apibuilder');

const afs = {
	access: util.promisify(fs.access)
};

/**
 * Replace path params to a placeholder identifier. /foo/:id and /foo/:bar
 * should transform to /foo/:pathParamPlacehdr.
 * @param {*} fullpath the full path
 * @return {string} transformed fullpath (eg, /foo/:pathParamPlacehdr)
 */
function pathTransform(fullpath) {
	return fullpath.replace(/(:(.*?)(?=\/|$))/g, ':pathParamPlacehdr');
}

/**
 * Helps in destroying idle sockets when closing the server.
 *
 * @param {*} server the decorated server
 */
function enableGracefulDestroy(server) {
	const sockets = {};
	let nextSocketId = 0;
	server.on('connection', (socket) => {
		const socketId = nextSocketId++;
		sockets[socketId] = socket;
		socket.on('close', () => {
			delete sockets[socketId];
		});
	});

	server.destroy = (cb) => {
		for (let key in sockets) {
			sockets[key].destroy();
		}
		server.close(cb);
	};
}

/**
 * Encodes a name for use in an ExpressJS URI.  Note that while the model `name` is
 * "safe" - it was checked using `encodeURI`, but it is not a valid URI.  E.g. A?B is a
 * valid model name, and it is encodeURI as `A?B`.  As a URI, it means path A and query B,
 * and that is not intended.  We want to bind on: /api/{name}, so `name` must be encoded
 * so that A%3FB matches the path component.
 *
 * @param {string} name - The name to encode for a URI.
 * @return {string} The encoded name.
 */
function encodeNameForURI(name) {
	return strictUriEncode(name.toLowerCase());
}

/**
 * Recursively merges own and inherited enumerable properties of `sources` objects
 * into the `target` object.  This will also optionally merge in `constructor` if
 * any exist in `sources`.  Source properties that resolve to undefined are skipped if
 * a destination value exists.  Array and plain object properties are merged
 * recursively. Other objects and value types are overridden by assignment. Source
 * objects are applied from left to right. Subsequent sources overwrite property
 * assignments of previous sources.
 *
 * @param {object} target - The target object.
 * @param {object} sources - The sources to merge.
 * @return {object} The `target` object.
 */
function mergeWithConstructor(target, ...sources) {
	_.merge(target, ...sources);
	for (const source of sources) {
		if (source.hasOwnProperty('constructor')) {
			target.constructor = source.constructor;
		}
	}
	return target;
}

/**
 * Returns a promise that resolves after all the given promises has been
 * either fulfilled or rejected, with an array of objects that each
 * describes the outcome of each promise.  This is temporary until we
 * move to node 12.
 * @param {Promise[]} promises - An array of promises.
 * @returns A promise that will resolve to an objects describing the outcome
 * of each promise.
 * @async
 */
function allSettled(promises) {
	const wrappedPromises = promises.map((promise) => {
		// Ensure that the item is actually a promise by wrapping it in resolve
		return Promise.resolve(promise)
			.then(
				val => ({ status: 'fulfilled', value: val }),
				err => ({ status: 'rejected', reason: err })
			);
	});
	return Promise.all(wrappedPromises);
}

/**
 * Determines if `file` exists, and if it can be written to.
 * @param {string} file - The filename to check.
 * @param {number} [mode=F_OK|W_OK] - The mode (see fs.constants).
 * @returns {boolean} `true` if the file exists, `false` if it does not.
 * @throws {Error} If there was a failure accessing the file other than
 * it not existing.
 */
async function exists(file, mode = fs.constants.F_OK | fs.constants.W_OK) {
	try {
		await afs.access(file, mode);
	} catch (ex) {
		if (ex.code === 'ENOENT') {
			return false;
		} else {
			// file exists, but cannot write to it or something
			throw ex;
		}
	}
	return true;
}

/**
 * Returns a logger that is a suitable replacement for Logger with the
 * intention that it be used in cases where there are cyclical dependencies
 * or when there is a preference for deferring messages, e.g. the Loader.
 */
function createDeferredLogger() {
	const logs = {
		trace: [],
		debug: [],
		info: [],
		warn: [],
		error: [],
		fatal: []
	};
	return {
		trace: function (...args) { logs.trace.push(args); },
		debug: function (...args) { logs.debug.push(args); },
		info: function (...args) { logs.info.push(args); },
		warn: function (...args) { logs.warn.push(args); },
		error: function (...args) { logs.error.push(args); },
		fatal: function (...args) { logs.fatal.push(args); },
		logAll: function (logger) {
			for (const level of Object.keys(logs)) {
				for (const msg of logs[level]) {
					logger[level](...msg);
				}
				logs[level] = []; // reset use
			}
		}
	};
}

/**
 * Checks if the process is running in a known EOL Node.js version
 * @returns {boolean} true if EOL, false otherwise
 */
function isUsingEOLNodeVersion() {
	// Next updates:
	// v17 will be EOL on 2022-06-01
	// v14 will be EOL on 2023-04-30
	return semverSatisfies(process.version, '<14.x || 15.x');
}

/**
 * Checks if the process is running in Node.js 14.x version
 * @returns {boolean} true if yes, false otherwise
 */
function isUsingNode14() {
	// In v5 we want to go to node 16 minimum, so we need to deprecate 14
	return semverSatisfies(process.version, '14.x');
}

/**
 * Gets the package.json for a dependency
 * @param {string} id - module to get package.json for, as if using `require()`
 * @returns {object} package.json object
 */
function getPackageJson(id) {
	const dir = require.resolve(id);
	const pkgPath = findUp.sync('package.json', { cwd: dir });
	const contents = fs.readFileSync(pkgPath);
	return JSON.parse(contents);
}

/**
 * Validates that the current api-builder version satisfies a module's runtime version requirement
 * @param {object} pkginfo - package.json for a module
 * @param {object} apibuilder - api builder instance
 */
function validateModuleCompatibility(pkginfo, apibuilder) {
	const { registerDeprecationUse, logger } = apibuilder;
	const name = pkginfo.name;
	const engine = pkginfo.engines && pkginfo.engines.apibuilder;

	// Validate that the module's API Builder requirements are satisfied
	validatePackageEngine(name, engine, logger);

	if (pkginfo.peerDependencies && pkginfo.peerDependencies['@axway/api-builder-runtime']) {
		registerDeprecationUse('runtimePeerDependency', name);
	}
}

/**
 * Validate that the module's API Builder requirements are satisfied
 * @param {string} name - module name
 * @param {string} engine - semver engine range
 * @param {object} logger - logger
 * @throws When module is incompatible with the current version of API Builder
 */
function validatePackageEngine(name, engine, logger) {
	if (engine) {
		// Trim prerelease bits. Avoids issues when testing using prerelease versions and allows
		// plugins which require >=4.70.0 to work on 4.71.0-rdpp-1234
		const currentVersion = APIBuilder.Version.split('-')[0];
		logger.trace(`Checking version requirement for ${name} (${engine})`);
		if (!semverSatisfies(currentVersion, engine)) {
			throw new Error(`${name} requires @axway/api-builder-runtime ${engine}. Currently using ${currentVersion} (${APIBuilder.Release})`);
		}
	}
}

module.exports = {
	enableGracefulDestroy,
	encodeNameForURI,
	mergeWithConstructor,
	allSettled,
	exists,
	createDeferredLogger,
	isUsingEOLNodeVersion,
	isUsingNode14,
	getPackageJson,
	validateModuleCompatibility,
	validatePackageEngine,
	pathTransform
};
