const path = require('path');
const TriggerManager = require('./triggers');
const { MiddlewareManager } = require('./express/MiddlewareManager');
const apiBuilderConfig = require('@axway/api-builder-config');
const utils = require('./utils');

const flowInvokeModelURI = 'nodehandler://api-builder-flow-invoke/model/';

/**
 * All private internal interfaces
 * @private
 */
function getInternalInterface () {
	// Placeholder for promise resolve/reject funcs: started.
	// E.g.: state.started.resolve();
	const state = {};
	const statePromises = {};
	const triggerManager = new TriggerManager();
	const middlewareManager = new MiddlewareManager();

	triggerManager.setAPIBuilder(this);

	return {
		/**
		 * Creates a new promise and assigns it to the internal state
		 * with property `name`.  It returns the promise, and resolve, reject
		 * functions.
		 * @param {string} name - The name of the promise.
		 * @param {function} catchHandler - Optional. If provided it will be
		 * attached as catch handler to the created Promise.
		 * @returns {object} `{ promise, resolve, reject }`
		 * @example
		 * const { promise, resolve, reject } = this.createPromiseState('foo');
		 */
		getPromiseState: (name, catchHandler) => {
			if (state[name]) {
				// existing state
				return state[name];
			}
			// create a new promise and assign it to internal state
			// by `name` (e.g. `apibuilder.state.started`).
			state[name] = {};
			state[name].promise = new Promise((resolve, reject) => {
				state[name].resolve = resolve;
				state[name].reject = reject;
			});
			if (catchHandler) {
				state[name].promise.catch(catchHandler);
			}
			// cleaner than reduce on `state`
			statePromises[name] = state[name].promise;
			return state[name];
		},

		/**
		 * Gets the internal promise state properties.
		 */
		get state() {
			return statePromises;
		},

		setApiSpecs: (apiSpecs) => {
			this._internal.apiSpecs = apiSpecs;
		},

		getApiSpecs: () => {
			return this._internal.apiSpecs || [];
		},

		setApiSpecTypes: (apiSpecTypes) => {
			this._internal.apiSpecTypes = apiSpecTypes;
		},

		getApiSpecTypes: () => {
			return this._internal.apiSpecTypes || {};
		},

		getPathManager: () => {
			return this._internal.pathManager;
		},

		setPathManager: (pathManager) => {
			this._internal.pathManager = pathManager;
		},

		getMiddlewareManager: () => {
			return middlewareManager;
		},

		setDynamicOpenAPI: (url, spec) => {
			this._internal.dynamicOpenAPI = spec;
			this._internal.dynamicOpenAPIURL = url;
		},

		getDynamicOpenAPI: () => {
			return {
				spec: this._internal.dynamicOpenAPI,
				url: this._internal.dynamicOpenAPIURL
			};
		},

		/**
		* Indicates that there are no plugged services (e.g. OAS) and
		* disableEndpoints flag is disabled.
		*/
		get endpointsEnabled() {
			const disableEndpoints = apiBuilderConfig.flags.disableEndpoints;
			return !disableEndpoints && !Object.keys(this.getApiSpecTypes()).length;
		},

		// Describes the API Builder service
		getServiceInfo: () => {
			// If http is disabled, do not set the port. We are setting this.port regardless if it
			// is being disabled or not, but we do not want this to leak into plugins.
			const port = this.config.http.disabled ? undefined : this.port;
			return {
				apiPrefix: this.config.apiPrefix,
				port,
				sslPort: this.config.ssl && this.config.ssl.port,
				security: this.authStrategy.getSwaggerSecurity(),
				overrides: this.config.apidoc.overrides
			};
		},

		/**
		 * Gets endpoint information.
		 *
		 * @private
		 * @param {string} name - The endpoint name to return.
		 * @return {object} The endpoint information object.
		 */
		getEndpointInfo: (name) => {
			return this.endpoints[name];
		},

		setEndpointTriggers: (endpointTriggers) => {
			this._internal.endpointTriggers = endpointTriggers;
		},

		getEndpointTriggers: () => {
			return this._internal.endpointTriggers;
		},

		getTriggerManager: () => {
			return triggerManager;
		},

		setBillingManager: billingManager => {
			this._internal.billingManager = billingManager;
		},

		getBillingManager: () => {
			return this._internal.billingManager;
		},

		countTransaction: () => {
			if (!this._internal.billingManager) {
				return;
			}
			this._internal.billingManager.countTransaction();
		},

		setUnavailable: (message) => {
			this._internal.unavailable = message;
		},

		isUnavailable: () => {
			return !!this._internal.unavailable;
		},

		getUnavailableMessage: () => {
			return this._internal.unavailable;
		},

		validatePackageEngine: (name, engine) => {
			utils.validatePackageEngine(name, engine, this.logger);
		},

		pluginUse: {
			registerAPI: api => {
				const { pluginUse } = this._internal;
				const methodPath = `${api.method.toUpperCase()} ${api.path}`;
				if (api.model) {
					const plugin = pluginUse.getPluginForModel(api.model.name);
					pluginUse.register(plugin, 'apis', methodPath, api.model.name);
				}
				if (api.response) {
					const plugin = pluginUse.getPluginForModel(api.response.name);
					pluginUse.register(plugin, 'apis', methodPath, api.response.name);
				}
			},

			registerFlow: (flow, fn) => {
				const { pluginUse } = this._internal;
				const def = flow.flow;
				for (const id in def.nodes) {
					const node = def.nodes[id];
					const plugin = pluginUse.getPluginForFlownode(node.type);
					const nodeName = this.flowManager
						.getRegisteredNodeSpec(node.type).name;
					pluginUse.register(plugin, 'flows', flow.id, {
						fn: path.relative(path.join(this.config.dir, 'flows'), fn),
						instance: node.name,
						name: nodeName
					});
				}
			},

			registerEndpoint: (path, flowID) => {
				const { pluginUse } = this._internal;
				const flow = this.flowManager.cache[flowID];
				const def = flow.flow;
				for (const id in def.nodes) {
					const node = def.nodes[id];
					const plugin = pluginUse.getPluginForFlownode(node.type);
					const nodeName = this.flowManager
						.getRegisteredNodeSpec(node.type).name;
					pluginUse.register(plugin, 'endpoints', path, {
						name: nodeName,
						instance: node.name
					});
					// Since we know the endpoint is using the plugin
					// then we don't care about the flow independently.
					pluginUse.unregister(plugin, 'flows', flowID);
				}
			},

			registerModel: model => {
				const { pluginUse } = this._internal;
				const connectorName = typeof model.connector === 'object'
					? model.connector.name : model.connector;
				let parentPlugin;
				if (model._supermodel) {
					parentPlugin = pluginUse.getPluginForModel(model._supermodel);
				}

				if (parentPlugin) {
					// It was extended or reduced from another model
					pluginUse.register(parentPlugin, 'models', model.name, {
						model: model._supermodel
					});
				} else if (connectorName === 'composite') {
					for (const field in model.fields) {
						if (model.fields[field].model) {
							const plugin = pluginUse
								.getPluginForModel(model.fields[field].model);
							pluginUse.register(plugin, 'models', model.name, {
								model: model.fields[field].model
							});
						}
					}
				} else if (connectorName !== 'memory') {
					const plugin = pluginUse.getPluginForConnector(connectorName);
					pluginUse.register(plugin, 'models', model.name, {
						connector: connectorName
					});
				}
			},

			registerConnector: (plugin, connector) => {
				this._internal.pluginUse.register(
					plugin, 'connectors', connector, 'modelAutogen'
				);
			},

			register: (plugin, type, id, details) => {
				if (!plugin) {
					return;
				}
				const info = this.apibuilderPlugins[plugin];
				if (!info) {
					return;
				}
				info.usage = info.usage || {};
				info.usage[type] = info.usage[type] || {};
				info.usage[type][id] = details;
			},

			unregister: (plugin, type, id) => {
				const info = this.apibuilderPlugins[plugin];
				if (info && info.usage && info.usage[type]) {
					delete info.usage[type][id];
				}
			},

			getPluginForFlownode: id => {
				const { pluginUse } = this._internal;
				// ew
				if (id.startsWith('nodehandler://axway-flow')) {
					return;
				} else if (id.startsWith(flowInvokeModelURI)) {
					const modelName = id.substring(flowInvokeModelURI.length);
					return pluginUse.getPluginForModel(modelName);
				} else {
					const plugins = this.apibuilderPlugins;
					return Object.keys(plugins).find(plugin =>
						plugins[plugin] && (id in plugins[plugin].components.flownodes)
					);
				}
			},

			getPluginForModel: name => {
				const { pluginUse } = this._internal;
				const model = this.getModel(name);
				if (!model) {
					return;
				}
				const connectorName = typeof model.connector === 'object'
					? model.connector.name : model.connector;
				return pluginUse.getPluginForConnector(connectorName);
			},

			getPluginForConnector: name => {
				if (this.config.connectors && this.config.connectors[name]) {
					return this.config.connectors[name].connector;
				}
			}
		},

		// Set the HTTP host if configured
		host: !this.config.http.disabled ? `localhost:${this.port}` : undefined,

		// Set the SSL host if configured
		sslHost: this.config.ssl ? `localhost:${this.config.ssl.port}` : undefined,

		/**
		 * Converts a relative URL into an array of valid absolute URLs to the server
		 * If an absolute URL is provided, it will be returned as-is as the only array item
		 * Multiple URLs will be returned if the server is configured for both HTTP and HTTPs
		 * @param {string} url absolute or relative url
		 * @returns {array} Array of absolute urls
		*/
		getAbsoluteURLs: (url) => {
			// URL is already absolute, return as-is
			if (!url.startsWith('/')) {
				return [ url ];
			}

			// Other urls are relative to the service. Convert to absolute paths for HTTP and HTTPs
			const urls = [];
			if (this._internal.host) {
				urls.push(`http://${this._internal.host}${url}`);
			}

			if (this._internal.sslHost) {
				urls.push(`https://${this._internal.sslHost}${url}`);
			}

			return urls;
		}
	};
}

module.exports = getInternalInterface;
