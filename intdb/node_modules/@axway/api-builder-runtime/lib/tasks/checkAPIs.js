const chalk = require('chalk');
const Endpoints = require('arrow-endpoint');
const uriUtils = require('@axway/api-builder-uri-utils');
const utils = require('../utils');
const SWAGGER_EXTENSION = /^x-/;
// check our APIs and Routes for uniqueness
function checkAPIs(apibuilder) {
	let uniqueMap = {},
		routesAndAPIs = [].concat(apibuilder.apis, apibuilder.routes);
	for (let i = 0; i < routesAndAPIs.length; i++) {
		const obj = routesAndAPIs[i];
		const pathTransformed = utils.pathTransform(obj.path);
		if (!obj.enabled) {
			continue;
		} else if (uniqueMap[obj.method.toLowerCase() + ':' + pathTransformed]) {
			apibuilder.logger
				.warn('Multiple APIs or Routes registered for the same path and method; please disable or change the path of all but one of them for consistent results:');
			apibuilder.logger.warn(` - ${obj.method} ${obj.path}`);
			apibuilder.logger
				.warn(' - to disable a Model method, use `actions: [ ... ]` or `disabledActions: [ "' + obj.describes + '" ]`');
			apibuilder.logger.warn(' - to disable an API or Route, use `enabled: false');
			break;
		} else {
			uniqueMap[obj.method.toLowerCase() + ':' + pathTransformed] = true;
		}
	}
	// check endpoints for duplicate routes, if found, mark the whole endpoint invalid
	const endpointsMap = {};
	const endpointTriggers = [];
	Object.keys(apibuilder.endpoints).forEach((ep) => {
		const { endpoint } = apibuilder.endpoints[ep];
		Object.keys(endpoint.paths).forEach((path) => {
			if (SWAGGER_EXTENSION.test(path)) {
				return;
			}
			Object.keys(endpoint.paths[path]).forEach((method) => {
				if (SWAGGER_EXTENSION.test(method) || method === 'parameters') {
					return;
				}
				const basepath = Endpoints.getRuntimeBasePath(apibuilder, endpoint);
				const fullpath = uriUtils.oasPathToExpress(basepath + path);
				const pathTransformed = utils.pathTransform(fullpath);
				const pathSignature = method + ':' + pathTransformed;
				const seen = endpointsMap[pathSignature];
				const spacer = chalk.grey('       | - ');

				// if route clashes with other endpoints, disable both endpoints
				if (seen) {
					let msg;
					msg = `Duplicate Endpoint for path "${method.toUpperCase()} ${path}" found in Endpoint "${seen.endpoint}" and ${ep}\n`;
					msg += spacer + 'to disable an API or Route, use `enabled: false`\n';
					msg += spacer + 'to disable flow based API endpoints group, use `x-enabled: { enabled: false }`';
					// Disable the whole endpoints
					Endpoints.disableEndpoint(endpoint, msg);
					Endpoints.disableEndpoint(apibuilder.getEndpoint(seen.endpoint), msg);

					// Set the errors on the methods that have duplicate paths.
					Endpoints.disableEndpointMethod(endpoint.paths[path][method], msg);
					Endpoints.disableEndpointMethod(
						apibuilder.getEndpoint(seen.endpoint).paths[seen.path][seen.method], msg);
					apibuilder.logger.warn(msg);
				} else {
					endpointsMap[pathSignature] = {
						endpoint: ep,
						path,
						method
					};
				}
				// if route clashes with API/Routes, disable the endpoint
				if (uniqueMap[pathSignature]) {
					let msg;
					msg = `Duplicate Endpoint for path "${method.toUpperCase()} ${path}": Multiple APIs or Routes registered for the same path and method\n`;
					msg += spacer + 'to disable an API or Route, use `enabled: false`\n';
					msg += spacer + 'to disable flow based API endpoints group, use `x-enabled: { enabled: false }`';

					Endpoints.disableEndpoint(endpoint, msg);
					Endpoints.disableEndpointMethod(endpoint.paths[path][method], msg);
					apibuilder.logger.warn(msg);
				} else {
					uniqueMap[pathSignature] = true;
				}

				// record the endpoint flow-trigger
				const flowId = endpoint.paths[path][method]['x-flow'];
				if (flowId) {
					const enabled
                        = Endpoints.isEnabled(endpoint.paths[path][method]);
					let errors = [];
					if (!enabled) {
						errors = endpoint.paths[path][method]['x-enabled'].errors;
						apibuilder.logger.debug(
							`${method.toUpperCase()} ${fullpath} (${flowId}) is disabled:`,
							errors.join(', ')
						);
					}
					endpointTriggers.push({
						endpointId: ep,
						flowId,
						path: fullpath,
						method,
						enabled,
						errors
					});
				}
			});
		});
	});
	apibuilder._internal.setEndpointTriggers(endpointTriggers);
	// This PathManager loop is for finding the clash between API paths.
	const pathManager = apibuilder._internal.getPathManager();
	for (const path in pathManager.pathSignatures) {
		// To avoid duplicate log message when we haven't already detected
		// for a clash with endpoints.
		if (uniqueMap[path] && !endpointsMap[path]) {
			const msg = `Duplicate API path: ${pathManager.pathSignatures[path]['ucMethod']} ${pathManager.pathSignatures[path]['path']}. Multiple APIs or Routes registered for the same path and method`;
			apibuilder.logger.warn(msg);
		}
	}
}

module.exports = checkAPIs;
