async function loadApiSpecs(apibuilder) {
	const { logger, _internal, apibuilderPlugins } = apibuilder;
	const apiSpecs = [];
	const apiSpecTypes = {};

	for (const plugin in apibuilderPlugins) {
		// this goes into a load function somewhere.
		const pluginSpecs = apibuilderPlugins[plugin].components.apiSpecs;
		// Don't do it like this. fine for now.
		if (!Object.keys(pluginSpecs).length) {
			continue;
		}
		for (const type in pluginSpecs) {
			const apiSpec = pluginSpecs[type];
			logger.trace('Registered plugin support for API protocol:', apiSpec.name);
			// Register the spec type and interface functions.
			apiSpecTypes[type] = apiSpec;

			const { specs } = apiSpec;
			// Register the API service spec if one has been loaded, this will
			// flatten the `specs` object into an array
			for (const spec of specs) {
				logger.debug(`Registered ${apiSpec.name} spec ${spec.triggerTypeId}: ${spec.name}`);
				apiSpecs.push(spec);
				// spec.url is added later when serve() is called
			}
		}
		// At some point we will also want to add a new type here for the "dynamic" spec
		// (and type), and load it as a "true" spec with the functions for serve
		// and capabilities. It may or may not be a plugin. Then we won't need special
		// code all over runtime, ui and api to handle it differently. We would probably
		// need to do something about the currently required triggerTypeId which is used
		// as the spec id right now, as some specs like this one may not make use of triggers.
	}
	_internal.setApiSpecs(apiSpecs);
	_internal.setApiSpecTypes(apiSpecTypes);
}

module.exports = loadApiSpecs;
