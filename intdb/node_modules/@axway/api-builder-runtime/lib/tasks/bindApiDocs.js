const chalk = require('chalk');
const Swagger = require('../swagger');

async function bindApiDocs(apibuilder) {
	const {
		config,
		_internal,
		logger
	} = apibuilder;

	// Bind our dynamically generated Swagger document.
	Swagger.bindRoutes(apibuilder);

	const apiSpecs = _internal.getApiSpecs();
	const apiSpecTypes = _internal.getApiSpecTypes();
	const pathManager = _internal.getPathManager();

	for (const apiSpec of apiSpecs) {
		const { name, serve } = apiSpecTypes[apiSpec.type];
		// at the moment, the config.apidoc has properties: disabled, prefix,
		// and overrides. the overrides are intended for only for swagger only
		// in the future, we may extend it to have more generic bits for other
		// specs.
		const links = (await serve({
			triggerTypeId: apiSpec.triggerTypeId,
			config: config.apidoc,
			pathManager
		}))
			// handle backwards compatibility with an array of strings
			.map(link => {
				if (typeof link === 'string') {
					return { url: link };
				}
				// { url, mimeType, specificationVersion }
				return link;
			});

		if (!links.length) {
			return;
		}

		// Log the first path. It will be logged for HTTP and HTTPs if it's a relative path.
		const urls = _internal.getAbsoluteURLs(links[0].url);
		for (const url of urls) {
			logger.info(`Access "${apiSpec.name}" ${name} document at:`,
				chalk.yellow.underline(url));
		}

		// Set a default URL on the apiSpec for use during development.
		// There's possibly something we can do better to create the apiSpec in one place,
		// and also have the URL defined once in a single location too. Right now this will
		// modify the apiSpec object returned from a plugin.
		apiSpec.url = urls[0];

		// Set all the served links { url, mimeType, specificationVersion } on the apiSpec.
		apiSpec.links = links;
	}
}

module.exports = bindApiDocs;
