/* r.e. setImmediate:
If anything inside a promise callback is thrown, the promise will automatically be rejected.
We don't want it to happen in these cases - we want the uncaughtException handler to catch these.
If we don't use setImmediate to take the callback out of the grasp of the promise, then we will en
up with UnhandledPromiseRejectionWarnings.
Don't mix and match promise/callback syntax, kids!
see:
https://github.com/nodejs/node/issues/9242
https://github.com/stevemao/promise-to-callback/blob/master/index.js#L12
*/

/**
 * @class APIBuilder
 */
module.exports = APIBuilder;
var pendingRequests = 0;

// set the name of the node process
process.title = 'API Builder';

var express = require('express'),
	_ = require('lodash'),
	events = require('events'),
	fs = require('fs-extra'),
	path = require('path'),
	util = require('util'),
	async = require('async'),
	walkSync = require('walk-sync'),
	debug = require('debug')('apibuilder'),
	pkg = require('../package.json'),
	Metadata = require('./metadata'),
	Logger = require('./logger'),
	Loader = require('./loader'),
	Middleware = require('./middleware'),
	Block = require('./block'),
	Router = require('./router'),
	FlowManager = null,
	FlowNode = null,
	registerFlowCoreNodeHandlers = null,
	unregisterFlowCoreNodeHandlers = null,
	APIBuilderFlowInvoke = null,
	registerAPIBuilderNodeHandlers = null,
	unregisterAPIBuilderNodeHandlers = null,
	CodeblockMetadata = null,
	Endpoints = null,
	CredentialManager,
	registerAuthorizationNodeHandlers,
	unregisterAuthorizationNodeHandlers,
	API = require('./api'),
	orm = require('arrow-orm'),
	uuid = require('uuid'),
	frameguard = require('frameguard'),
	xssfilter = require('x-xss-protection'),
	nocache = require('nocache'),
	nosniff = require('dont-sniff-mimetype'),
	paths = require('./paths'),
	plugins = require('./plugins'),
	requireUncached = require('require-uncached'),
	pluralize = require('pluralize'),
	chalk = require('chalk'),
	strictUriEncode = require('strict-uri-encode'),
	Authentication = require('./authentication'),
	getAccessControlMiddleware = require('./authentication/access-control'),
	Swagger = require('./swagger'),
	getInternalInterface = require('./_internal'),
	globalConnectors = {},
	inGetConnector,
	pendingModels,
	loadedModelDirs = [],
	schemas = null,
	deprecationsCfg = require('../deprecations'),
	allTasks = require('./tasks'),
	apiBuilderConfig = require('@axway/api-builder-config'),
	bytes = require('bytes');

// Most of the time there's only going to be one API Builder instance.
// If there are multiple instances, this will only be the first one.
let globalAPIBuilder = null;

// Intentionally leave this as separate const declaration
// The starting point for code evolution ...
const CompositeFactory = require('./composite');
const utils = require('./utils');
const cors = require('./cors');
const inspect = Symbol.for('nodejs.util.inspect.custom');
const Globals = require('./globals');
const globals = new Globals();
const { PathManager } = require('./express/PathManager');
const { RenderEngineManager } = require('./express/RenderEngineManager');
const { destroy: destroyAgents } = require('@axway/requester');

util.inherits(APIBuilder, events.EventEmitter);

// allow people to reference the built-in debug module (deprecated)
Object.defineProperty(APIBuilder, 'debug', {
	enumerable: true,
	get: util.deprecate(function () {
		return debug;
	}, 'APIBuilder.debug is deprecated. See: https://docs.axway.com/bundle/api-builder/page/docs/deprecations/index.html#D027', 'D027')
});

// merge in orm into our APIBuilder
for (const key of Object.getOwnPropertyNames(orm)) {
	APIBuilder[key] = orm[key];
	orm[key].APIBuilder = APIBuilder;
}

APIBuilder.API = API;
APIBuilder.Block = Block;
APIBuilder.Formation = require('./formatters');
APIBuilder.Loader = Loader;
APIBuilder.Logger = Logger;
APIBuilder.Metadata = Metadata;
APIBuilder.Middleware = Middleware;
APIBuilder.ORM = orm;
APIBuilder.Router = Router;
APIBuilder.Version = pkg.version;
APIBuilder.Release = pkg['api-builder'].release;

/**
 * Setup known deprecations.  Use `registerDeprecationUse` to mark deprecated features so be
 * logged on startup.
 * @param {object} apibuilder - The APIBuilder instance.
 */
function setupDeprecations(apibuilder) {
	apibuilder.deprecations = requireUncached('../deprecations');

	apibuilder.registerDeprecationUse = (id, use) => {
		const { deprecations } = apibuilder;
		const deprecation = deprecations.features[id] || deprecations.flags[id];
		deprecation.active = true;
		deprecation.uses = deprecation.uses || [];
		// Allow additional per-usage info to be aggregated.
		if (use) {
			deprecation.uses.push(use);
		}
	};
}

/**
 * Handle legacy configuration, upgrade and mark deprecated feature use and set defaults.
 * @param {object} apibuilder - The APIBuilder instance.
 */
function handleLegacyConfig(apibuilder) {
	const { config } = apibuilder;

	if (config.admin.apiDocPrefix !== undefined) {
		apibuilder.registerDeprecationUse('apiDocPrefix');
	}

	if (config.admin.disableAPIDoc !== undefined) {
		apibuilder.registerDeprecationUse('disableAPIDoc');
	}

	if (config.apidoc.disabled !== undefined) {
		apibuilder.registerDeprecationUse('apidocDisabled');
	}

	if (config.APIKeyAuthType !== undefined
		|| config.APIKeyAuthPlugin !== undefined) {
		apibuilder.registerDeprecationUse('perURLAuthentication');
	}

	// move legacy apidoc config from admin section to apidoc section or use default
	if (config.apidoc.prefix === undefined) {
		config.apidoc.prefix = config.admin.apiDocPrefix || '/apidoc';
	}
	if (config.apidoc.disabled === undefined) {
		config.apidoc.disabled = !!config.admin.disableAPIDoc;
	}
	// "Kobe" release made API Builder secure by default.  If accessControl is not defined, then
	// move legacy config and configure it to be backwardly compatible.  It looks kinda scary
	// setting / to public.
	if (!config.accessControl) {
		config.accessControl = {
			apiPrefixSecurity: config.APIKeyAuthType || 'basic',
			plugin: config.APIKeyAuthPlugin,
			public: [ '/' ]
		};
		if (!config.APIKeyAuthType) {
			// if not defined, use 'none'
			config.accessControl.apiPrefixSecurity = 'none';
		}

		delete config.APIKeyAuthType;
		delete config.APIKeyAuthPlugin;
	}

	// --> Upgrade config.port to config.http.port
	if (config.port !== undefined) {
		apibuilder.registerDeprecationUse('port');
	}

	if (!config.http) {
		config.http = {
			port: parseInt(config.port) || 8080,
			disabled: false
		};
	}

	// Apply defaults
	config.http.headers = {
		'content-md5': true,
		etag: true,
		server: true,
		...config.http.headers
	};

	// Legacy config takes priority
	if (config.disableServerBanner !== undefined) {
		apibuilder.registerDeprecationUse('disableServerBanner');
		config.http.headers.server = !config.disableServerBanner;
	}

	// Some applications might be using config.port directly, so explicitly
	// set this value for backward compatibility.
	config.port = config.http.port;
	// <-- End upgrade config.port to config.http.port

	// assign the new value back for backwards compatability
	config.admin.apiDocPrefix = config.apidoc.prefix;
	config.admin.disableAPIDoc = config.apidoc.disabled;

	// Register deprecation for bodyparser config
	if (config.bodyParser !== undefined) {
		apibuilder.registerDeprecationUse('bodyParser');
	}

	// Register deprecation for busboy config
	if (config.busboy !== undefined) {
		apibuilder.registerDeprecationUse('busboy');
	} else {
		config.busboy = {};
	}
	config.busboy.limits = config.busboy.limits || {};

	configureRequestLimits(apibuilder);
}

/**
 * This may expand to limits such as the entire request body maximum size
 *(including multipart requests and raw) and/or limits for raw/text/json
 * requests independently to multipart requests.
 */
function configureRequestLimits(apibuilder) {
	const { config } = apibuilder;

	const undefinedMpSize = config.limits.multipartPartSize === undefined;
	try {
		config.limits.multipartPartSize = parseBytes(config.limits.multipartPartSize);
	} catch (err) {
		throw new Error(`invalid limits.multipartPartSize: ${err.message}`);
	}

	const { multipartPartSize } = config.limits;
	// busboy configuration will take priority over our own limits settings.
	const { limits } = config.busboy;
	if (undefinedMpSize) {
		// busboy's fieldSize limit defaults to 1mb when limits.multipartPartSize
		// is undefined. We inherit that unless the user specifically configures
		// multipartPartSize. When we remove the deprecation, we will always set
		// a value (infinity)
		apibuilder.registerDeprecationUse('undefinedMultipartPartSize');
	} else {
		limits.fieldSize = limits.fieldSize !== undefined
			? limits.fieldSize : multipartPartSize;
	}
	limits.fileSize = limits.fileSize !== undefined
		? limits.fileSize : multipartPartSize;
}

/**
 * Parses a string such as '10MB' to a number of bytes
 * Units are powers of 2 (1KB = 1024B).
 * Strings may be numerical values (i.e. '-1' or '4000')
 * Negative numerical values are treated as Infinity
 * @param {string|number} value the value to parse as bytes
 * @throws {Error} when a value which isn't undefined, a string, number or a
 * provided string doesn't parse as a number of bytes.
 */
function parseBytes(value) {
	if (value === undefined) {
		return Infinity;
	}
	let parsed = value;
	if (typeof value === 'string') {
		// Parse a string into a number
		parsed = bytes.parse(value);
	}
	// If parsing failed or the value provided was invalid
	if (isNaN(parsed) || typeof parsed !== 'number') {
		throw new Error(`"${value}" is not a valid value`);
	}
	// Negative numbers disable the limit
	if (parsed < 0) {
		return Infinity;
	}
	// All that's left are numbers between 0 and Infinity which are allowed.
	return parsed;
}

/**
 * API Builder constructor function.
 * It produces API Builder instances and in cases loadOnly is false spin up express application/s
 *
 * @param {*} config the initial configuration file the service is started
 * @param {*} loadOnly if true does not spin up express application
 */
function APIBuilder(config, loadOnly) {
	this.initialConfig = config !== undefined ? JSON.parse(JSON.stringify(config)) : null;
	this.apibuilderPlugins = {};
	const deferredLogger = utils.createDeferredLogger();
	this.config = new Loader(config && config.dir, config, deferredLogger);
	this.config.apiPrefix = this.config.apiPrefix || '/api';
	this.config.admin = this.config.admin || {};
	this.config.apidoc = this.config.apidoc || { overrides: {} };
	this.config.apidoc.overrides = this.config.apidoc.overrides || {};
	this.config.limits = this.config.limits || {};
	if (this.config.bindProcessHandlers === undefined) {
		this.config.bindProcessHandlers = true;
	}

	// Set known deprecation info in one place.  This will be used to mark deprecated
	// features on startup.
	setupDeprecations(this);

	// add the config.flags
	apiBuilderConfig.setFlagDisabledHandler((dep) => {
		this.registerDeprecationUse(dep.prop);
	});
	this.config.flags = this.config.flags || {};
	apiBuilderConfig.flags = Object.entries(deprecationsCfg.flags)
		.reduce((col, [ key, value ]) => {
			col[key] = {
				...value,
				enabled: !!this.config.flags[key]
			};
			return col;
		}, {});

	// Upgrade config and register deprecation messages
	handleLegacyConfig(this);

	// Register deprecation warning for any out-of-support Node.js versions
	if (utils.isUsingEOLNodeVersion()) {
		this.registerDeprecationUse('nodeSupport');
	}

	// Register deprecation warning for node 14 as we are moving to node 16 minimum in v5
	if (utils.isUsingNode14()) {
		this.registerDeprecationUse('nodeSupport14');
	}

	// http and https ports taken from the config
	// http port defaults to 8080 only as legacy apps compatibility
	// https port defaults to 8443
	this.port = this.config.http.port;
	if (this.config.ssl && !this.config.ssl.port) {
		this.config.ssl.port = 8443;
	}

	// Run validation on the config
	validateConfig(this.config);

	// Infer the need of web resource allocation like static web and renderers
	const webDirectory = this.config.dir && path.join(this.config.dir, 'web');
	const publicDirectory = webDirectory && path.join(webDirectory, 'public');
	const routesDirectory = webDirectory && path.join(webDirectory, 'routes');
	// configWeb is internal prop that holds flags to specify
	// the need to initialize resources related with web app capabilities
	// like static server and renderers.
	// In the future this might be turned into official configuration strategy in app config
	this.configWeb = {
		needStaticServer: publicDirectory && fs.existsSync(publicDirectory),
		needRenderers: routesDirectory && fs.existsSync(routesDirectory)
	};
	if (this.configWeb.needRenderers) {
		this.registerDeprecationUse('apiBuilderWeb');
	}
	// end of Infer logic

	this.loadOnly = loadOnly;
	this.ignoreDuplicateModels = !!this.config.ignoreDuplicateModels;

	if (!globalAPIBuilder) {
		globalAPIBuilder = this;
	}
	// since the continuation listeners potentially has a ton of listeners on
	// startup
	this.setMaxListeners(Number.MAX_VALUE);

	// Initialize the base url
	let baseurl = this.config.baseurl
		|| (this.config.http.disabled ? 'https://localhost' : 'http://localhost');
	baseurl = `${baseurl}${baseurl.endsWith(':') ? '' : ':'}`;
	if (baseurl.toLowerCase().startsWith('https://')) {
		baseurl = `${baseurl}${this.config.ssl.port}`;
	} else {
		baseurl = `${baseurl}${this.port}`;
	}

	// Now that flags are configured, set the logging level, and after
	// it is safe for use.
	const hasCustomLogger = !!(config && config.logger);
	if (hasCustomLogger) {
		// Note, that imo, for custom loggers, we should be calling:
		// `this.logger.level(this.config.logLevel)`
		// But, we never did before, so just making the point now.
		this.logger = config.logger;
	} else {
		// defaults to Logger.NONE
		this.logger = Logger.createLogger({
			level: this.config.logLevel
		});
	}

	// Log the loader messages (this is the top of the log)
	deferredLogger.logAll(this.logger);

	logConfiguredMultipartLimit(this);

	// Require these after setting the flags as the flags may affect their interfaces
	const AxwayFlow = require('@axway/flow');
	FlowManager = AxwayFlow.FlowManager;
	FlowNode = AxwayFlow.FlowNode;
	registerFlowCoreNodeHandlers = AxwayFlow.register;
	unregisterFlowCoreNodeHandlers = AxwayFlow.unregister;
	schemas = require('axway-schema');
	APIBuilderFlowInvoke = require('@axway/api-builder-flow-invoke');
	registerAPIBuilderNodeHandlers = APIBuilderFlowInvoke.register;
	unregisterAPIBuilderNodeHandlers = APIBuilderFlowInvoke.unregister;
	CodeblockMetadata = APIBuilderFlowInvoke.CodeblockMetadata;
	Endpoints = require('arrow-endpoint');

	// Initialize the Credential Manager
	initCredentialManager(baseurl, this);

	const pathManager = new PathManager(this);
	// this is the default path (inside if). we use this
	// as a way to be able to load up API Builder but without
	// creating the server infrastructure. this is useful for
	// being able to programatically load models, connectors, etc
	if (!loadOnly) {

		var self = this;
		this.express = express;
		var server = this.app = express();

		// Configure express to always behave as "production".
		// This is more secure, and provides a number of performance benefits
		// Although it does cache view templates and css files
		// http://expressjs.com/en/advanced/best-practice-performance.html#set-node_env-to-production
		// this.config.expressEnv is not part of the public interface, and
		// intentionally undocumented and only for use by us if we find
		// that we need to configure the express env ASAP for debugging.
		server.set('env', this.config.expressEnv || 'production');

		// If configured, disable etag header and calculation for non-static requests.
		// See https://npmjs.com/package/etag
		if (!this.config.http.headers.etag) {
			server.set('etag', false);
		}

		var healthCheckAPI;
		var healthCheckError;
		if (this.config.healthCheckAPI) {
			try {
				healthCheckAPI = require(path.resolve(this.config.dir, this.config.healthCheckAPI));
			} catch (e) {
				healthCheckError = e;
			}
		}

		const healthcheckMiddleware = healthCheckAPI || function (req, resp) {
			const success = !self.shuttingdown
				&& !self._internal.isUnavailable();
			return resp.json({ success });
		};

		// These don't get server/request id or content-md5 headers
		// since they are bound before the middleware that adds these headers
		// and before req.server is bound (md5 uses this)
		server.get('/apibuilderPing.json', healthcheckMiddleware);
		// This is the default healthcheck that ARS will call.
		server.get('/arrowPing.json', healthcheckMiddleware);

		if (healthCheckError) {
			this.logger.trace(healthCheckError.stack);
			this.logger
				.error('error loading health check plugin', healthCheckAPI, healthCheckError);
		}

		// add graceful shutdown middleware which will send 503 responses to
		// any incoming connection requests while we're in shutdown or reload mode. any
		// front end load balancer (like API Runtime Services) should correctly handle this
		server.use(function (req, resp, next) {
			if (self.shuttingdown || self.pendingReload) {
				resp.shouldKeepAlive = false;
				resp.set('Connection', 'close');
				resp.set('Cache-Control', 'no-cache, no-store, max-age=0');
				resp.set('Pragma', 'no-cache');
				resp.status(503);
				if (self.shuttingdown) {
					resp.end('Server is shutting down');
				} else {
					resp.end('Server is restarting');
				}
			} else {
				next();
			}
		});

		// add the request-id helper
		express.request.getId = function () {
			if (!this._reqid) {
				this._reqid = uuid.v4();
			}
			return this._reqid;
		};

		addLocals(this, this.app, baseurl);

		// bind a logger to the server itself
		server.logger = this.logger;

		let appPkg = path.join(this.config.dir, 'package.json');
		const releaseName
			= chalk.blue.bold(`API Builder/${APIBuilder.Release} (${APIBuilder.Version})`);
		if (fs.existsSync(appPkg)) {
			appPkg = require(appPkg);
			this.logger.info(releaseName + ' ' + chalk.yellow(`${appPkg.name}/${appPkg.version}`));
		} else {
			appPkg = {};
			// fallback if we can't find package.json for app
			this.logger.info(releaseName);
		}
		this.projectName = appPkg.name ? path.basename(appPkg.name) : 'apibuilder-app';

		this.metadata = {
			name: appPkg.name,
			version: appPkg.version,
			description: appPkg.description,
			author: appPkg.author,
			license: appPkg.license
		};

		if (this.config.apikey) {
			this.logger.debug('APIKey is:', chalk.gray(this.config.apikey));
		}

		setupSecurityHeaders(server);

		server.use(function (req, resp, next) {
			req.pendingReqCount = ++pendingRequests;
			req.server = self;
			if (self.config.http.headers.server) {
				resp.set('Server', 'API Builder/' + pkg.version);
			}
			resp.set('Request-Id', req.getId());
			resp.locals['request-id'] = req.getId();
			req.logger = resp.logger = req.log = req.log || self.logger.scope(req);
			next();
		});

		// Note: Admin isn't loaded at this point, the module is just required
		// so we can test for "development" mode early on.
		let Admin;
		try {
			// try to require admin if enabled
			if (this.config.admin && this.config.admin.enabled) {
				const pkg = utils.getPackageJson('@axway/api-builder-admin');
				utils.validateModuleCompatibility(pkg, this);
				// eslint-disable-next-line import/no-unresolved
				Admin = require('@axway/api-builder-admin');
			} else {
				// admin is completely disabled
				this.logger.info('API Builder Console is disabled');
			}
		} catch (ex) {
			// Ignore require error if admin cannot be loaded
			if (!ex.message.includes('Cannot find module \'@axway/api-builder-admin\'')) {
				throw ex;
			}
		}

		// A flag toggling on redaction in Production. This would redact the req
		// info that is being logged to preserve sensitive information from being
		// leaked into the logs.
		const enableRedaction = !Admin;
		const requestMiddleware = getRequestMiddleware(enableRedaction);
		// This should always be at the top before anything else but after setting up the logger
		server.use(requestMiddleware);

		this.corsAPI = cors(
			{
				apidocPath: this.apidocPath,
				apidocPathLegacy: this.apidocPathLegacy,
				getAPIsForPath: API.getAPIsForPath,
				pathManager,
				publicDirectory
			},
			this.config.cors
		);

		if (this.configWeb.needStaticServer) {
			if (this.corsAPI.isCORSOn()) {
				// Add CORS headers for the Static Resources if the static server is available and
				// if CORS is on
				server.use(this.corsAPI.middlewareForStaticResources);
			}
			// setup static route to web/public.  this is placed before the authenticated
			// api/routes, otherwise static routes will not work.  e.g. the UI requests /index.html
			// which routes to ./web/public.
			setupStaticPublicMiddleware(server, this.config.dir);
		}

		// create the authentication strategy and middleware (bound in start).
		setupAuthenticationStrategy(this);

		// Enable view cache when in "production".
		// This is for the deprecated API Builder Web (Middleware)
		if (!Admin && this.app.get('env') === 'production') {
			// Must be set manually
			this.app.enable('view cache');
		} else {
			this.app.disable('view cache');
		}

		// Create the RenderEngineManager - for backward compatibility, it has
		// the same interface as the old Middleware used to have before it was
		// refactored to remove the render engines.
		this.middleware = new RenderEngineManager(server, {
			appDir: this.config.dir,
			logger: this.logger
		});
		this.middleware.registerRenderers();

		// load up admin if enabled
		if (Admin) {
			this.admin = new Admin();
		}

		if (!this.config.http.disabled) {
			this.logger.trace(`creating APIBuilder server instance on port ${this.port}`);
		}
		if (this.config.ssl) {
			this.logger.trace(`creating APIBuilder server instance on port ${this.config.ssl.port}`);
		}
	} else {
		this.pkg = pkg;
	}

	if (this.config.printEnvVars) {
		this.logger.trace(process.env);
	}

	// pass the config to components but remove some parts
	const { name, port, admin, session, apikey } = this.config;
	this.objConfig = { name, port, admin, session, apikey };

	schemas.setLogger(this.logger);

	this.flowManager = new FlowManager(this.logger, CredentialManager);
	this.models = {};
	this.apis = [];
	this.blocks = {};
	this.registeredNodes = [];
	this.routes = [];
	this.codeblocks = {};
	this.endpoints = {};

	// NOTE: put all non-public interfaces on internal
	this._internal = getInternalInterface.bind(this)();
	this._internal.setPathManager(pathManager);
	if (loadOnly) {
		// The `loadOnly` is only used internally. It is an asynchronous
		// function with a callback (not passed), so it is not going to wait
		// here. It used to use `nextTick`, possibly to ensure that what ever
		// happens in `load`, happens after this constructor resolves.
		// However, internal tests pass, so we will leave it without the
		// `nextTick`.  Now, `load` is called by `start`.
		// TODO: we do not want `load` here, even for development.  tests
		// that depend on loadOnly should be refactored to explicitly call
		// load.
		this.load();
	} else {
		this.once('reload', this.reload);
	}
	loadInternalConnectors();
}

function logConfiguredMultipartLimit(apibuilder) {
	const { fileSize, fieldSize = '1mb' } = apibuilder.config.busboy.limits;

	const file = bytes.parse(fileSize);
	const field = bytes.parse(fieldSize);

	const fileUnlimited = file === Infinity;
	const fieldUnlimited = field === Infinity;

	const fileFSize = fileUnlimited ? 'unlimited' : bytes.format(file);
	const fieldFSize = fieldUnlimited ? 'unlimited' : bytes.format(field);

	const unlimited = fileUnlimited || fieldUnlimited;

	const logLvl = unlimited ? 'warn' : 'debug';

	const msg = 'The maximum part size for multipart/form-data requests is';
	const unlimitedMsg = unlimited
		? '. You should consider configuring a limit in config.limits.multipartPartSize.'
		: '';

	const size = file === field ? fileFSize : `${fileFSize} (files), ${fieldFSize} (fields)`;

	apibuilder.logger[logLvl](`${msg} ${size}${unlimitedMsg}`);
}

/**
 * Validates the apidoc configuration overrides.
 *
 * @param {Object} overrides - The apidoc overrides from the configuration.
 * @throws {Error} - when invalid configuration is encountered.
 */
function validateApidocOverrides(overrides) {
	const { schemes, host, basePath, servers } = overrides;

	// Verify that scheme contains 0 or 1 of http, https, ws, wss
	if (schemes !== undefined && schemes !== null) {
		let invalid = !Array.isArray(schemes) || !schemes.length;
		if (!invalid) {
			const valid = [ 'http', 'https', 'ws', 'wss' ];
			// remove duplicates and filter out invalid schemes
			const filtered = [ ...new Set(schemes) ]
				.filter(s => valid.includes(s));
			// if the length is different then there were some invalid values
			if (filtered.length !== schemes.length) {
				invalid = true;
			}
		}
		if (invalid) {
			throw new Error('apidoc.overrides.schemes configuration is invalid. Value must be an array containing 0 or 1 of "http", "https", "ws", "wss"');
		}
	}

	if (host !== undefined && host !== null && typeof host !== 'string') {
		throw new Error('apidoc.overrides.host configuration is invalid. Value must be a string');
	}

	if (basePath !== undefined
		&& basePath !== null
		&& (typeof basePath !== 'string' || basePath[0] !== '/')) {
		throw new Error('apidoc.overrides.basePath configuration is invalid. Value must be a string and start with a leading /, or null to specify no basePath');
	}

	if (servers !== undefined && servers !== null) {
		if (!Array.isArray(servers)) {
			throw new Error('apidoc.overrides.servers configuration is invalid. Value must be an array.');
		}

		// Validate the server values
		for (const server of servers) {
			const isObject = !Array.isArray(server) && server instanceof Object;
			const containsUrl = server.hasOwnProperty('url') && typeof server.url === 'string';
			if (!isObject || !containsUrl) {
				throw new Error('apidoc.overrides.servers configuration is invalid. Values must be of type Object and at minimum contain the required server url as String.');
			}
		}
	}
}

function validateConfig(config) {
	validateApidocOverrides(config.apidoc.overrides);

	const proxyUri = config.proxy;
	if (proxyUri !== undefined && typeof proxyUri !== 'string') {
		throw new Error('proxy configuration is invalid. Value must be a string');
	}
	const apiPrefix = config.apiPrefix;
	if (typeof apiPrefix !== 'string' || apiPrefix[0] !== '/') {
		throw new Error('apiPrefix configuration is invalid. Value must be a string and start with a leading "/".');
	}

	if (config.baseurl) {
		if (!config.ssl && config.baseurl.toLowerCase().startsWith('https://')) {
			throw new Error(`baseurl in the config is set to the secure url ${config.baseurl}. \
However SSL has not been enabled on this service. For details on configuring SSL see https://docs.axway.com/bundle/api-builder-security-guide/page/enabling_tls_ssl.html`);
		}

		if (config.http.disabled && config.baseurl.toLowerCase().startsWith('http://')) {
			throw new Error(`The baseurl is set to ${config.baseurl}, but http is disabled (http.disabled is set to true)`);
		}
	}

	if (!config.http.port || typeof config.http.port !== 'number') {
		throw new Error('http.port is not configured properly in your config. \
It is either missing or not of type number.');
	}

	if (config.http.disabled && !config.ssl) {
		throw new Error('http.disabled in the config is set to true. \
However SSL has not been enabled on this service. For details on configuring SSL see https://docs.axway.com/bundle/api-builder-security-guide/page/enabling_tls_ssl.html');
	}

	if (!config.accessControl.hasOwnProperty('public')) {
		throw new Error('accessControl.public is required.  Value must be an empty array, or array of path strings prefixed with a leading "/"');
	}
}

/**
 * Initialize Credential Manager and registers all credentials in API Builder.
 * The function is also responsible to preserve valid authorizations across reloads if they have not
 * been touched.
 *
 * @param {*} baseurl the baseurl.
 * @param {*} apiBuilder API Builder instance.
 */
function initCredentialManager(baseurl, apiBuilder) {
	apiBuilder.config.authorization = apiBuilder.config.authorization || {};
	apiBuilder.config.authorization.callback = apiBuilder.config.authorization.callback || '/auth/callback';
	const FlowAuth = require('@axway/axway-flow-authorization');
	CredentialManager = FlowAuth.CredentialManager;
	registerAuthorizationNodeHandlers = FlowAuth.register;
	unregisterAuthorizationNodeHandlers = FlowAuth.unregister;
	CredentialManager.setLogger(apiBuilder.logger);

	CredentialManager.config = {
		baseurl,
		...apiBuilder.config.authorization,
		credentials: mergeCredentials(baseurl, apiBuilder.config.authorization.callback)
	};

	/**
	 * Responsible to update the list with managed by Credential Manager credentials.
	 * baseurl and callback are used to calculate redirect_uri used by oauth2 authorization.
	 *
	 * On system restart the Credential Manager must manage the updated list with credentials
	 * - deleted credentials must not be managed
	 * - newly added credentials must be managed
	 * - modified credentials should be invalidated
	 * - not modified credentials should be preserved
	 *
	 * There are two types of credential attributes - manually managed and dynamically managed by
	 * CM.
	 * The algorithm here decides how to reset oauth2 credentials when checking manually managed
	 * attributes for changes.
	 *
	 * @param {*} baseurl service base url
	 * @param {*} callback service callback url
	 * @returns {array} the new list with credentials that must be managed by Credential Manager
	 */
	function mergeCredentials(baseurl, callback) {
		const previouslyManagedCredentials = CredentialManager.getCredentialConfigs() || {};
		const newCredentials = apiBuilder.config.authorization.credentials || {};
		if (Object.keys(previouslyManagedCredentials).length === 0
			|| Object.keys(newCredentials).length === 0) {
			// No merge required.
			return newCredentials;
		}

		// Delete any removed credentials
		Object.keys(previouslyManagedCredentials)
			.filter(name => !newCredentials.hasOwnProperty(name))
			.forEach(name => CredentialManager.removeCredential(name));

		// Merge the old details into the new credential.
		Object.keys(newCredentials)
			// Filter newly added
			.filter(name => previouslyManagedCredentials.hasOwnProperty(name))
			// Leave only oauth2 since they are the only refreshable at the moment
			.filter(name => newCredentials[name].type === 'oauth2')
			// Merge
			.forEach(name => {
				const providedProps = [
					'authentication_url',
					'client_id',
					'client_secret',
					'flow',
					'token_url'
				];
				const existing = previouslyManagedCredentials[name];
				const newCred = newCredentials[name];
				const newRedirectUri = newCred.redirect_uri || baseurl + callback;
				if (providedProps.every(key => newCred[key] === existing[key])
					&& newRedirectUri === existing.redirect_uri) {
					// If the provided props and redirect_uri stays the same we keep the previously
					// claculated managed dependencies
					newCred.expiry = existing.expiry;
					newCred.access_token = existing.access_token;
					newCred.refresh_token = existing.refresh_token;
					newCred.scope = existing.scope;
				}
			});

		return newCredentials;
	}
}

/**
 * This is invoked only when constructing APIBuilder instance.
 * Internal connectors are created once and reloaded on APIBuilder restart.
 * getConnector will always find these already instantiated.
 * @param {object} instance - The APIBuilder instance.
 */
function loadInternalConnectors() {
	// Load memory connector
	APIBuilder.registerConnector(new APIBuilder.MemoryConnector());

	// Load composite connector
	APIBuilder.registerConnector(CompositeFactory(APIBuilder));
}

function addLocals(server, app, baseurl) {
	// Note that the baseurl argument is calculated using the config and the
	// port. That is assigned to server instance property.
	// The config baseurl does not contain a port.
	server.baseurl = baseurl;
	server.apidocPathLegacy = server.config.apidoc.prefix + '/docs.json';
	server.apidocPath = server.config.apidoc.prefix + '/swagger.json';
	server.apidocurl = server.baseurl + server.apidocPath;
	server.logger.trace('setting app locals', app.locals);

	Object.defineProperty(app.locals, 'appc_external_url', {
		enumerable: true,
		get: util.deprecate(function () {
			return server.baseurl;
		}, 'app.locals properties appc_external_url, appc_external_apidoc_path_legacy, appc_external_apidoc_path, and appc_external_apidoc_url are deprecated. See: https://docs.axway.com/bundle/api-builder/page/docs/deprecations/index.html#D026', 'D026')
	});
	Object.defineProperty(app.locals, 'appc_external_apidoc_path_legacy', {
		enumerable: true,
		get: util.deprecate(function () {
			return server.apidocPathLegacy;
		}, 'app.locals properties appc_external_url, appc_external_apidoc_path_legacy, appc_external_apidoc_path, and appc_external_apidoc_url are deprecated. See: https://docs.axway.com/bundle/api-builder/page/docs/deprecations/index.html#D026', 'D026')
	});
	Object.defineProperty(app.locals, 'appc_external_apidoc_path', {
		enumerable: true,
		get: util.deprecate(function () {
			return server.apidocPath;
		}, 'app.locals properties appc_external_url, appc_external_apidoc_path_legacy, appc_external_apidoc_path, and appc_external_apidoc_url are deprecated. See: https://docs.axway.com/bundle/api-builder/page/docs/deprecations/index.html#D026', 'D026')
	});
	Object.defineProperty(app.locals, 'appc_external_apidoc_url', {
		enumerable: true,
		get: util.deprecate(function () {
			return server.apidocurl;
		}, 'app.locals properties appc_external_url, appc_external_apidoc_path_legacy, appc_external_apidoc_path, and appc_external_apidoc_url are deprecated. See: https://docs.axway.com/bundle/api-builder/page/docs/deprecations/index.html#D026', 'D026')
	});
}

/**
 * Returns the middleware instance containing the Express app instance.
 * @returns {APIBuilder.Middleware}
 */
APIBuilder.prototype.getMiddleware = function () {
	return this.middleware;
};

/*
 * used for testing only
 *
 * @private
 */
APIBuilder.resetGlobal = function () {
	APIBuilder.ORM.MemoryConnector.resetPrimaryKeys();
	globalConnectors = {};
	loadedModelDirs = [];
	globalAPIBuilder = null;
	globals.resetState();
	pendingRequests = 0;
};

/**
 * Gets a reference to the first instantiated APIBuilder server.
 * @returns {APIBuilder}
 */
APIBuilder.getGlobal = function () {
	return globalAPIBuilder;
};

/**
 * Returns the full path of the component directory.
 * @param {String} type Component type, that is, `api`, `block`, `model`, `route`, `node`.
 * @returns String
 */
APIBuilder.prototype.getComponentDir = function getComponentDir(type) {
	if (type === 'route') {
		// these live in a little bit of a different location
		return path.resolve(path.join(this.config.dir, 'web', 'routes'));
	} else {
		return path.resolve(path.join(this.config.dir, `${type}s`));
	}
};

/**
 * Loads an API from an API file. The file must exist and be a valid API. No error checking is
 * performed.
 * @param {String} fn Filename of the API.
 * @param {Function} [cb] Callback passed an Error object (or null if successful), the API instance,
 * @and the API class.
 */
APIBuilder.prototype.loadApi = function loadAPI(fn, cb) {
	try {
		this.logger.debug('attempting to load API', fn);
		let APIClass = paths.requireComponent(fn, true);
		if (!_.isFunction(APIClass)) {
			this.logger.trace(APIClass);
			throw new Error('Error loading api at ' + fn + '. this module did not export a Class');
		}
		let api = new APIClass(this.objConfig, this, fn);
		// APIs can reference models so if they use them, add to usage map

		this._internal.pluginUse.registerAPI(api);
		this.apis.push(api);
		cb && setImmediate(() => cb(null, api, APIClass));
	} catch (ex) {
		if (cb) {
			return cb(ex);
		} else {
			throw ex;
		}
	}
};

/**
 * Loads a Model from a Model file. The file must exist and be a valid Model. No error checking is
 * performed.
 * @param {String} fn Filename of the Model.
 * @param {Function} [cb] Callback passed an Error object (or null if successful) and the Model
 * @class.
 */
APIBuilder.prototype.loadModel = function loadModel(fn, cb) {
	try {
		this.logger.debug('attempting to load model', fn);
		let Model = paths.requireComponent(fn, true);
		if (!Model) {
			this.logger.trace(Model);
			throw new Error('Error loading model at ' + fn);
		}
		if (Model.deferred) {
			// Set by model extend/reduce monkeypatch futher down this file.
			// Model loading was deferred since it referenced another model.
			// Note: This function is never hit again for that model.
			cb && setImmediate(() => cb());
			return;
		}
		if (!_.isObject(Model)) {
			this.logger.trace(Model);
			throw new Error('Error loading model at ' + fn + '. this module did not load properly');
		}
		if (!_.isFunction(Model.create) && !Model.loadingModels) {
			this.logger.trace(Model);
			throw new Error('Error loading model at ' + fn + '. this module did not export a Class');
		}
		if (!Model.loadingModels
			&& (!_.isObject(Model.fields)
				|| !Object.keys(Model.fields).length)) {
			this.logger.trace(Model);
			throw new Error('Error loading model at ' + fn + '. this model did not contain any fields');
		}
		// if we don't provide a connector, attempt to get the connector global default the config
		// this makes it nice since i can simply put my default in the config and i don't need to
		// specify on each and every model
		if (!Model.connector) {
			Model.setConnector(this.config.defaultConnector);
		}
		Model.filename = fn;
		if (!Model.generated) {
			Model.timestamp = fs.statSync(fn).mtime;
		}
		Model.name && (this.models[Model.name] = Model);
		this._internal.pluginUse.registerModel(Model);

		cb && setImmediate(() => cb(null, Model));
	} catch (ex) {
		if (cb) {
			return cb(ex);
		} else {
			throw ex;
		}
	}
};

/**
 * Loads a Block from a Block file. The file must exist and be a valid Block. No error checking is
 * performed.
 * @param {String} fn Filename of the Block.
 * @param {Function} [cb] Callback passed an Error object (or null if successful) and the Block
 * @class.
 */
APIBuilder.prototype.loadBlock = function loadBlock(fn, cb) {
	try {
		this.logger.debug('attempting to load block', fn);
		let Block = paths.requireComponent(fn, true);
		if (!Block) {
			this.logger.trace(Block);
			throw new Error('Error loading block at ' + fn);
		}
		if (!_.isFunction(Block)) {
			this.logger.trace(Block);
			throw new Error('Error loading block at ' + fn + '. this module did not export a Class');
		}
		let block = new Block(this.objConfig, this);
		Block.filename = block.filename = fn;
		Block.timestamp = block.timetsamp = fs.statSync(fn).mtime;
		this.blocks[block.name] = block;
		cb && setImmediate(() => cb(null, Block));
	} catch (ex) {
		if (cb) {
			return cb(ex);
		} else {
			throw ex;
		}
	}
};

/**
 * Loads a Flow from a flow file. The file must exist and be a valid Flow.
 * @param {String} fn Filename of the flow.
 * @param {Function} [cb] Callback passed an Error object (or null if @successful) and the
 * Flow class.
 */
APIBuilder.prototype.loadFlow = function loadFlow(fn, cb) {
	this.logger.debug('attempting to load flow', fn);
	// only save changes to flows when admin is running
	const saveUpdates = !!this.admin;
	return this.flowManager.load(fn, { saveUpdates }).then(
		flow => {
			this._internal.pluginUse.registerFlow(flow, fn);
			// See "r.e. setImmediate" comment above
			setImmediate(function () {
				cb && cb(null, flow);
			});
		},
		err => {
			this.logger.error(err);
			// See "r.e. setImmediate" comment above
			setImmediate(function () {
				cb && cb(new Error('Error loading flow at ' + fn));
			});
		});
};

/*
 * Parses and validates a swagger document
 * See Endpoints.validateSwagger for details about validation types performed.
 * @param {string|object} swagger - swagger document
 * @returns {Promise<object>} valid swagger
 */
APIBuilder.prototype.validateSwagger = function (swagger) {
	return Endpoints.validateSwagger(swagger, { logger: this.logger });
};

/**
 * Loads an endpoint from a file.
 * @param  {string} fn [path to file]
 * @param  {Function} cb [callback to for error handle]
 */
APIBuilder.prototype.loadEndpoint = function loadEndpoint(fn, cb) {
	this.logger.debug('attempting to load endpoint', fn);
	return Endpoints.load(fn, this.getFlows(), { logger: this.logger }).then(
		(epInfo) => {
			if (this.endpoints[epInfo.name]) {
				// See "r.e. setImmediate" comment above
				setImmediate(() => {
					const { filename } = this.endpoints[epInfo.name];
					cb && cb(new Error(`Duplicate endpoint at ${fn} and ${filename}`));
				});
				return;
			}
			this.endpoints[epInfo.name] = epInfo;
			// See "r.e. setImmediate" comment above
			setImmediate(function () {
				cb && cb(null, epInfo);
			});
		},
		(err) => {
			// err can contain .errors or is an exception
			const errors = [ `Error loading endpoint at ${fn}` ];
			if (err.errors) {
				errors.push(' ');
				err.errors.forEach(function (e) {
					errors.push(JSON.stringify(e));
				});
			} else {
				errors.push((err + '').replace(/^Error:\s+/, '; '));
			}
			const msg = errors.join('').trim();
			this.logger.error(msg);
			// See "r.e. setImmediate" comment above
			setImmediate(function () {
				cb && cb(new Error(msg));
			});
		});
};

/**
 * Loads a Route from a Route file. The file must exist and be a valid Route. No error checking is
 * performed.
 * @param {String} fn Filename of the Route.
 * @param {Function} [cb] Callback passed an Error object (or null if successful) and the Route
 * @class.
 */
APIBuilder.prototype.loadRoute = function loadRoute(fn, cb) {
	try {
		this.logger.debug('attempting to load route', fn);
		var Router = paths.requireComponent(fn, true);
		if (!Router) {
			this.logger.trace(Router);
			throw new Error('Error loading route at ' + fn);
		}
		if (!_.isFunction(Router)) {
			this.logger.trace(Router);
			throw new Error('Error loading route at ' + fn + '. this module did not export a Class');
		}
		var route = new Router(this.objConfig, this);
		this.routes.push(route);
		Router.filename = route.filename = fn;
		Router.timestamp = route.timestamp = fs.statSync(fn).mtime;
		cb && setImmediate(() => cb(null, Router));
	} catch (ex) {
		if (cb) {
			return cb(ex);
		} else {
			throw ex;
		}
	}
};

/**
 * Loads a Codeblock from a Codeblock file. The file must exist and be a valid Codeblock. No error
 * checking is performed.
 * @param {String} fn Filename of the Codeblock.
 * @param {Function} [cb] Callback passed an Error object (or null if successful) and the Codeblock
 * @class.
 */
APIBuilder.prototype.loadCodeblock = function loadCodeblock(fn, cb) {
	var msg;
	this.logger.debug('attempting to load codeblock', fn);

	CodeblockMetadata.load(fn, {
		logger: this.logger
	}).then(
		function (meta) {
			// all checks pass. Read the codeblock and save it in the instance
			// get codeblock function file
			var absPath = path.resolve(path.dirname(fn), meta.path);
			try {
				meta.action = requireUncached(absPath);
			} catch (ex) {
				msg = 'Error loading codeblock at ' + fn + '. ' + ex;
				this.logger.error(msg);
				// See "r.e. setImmediate" comment above
				setImmediate(function () {
					cb && cb(new Error(msg));
				});
				return;
			}
			if (typeof (meta.action) !== 'function') {
				msg = 'Error loading codeblock at ' + fn + '. module is not a function';
				this.logger.error(msg);
				// See "r.e. setImmediate" comment above
				setImmediate(function () {
					cb && cb(new Error(msg));
				});
				return;
			}

			this.codeblocks[meta.name] = meta;
			// See "r.e. setImmediate" comment above
			setImmediate(function () {
				cb && cb(null, meta);
			});
		}.bind(this),
		function (err) {
			this.logger.error(err);
			this.logger.error('Error loading codeblock at ' + fn);
			// See "r.e. setImmediate" comment above
			setImmediate(function () {
				cb && cb(err);
			});
		}.bind(this)
	);
};

APIBuilder.prototype.registerNode = function registerNode(node) {
	// TODO: this is a "public interface" currently, but the paramter
	// with "specs" has leaked from when we used to have flows on disk.
	// This can easily be changed to taking a single node when we're happy
	// to break the function interface.
	if (!node || !node.specs) {
		throw new Error('Not a flow-node component');
	}
	Object.keys(node.specs).forEach(
		(name) => {
			const spec = JSON.parse(JSON.stringify(node.specs[name]));

			class Node extends FlowNode { }
			Object.entries(node.specs[name].methods).forEach(([ methodName, methodDef ]) => {
				Node.prototype[methodName] = methodDef.action;
			});

			this.registeredNodes.push(spec.type);
			this.flowManager.registerNode(spec.type, Node, function () {
				return spec;
			});
		}
	);
};

APIBuilder.prototype.loadSchema = function loadSchema(fn, cb) {
	this.logger.debug('attempting to load schema', fn, 'with scope, \'' + this.projectName + '\'');
	// adding schema as per the ticket RDPP-1673
	schemas.add(fn, 'schema:///schema/' + this.projectName + '/' + path.basename(fn, '.json'));
	cb();
};

/**
 * Loads all service components.
 * @param {Function} callback Callback to execute after loading each component. Passed an Error
 * @object if any.
 */
APIBuilder.prototype.loadComponents = function loadComponents(componentTypes, callback) {
	var instance = this;
	var tasks = [];

	// load connectors, models, blocks, apis, and then routes from directories
	// (in that order) first using the node_modules (the true) and then using
	// the cwd/<type> (the false)
	componentTypes.forEach(function (type) {
		var xtype = type.replace(/^@/g, ''),
			typeName = xtype.charAt(0).toUpperCase() + xtype.substring(1),
			mn = 'load' + typeName,
			loadFn;
		if (!instance[mn]) {
			throw new Error('Missing method: ' + mn);
		}
		loadFn = instance[mn].bind(instance);

		// set a flag that we're loading
		tasks.push(function (cb) {
			instance['loading' + typeName + 's'] = true;
			cb();
		});

		// look inside project directories
		iterateComponentDir(instance, type, fn => {
			tasks.push(cb => loadFn(fn, cb));
		});

		tasks.push(function (cb) {
			// delete our flag
			delete instance['loading' + typeName + 's'];
			// fire an event that we're done loading in case we have someone
			// listening for pending models to finish before continuing
			instance.emit('loaded' + typeName + 's');
			cb();
		});
	});

	async.series(tasks, callback);
};

/*
 * called internally to start loading server. when you call start, it will wait until the
 * loaded event is fired
 */
APIBuilder.prototype.load = function load(callback) {
	// Initialize the plugin details and then load components
	const exitOnPluginFailure = apiBuilderConfig.flags.exitOnPluginFailure;

	Promise.resolve()
		.then(async () => await allTasks.startBilling.call(this, {
			runtimeVersion: APIBuilder.Version
		}))
		.then(() => plugins.findPlugins(this))
		.then(
			apibuilderPlugins => {
				this.apibuilderPlugins = apibuilderPlugins;
			},
			err => {
				// If findPlugins rejected, throw the err and stop
				// the server in the catch
				if (exitOnPluginFailure) {
					throw err;
				}
				// REFACTOR: Everything below could be deleted and handled in
				// the catch handler. Currently it could cause calling the
				// callback twice - here with an error (if exitOnPluginFailure
				// is set to false) and in 'loadComponents' without and error
				// which will cause the 'started' promise to be resolve twice.
				if (callback) {
					callback(err);
				} else {
					this.emit('error', err);
				}
			}
		)
		.then(async () => {
			await allTasks.registerConnectors.call(this);
			await allTasks.loadConnectors.call(this);
		})
		.then(() => {
			// set plugins on the trigger manager
			this._internal.getTriggerManager()
				.setPlugins(this.apibuilderPlugins);
		})
		.then(() => allTasks.loadApiSpecs(this))
		.then(
			() => {
				// Load the components
				this.loadComponents([ 'schema', 'model', 'block', 'api', 'route' ], (err) => {
					if (!err) {
						// indicate we've started and emit loading event
						this.logger.debug('Done loading schema, model, block, api, and route');
						this.loaded = true;
						Object.values(this.models).forEach((model) => {
							const connectorName = typeof model.connector === 'object'
								? model.connector.name : model.connector;
							// Register models that are in use by composite models.
							// Done after all models are loaded so we know every model's connector
							if (connectorName === 'composite') {
								this._internal.pluginUse.registerModel(model, true);
							}
							// See if connector has a defaultMetadata for the
							// model.
							const connector = this.getConnector(connectorName);
							if (connector.defaultMetadata
								&& (!model.metadata || !Object.keys(model.metadata).length)) {
								model.metadata = connector.defaultMetadata;
							}

							// convert models to schema and register them after all the models are
							// loaded
							this.modelToSchema(model).forEach((schema) => schemas.add(schema));
						});
						this.emit('loaded');
						callback && callback();
						// REFACTOR: Else clauses could be deleted and handled in
						// the catch handler so we have single place to control
						// when the callback is invoked.
					} else if (callback) {
						callback(err);
					} else {
						this.emit('error', err);
					}
				});
			}
		)
		.catch(err => {
			// Log the error and stop safely
			// This catch also catches previously uncaught promise
			// rejections if connectors failed to start
			const errMsg = err && err.message || err;
			this.logger.error('Server failed to load components');
			errMsg && this.logger.error(err.stack);
			this.stop(() => callback && callback(err));
		});
};

const JSON_FILE_REGEXP = /^((?!_))(.*)?\.json$/;
const JSON_YAML_FILE_REGEXP = /^((?!_))(.*)?\.(json|yaml|yml)$/;
const JS_FILE_REGEXP = /^((?!_))(.*)?\.js$/;

/*
 * utility function to iterate a component directory and for each component found, call
 * the foundCallback function will the parameter of the path to the component
 */
function iterateComponentDir(instance, type, foundCallback) {
	const directoryTypes = {
		codeblock: JSON_FILE_REGEXP,
		flow: JSON_FILE_REGEXP,
		endpoint: JSON_YAML_FILE_REGEXP,
		schema: JSON_FILE_REGEXP
	};

	const dir = instance.getComponentDir(type);
	instance.logger.trace('iterateComponentDir', type, dir);
	if (fs.existsSync(dir)) {
		if (type === 'model') {
			if (loadedModelDirs.indexOf(dir) >= 0) {
				instance.logger.trace('iterateComponentDir already read', type, dir);
				return;
			}
			loadedModelDirs.push(dir);
		}
		let dirs;
		if (instance._internal.endpointsEnabled) {
			// Only load endpoints from disk if enabled
			dirs = [ 'codeblock', 'flow', 'endpoint', 'schema' ];
		} else {
			dirs = [ 'codeblock', 'flow', 'schema' ];
		}

		if (dirs.includes(type)) {
			walkSync(dir).forEach(function fileIterator(file) {
				if (directoryTypes[type].test(path.basename(file))) {
					foundCallback(path.join(dir, file));
				} else {
					instance.logger.trace('iterateComponentDir - skipping...', file);
				}
			});
		} else {
			walkSync(dir).forEach(function fileIterator(file) {
				if (JS_FILE_REGEXP.test(path.basename(file))) {
					foundCallback(path.join(dir, file));
				} else {
					instance.logger.trace('iterateComponentDir - skipping...', file);
				}
			});
		}
	} else {
		instance.logger.trace('iterateComponentDir not found', type, dir);
	}
}

/**
 * Returns a configuration value for the key (or a provided default value if not found).
 * @param {String} key Key to retrieve.
 * @param {Any} def Default value to return if the key cannot be found.
 */
APIBuilder.prototype.get = util.deprecate(function get(key, def) {
	return this.config[key] || def;
}, 'APIBuilder.get is deprecated. See: https://docs.axway.com/bundle/api-builder/page/docs/deprecations/index.html#D030', 'D030');

/**
 * returns false if the model name passed in does not exist.
 * It handles the fatal error if the model does exist.
 *
 * At the moment it returns true, but it should stop the server
 */
function isModelDuplicate(modelName) {
	if (globalAPIBuilder && (modelName in globalAPIBuilder.models)) {
		if (globalAPIBuilder.ignoreDuplicateModels) {
			return false;
		}
		// Model already exists!
		throw new Error('Model name: ' + modelName + ' exists in multiple places');
	} else {
		return false;
	}
}

/**
 * Executes a security middleware call, which authenticates the request.  This is no longer called
 * internally, but remains public method on the APIBuilder interface.
 * @param {Object} req Request object.
 * @param {Object} resp Response object.
 * @param {Function} next Next function to call.
 */
APIBuilder.prototype.executeSecurityMiddleware
	= function executeSecurityMiddleware(req, resp, next) {
		return this.accessControlMiddleware(req, resp, next);
	};

/**
 * Starts the server.
 * @param {Function} [callback] Callback passed an Error object.
 * @throws Error
 */
APIBuilder.prototype.start = function start(callback) {
	// `start` function is called multiple times (i.e. start > on load > start)
	// so here we create or get already created promise state where 'started'
	// structure is { promise, resolve, reject }. We provide a function as
	// second argument that is attached as catch handler and prevents
	// UnhandledPromiseRejectionWarning.
	const started = this._internal.getPromiseState('started', () => {});
	// this can happen if you call loadOnly in constructor and then later
	// try and start the server
	if (!this.app) {
		var error = new Error('invalid state. no internal app was created. did you call loadOnly in the APIBuilder constructor?');
		this.logger.trace('rejecting started promise', error);
		started.reject(error);
		if (callback) {
			callback(error);
		}
		return started.promise;
	}

	// if we started and then stopped and now we're restarting, we need to reload this
	if (this.shuttingdown) {
		this.logger.trace('re-start after a shutdown');
		var self = this;
		this.shuttingdown = false;
		async.each(this.apis, function (api, cb) {
			api.remove(self, cb);
		}, function (err) {
			if (err) {
				return callback(err);
			}
			async.each(self.routes, function (route, cb) {
				if (route) {
					route.remove(self, cb);
				} else {
					cb();
				}
			}, function (err) {
				if (err) {
					return callback(err);
				}
				Object.keys(self.blocks).forEach(function (name) {
					var block = self.blocks[name];
					block.removeAllListeners();
				});
				self.models = {};
				self.apis = [];
				self.blocks = {};
				self.routes = [];
				self.load(function (err) {
					if (err) {
						return callback(err);
					}
					self.start(callback);
				});
			});
		});
		return started.promise;
	}

	// REFACTOR: If 'start' is called without a callback we provide default
	// post startup logic (error handling + more). To reduced the friction we
	// can move this logic in 'async.series' callback and execute it if not
	// callback is provided. This will allow us to call 'start' internally
	// without a callback.
	if (!callback) {
		// This is the default error handler. Most applications do not have a
		// callback when calling start.
		this.logger.trace('using the standard start callback');
		callback = function (err) {
			if (err) {
				this.logger.error('Server failed to start');
				this.logger.error(err.stack);
				// When an 'error' occurs within an `EventEmitter`, Node.js
				// handles these specially.  If an 'error' is emitted and there
				// is nothing registered to handle it, then an Error is thrown.
				// https://nodejs.org/api/events.html#events_error_events

				// REFACTOR: This is our current non-graceful way of exiting the
				// app. Consider changing it to:
				// this.stop(() => { this.emit('error', err); })
				this.emit('error', err);
			} else if (this.port) {
				if (!this.config.http.disabled) {
					this.logger.info(`Server started on port ${this.port}`);
				}
				if (this.config.ssl) {
					this.logger.info(`SSL server started on port ${this.config.ssl.port}`);
				}
			} else {
				this.logger.info('Server started');
			}
		}.bind(this);
	}

	if (!this.loaded) {
		this.logger.trace('loading components');
		this.load((err) => {
			// This callback is needed because load can fail.  When it fails,
			// we need to handle it so that we can reject the started promise.
			if (err) {
				this.logger.trace('failed to load components', err);
				started.reject(err);
				return callback(err);
			}
			this.logger.trace('loaded, now starting');
			this.start(callback);
		});
		return started.promise;
	}
	this.logger.trace('starting');

	if (!this.config.http.disabled) {
		this.logger.debug('starting', this.port);
	}
	if (this.config.ssl) {
		this.logger.debug('starting', this.config.ssl.port);
	}
	this.emit('starting');

	const tasks = [];

	if (!this.config.http.disabled) {
		tasks.push(allTasks.checkPort.bind(this, this.port));
	}

	if (this.config.ssl) {
		tasks.push(allTasks.checkPort.bind(this, this.config.ssl.port));
	}

	tasks.push((next) => {
		// before 'started' event, bind system events, e.g. "shutdown"
		allTasks.systemEvents.bindEvents.call(this);
		next();
	});

	// ------------------------------------------------------------------------
	// LOAD: start loading all components.  Al tasks that are below this are
	// in a specific order, e.g. schemas are first because flows need them, etc.
	// These tasks should be done before we start binding anything, e.g. PLUGINS
	// ------------------------------------------------------------------------

	// load schemas
	tasks.push(function loadSchemasTask(next) {
		this.logger.debug('loading schemas');
		try {
			// register plugin schema
			for (const plugin of Object.values(this.apibuilderPlugins)) {
				for (const schema of Object.values(plugin.components.schema || {})) {
					schemas.add(schema);
				}
			}
			// Finally load all schemas that have been registered
			schemas.loadSync();
		} catch (ex) {
			this.logger.error('error loading schemas', ex);
			return next(ex);
		}
		next();
	}.bind(this));

	// finish loading flows, after registering node handlers
	tasks.push(function loadCodeblocks(next) {
		this.loadComponents([ 'codeblock' ], function (err) {
			this.logger.debug('Done loading codeblocks');
			next(err);
		}.bind(this));
	}.bind(this));

	// register node handlers.  has to be done after connectors, and done after checking
	// to see if port is in use (existing tests depend on that).
	tasks.push(function registerNodeHandlers(next) {
		try {
			// register flow-nodes from plugins
			for (const plugin of Object.values(this.apibuilderPlugins)) {
				if (!plugin.components.flownodes
					|| Object.keys(plugin.components.flownodes).length === 0) {
					continue;
				}
				this.registerNode({
					specs: plugin.components.flownodes
				});
			}
			registerFlowCoreNodeHandlers(this.flowManager);
			registerAPIBuilderNodeHandlers(this);
			registerAuthorizationNodeHandlers(this.flowManager);
		} catch (ex) {
			return next(ex);
		}
		next();
	}.bind(this));

	// finish loading flows, after registering node handlers
	tasks.push(function loadFlows(next) {
		this.loadComponents([ 'flow', 'endpoint' ], function (err) {
			this.logger.debug('Done loading flows and endpoints');
			next(err);
		}.bind(this));
	}.bind(this));

	// TODO: when we remove Codeblocks, this task can be deleted.
	tasks.push(function unregisterOptionalCodeblock(next) {
		let codeBlockUri = this.flowManager.formatNodeHandlerUri('api-builder-flow-invoke', 'codeblock');
		// Check if there are any codeblock files
		let hasCodeblockFile = Object.keys(this.codeblocks).length > 0;
		let hasCodeblockFlow = false;
		if (!hasCodeblockFile) {
			// The FlowManager has all the flows in a cache of Flow instances, but
			// unfortunately, it does not give direct access to those instances of Flow.
			// The cache is accessible, and this isn't great to access it this way, but
			// this is the only way to get the nodehandlers that are needed for the flow
			// without creating a Flow instance.  Adding a method on FlowManager does not
			// make sense as this is is to manage a deprecated feature.  This code will be
			// deleted.
			for (const flowId in this.flowManager.cache) {
				for (const nodeHandler of this.flowManager.cache[flowId].getNodeHandlers()) {
					if (nodeHandler.node.type === codeBlockUri) {
						hasCodeblockFlow = true;
						break;
					}
				}
			}
		}
		if (hasCodeblockFile || hasCodeblockFlow) {
			// If any codeblock files loaded, or any flow has a codeblock node, emit
			// deprecation warning
			this.registerDeprecationUse('codeblock');
		} else {
			// Otherwise, codeblock is unused, unregister the flow-node handler
			this.flowManager.unregisterNode(codeBlockUri);
		}
		next();
	}.bind(this));

	// turn our models into apis
	tasks.push(function createModelAPIs(next) {
		this.createAPIsFromModels();
		next();
	}.bind(this));

	// sort APIs
	tasks.push(allTasks.sortAPIsOrRoutes.bind(this, this.apis));

	// sort Routes
	tasks.push(allTasks.sortAPIsOrRoutes.bind(this, this.routes));

	// ------------------------------------------------------------------------
	// PLUGINS: register the middlewares into the express app. these must be
	// added before SECURITY and ADMIN and general ROUTES. All paths bound
	// **below** this are subject to being counted towards metrics.
	// ------------------------------------------------------------------------
	tasks.push(async () => await allTasks.startMiddlewares(this));

	// ------------------------------------------------------------------------
	// SECURITY and ADMIN: these exist at the top of our express app must come
	// before ROUTES. Note that accessControl here below PLUGINS to capture 401.
	// Note Middleware moved here below PLUGINS to ensure things like busboy
	// happen after authentication.
	// ------------------------------------------------------------------------
	// bind tasks moved from constructor
	tasks.push(async () => {
		// bind our access-control
		this.app.use(this.accessControlMiddleware);

		// create the core express middleware (moved from constructor).
		// REFACTOR: the constructor for this is a bit of a mess and can be
		// simplified to: Middleware(app, config)
		const sessionConfig = this.config.session || {};
		new Middleware(this.app, this.config.dir, sessionConfig, this.config);

		this.app.on('after', endRequestMiddleware);

		if (this.corsAPI.isCORSOn()) {
			this.app.use(this.corsAPI.middlewareForAPIs);
			this.app.use(this.corsAPI.middleware);
		}

		// load up admin if enabled
		if (this.admin) {
			// Authorization callbacks only registered if we have Admin console
			// for now.
			this.app.get(
				this.config.authorization.callback,
				CredentialManager.middleware
			);
		}
	});

	// ------------------------------------------------------------------------
	// ROUTES: These are the apis, endpoints, model API, and triggers. The order
	// of these are important in that each take priority over the other in the
	// event of duplicate paths (e.g. possible to create a custom api with a
	// similar path).
	// ------------------------------------------------------------------------

	// bind our apis
	tasks.push(function (next) {
		var keys = {};
		this.apis.forEach(api => {
			if (api.enabled) {
				// keep track of already bound apis and only bind once (save memory)
				var key = api.method + api.path;
				if (key in keys) {
					return;
				}
				keys[key] = 1;
				api.bind(this.app);
			}
		});
		next();
	}.bind(this));

	// bind our endpoints to flows
	tasks.push(function (next) {
		Endpoints.bind(this, this.endpoints, Swagger.schemaIdToSwaggerName);
		next();
	}.bind(this));

	// bind our routes
	tasks.push(function (next) {
		var keys = {};
		this.routes.forEach(route => {
			if (route.enabled) {
				// keep track of already bound routes and only bind once (save memory)
				var key = route.method + route.path;
				if (key in keys) {
					return;
				}
				keys[key] = 1;
				route.bind(this.app);
			}
		});
		next();
	}.bind(this));

	// load triggers
	tasks.push(async () => {
		// We have semantic validation on the triggers' configuration that can
		// throw, which should abort the start up with the respective details
		// how to fix the issues.  Note this must happen *before* binding to
		// ports because some triggers can take time to load. async.js is
		// handling this async function and any errors it may throw.
		await allTasks.loadTriggers.call(this);
	});

	// ------------------------------------------------------------------------
	// MISC PATHS: Extra stuff to bind, this block should come after ROUTES and
	// before MIDDLEWARE BIND.
	// ------------------------------------------------------------------------

	// bind apidocs
	tasks.push(async () => await allTasks.bindApiDocs(this));

	// bind apidocs discoverability
	tasks.push(async () => await allTasks.bindApiDocsDiscoverability(this));

	// Run any validation that couldn't happen while loading components

	// Validate schemas
	// Async on purpose - saves a try/catch to call a "next" callback
	tasks.push(async () => {
		// Note that validateSchema is synchronous and this is returning undefined
		// on success and not a promise.
		return allTasks.validateSchema(schemas, {
			logger: this.logger,
			warnOnly: !apiBuilderConfig.flags.exitOnSwaggerSchemaValidationError
		});
	});

	tasks.push(async () => {
		return allTasks.validateSwagger(this, {
			warnOnly: !apiBuilderConfig.flags.exitOnSwaggerSchemaValidationError
		});
	});

	// ------------------------------------------------------------------------
	// MIDDLEWARE BIND: The middleware `bind` methods can bind additional
	// paths to the express app, and may log additional URL, so this must come
	// before ADMIN UI so that the console URL appears last.
	// ------------------------------------------------------------------------
	tasks.push(async () => await allTasks.bindMiddlewares(this));

	// check our APIs and Routes for uniqueness
	tasks.push((next) => {
		try {
			allTasks.checkAPIs(this);
		} catch (ex) {
			return next(ex);
		}
		next();
	});

	// ------------------------------------------------------------------------
	// ADMIN UI: load the admin-api and admin-ui.  This will bind additional
	// paths to the express app, so it must come before ERROR HANDLER, and it
	// should come after: ROUTES, MISC PATHS
	// ------------------------------------------------------------------------
	if (this.admin) {
		tasks.push(next => this.admin.start(this, next));
	}

	// ------------------------------------------------------------------------
	// ERROR HANDLER: Attach express custom error handler. This task must happen
	// after **all** routes and middleware are bound.
	// ------------------------------------------------------------------------
	tasks.push((next) => {
		allTasks.bindErrorHandlingMiddleware(this);
		next();
	});

	// ------------------------------------------------------------------------
	// LISTEN: No express paths should be bound after this.
	// ------------------------------------------------------------------------

	// Bind start up the http server and bind the ports
	tasks.push(function appListenTask(next) {
		this.emit('listening');
		if (this.config.ssl && this.config.http.disabled) {
			// https only use case
			const https = require('https');
			this.sslServer
				= https.createServer(this.config.ssl, this.app)
					.listen({ port: this.config.ssl.port }, next);
			// http is disabled so we reuse the sslServer
			// because we use this.server for number of events
			// e.g. APIBuilder.prototype.stop
			this.server = this.sslServer;
		} else {
			if (this.config.ssl) {
				// we have https in addition to http
				const https = require('https');
				// note that we don't pass 'next' to listen here
				// since we pass it later when we create http server
				this.sslServer
					= https.createServer(this.config.ssl, this.app).listen(this.config.ssl.port);
			}
			// http is enabled so we create new server
			this.server = this.app.listen(this.port, next);
		}
		if (this.sslServer) {
			utils.enableGracefulDestroy(this.sslServer);
			if (this.config.timeout !== undefined) {
				this.sslServer.setTimeout(this.config.timeout);
			}
		}
		utils.enableGracefulDestroy(this.server);
		if (this.config.timeout !== undefined) {
			this.server.setTimeout(this.config.timeout);
		}
	}.bind(this));

	// Add this server instance and bind the interrupt handlers.
	// IMPORTANT: any startup task error that occurs _after_ `addServer` will
	// result in an "Uncaught Exception" error.  This is because `start` will
	// this.emit('error', error) which causes the exception to be thrown as
	// there is no 'error' listener.  Prior to this point, it is just an error
	// and logs, "Emitted 'error' event on APIBuilder instance". After this
	// point, it gets the label, "Uncaught Exception".
	tasks.push(function startedTask(next) {
		if (this.unstable && !this.admin) {
			// intentionally happening before addServer and "started"
			return next(new Error('Server became unstable during startup'));
		}
		globals.addServer(this, {
			bind: this.config.bindProcessHandlers
		});
		this.emit('listen');
		this.emit('started');
		next();
	}.bind(this));

	// Log any warnings

	// Test for configured data connectors whose plugins aren't installed.
	tasks.push((next) => {
		Object.keys((this.config.connectors) || {})
			.filter(name => this.config.connectors[name].connector)
			.forEach(name => {
				if (!this.getConnector(name)) {
					this.logger.warn(`Unused connector configured: ${name}. Required plugin ${this.config.connectors[name].connector} is not installed.`);
				}
			});
		next();
	});

	// Log deprecation warnings
	tasks.push((next) => {
		const { url, features, flags } = this.deprecations;
		const sortById = (a, b) => {
			return a.id > b.id ? 1 : a.id < b.id ? -1 : 0;
		};

		[
			...Object.values(features).filter(dep => dep.active),
			...Object.values(flags).filter(dep => dep.active)
		].sort(sortById).forEach(dep => {
			let message = `[${dep.id}] ${dep.message}. `;
			if (dep.usageMessage) {
				message += `${dep.usageMessage}: ${dep.uses.join(', ')}. `;
			}
			message += `See: ${url}${dep.id}`;
			this.logger.warn(message);
		});
		next();
	});

	// Log credentials status
	tasks.push((next) => {
		const credCfgs = CredentialManager.getCredentialConfigs();
		if (credCfgs && Object.keys(credCfgs).length > 0) {
			Object.entries(credCfgs).forEach(([ name, cfg ]) => {
				if (cfg.status.action === 'needsAuth') {
					this.logger.warn(`Credential ${name} requires authorization.`);
				}
			});
		}
		next();
	});

	async.series(tasks, (err) => {
		if (err) {
			this.logger.trace('rejecting started promise', err);
			started.reject(err);
		} else {
			this.logger.trace('resolving started promise');
			started.resolve(this);
		}
		callback && callback(err);
	});

	return started.promise;
};

/**
 * Get the id of the model schema that has all the fields but no id and
 * does not allow additionalProperties. Used in create/update etc.
 *
 * @param {Model} model The model to get the schema id for.
 * @param {string} suffix The suffix to append.
 */
APIBuilder.prototype.getModelSchemaId = function (model, suffix) {
	let { name } = model;
	if (apiBuilderConfig.flags.enableModelNameEncodingInSwagger) {
		// schema id as per the ticket RDPP-1673 (strict encode RFC-3986)
		name = strictUriEncode(model.name);
	}
	return `schema:///model/${name}${suffix || ''}`;
};

/**
 * Get the id of the model schema that has all the fields but no id and
 * allows additionalProperties.
 *
 * @param {Model} model The model to get the schema id for.
 */
APIBuilder.prototype.getModelSchemaExId = function (model) {
	return this.getModelSchemaId(model, '-ex');
};

/**
 * Get the id of the model schema that has all the fields including id
 * but also allows additionalProperties. Used in the swagger for programmatic
 * APIs to allow composition with the ResponseModel.
 *
 * @param {Model} model The model to get the schema id for.
 */
APIBuilder.prototype.getModelSchemaFullExId = function (model) {
	return this.getModelSchemaId(model, '-fullex');
};

/**
 * Get the id of the model schema that has all the fields including id
 * and does not allow additionalProperties. Used in the endpoint returns
 * and endpoint upsert.
 * @param {Model} model The model to get the schema id for.
 */
APIBuilder.prototype.getModelSchemaFullId = function (model) {
	return this.getModelSchemaId(model, '-full');
};

/**
 * Given a model, this method computes an array of json-schemas
 * @param  {Object} model - The apibuilder model to use
 * @return {Array}       An array of schemas
 */
APIBuilder.prototype.modelToSchema = function (model) {
	const required = [];
	const properties = {};

	if (!(model instanceof APIBuilder.Model)) {
		model = new APIBuilder.Model(model.name, model, true);
	}

	/**
	 * Casts a string representation of a value to the property type
	 * @param  {(String|Any)} value - The value we want to cast/return
	 * @param  {String} [type="string"] - The type to cast to
	 * @return {Any}
	 */
	const castModelDefault = (value, type = 'string') => {
		// Throw an error if the type and string value are not compatible
		function throwInvalidType(value, type) {
			throw new Error(`Invalid default value "${value}" for type "${type}" in model "${model.name}"`);
		}

		// Assert that the parsed/interprated value is the correct type
		function verifyType(value, type) {
			if (Object.prototype.toString.call(value).toLowerCase() !== `[object ${type}]`) {
				throwInvalidType(value, type);
			}
		}

		// check that the type is correct
		if (typeof value !== 'string') {
			verifyType(value, type);
			return value;
		}

		// Cast the strings to their correct type
		try {
			switch (type) {
				case 'integer':
				case 'number':
					const num = Number(value);
					isNaN(num) && (() => {
						throw new Error();
					})();
					return num;
				case 'date':
					return new Date(value).toISOString();
				case 'boolean':
				case 'array':
				case 'object':
					// Parse and verify type
					const parsedVal = JSON.parse(value);
					verifyType(parsedVal, type);
					return parsedVal;
				default:
					return value;
			}
		} catch (e) {
			throwInvalidType(value, type);
		}
	};

	Object.entries(model.fields).forEach(([ name, field ]) => {
		if (field.required) {
			required.push(name);
		}
		properties[name] = {};

		// Record any defaults or descriptions
		if ('default' in field) {
			properties[name].default = castModelDefault(field.default, field.type);
		}
		if ('description' in field) {
			properties[name].description = field.description;
		}

		// Build out or properties object
		properties[name].type = field.type;
		switch (field.type) {
			case 'date':
				properties[name].type = 'string';
				break;
			case 'array':
				// TODO: We need more information about the array sub-type here. See RDPP-1672
				properties[name].items = {};
				break;
			case 'object':
				// TODO: We need more information about the object properties here. See RDPP-1672
				properties[name].additionalProperties = true;
				break;
			case 'string':
			case 'number':
			case 'integer':
			case 'boolean':
				properties[name].type = field.type;
				break;
			default:
				properties[name].type = 'string';
				break;
		}
	});

	// NOTE: You can't do composition between these schemas using allOf as each
	// clause needs to be independently enforcable, so additionalPropertes false
	// won't work.

	// Extensible schema for describing the model fields (used in schema composition).
	const modelSchemaEx = {
		id: this.getModelSchemaExId(model),
		type: 'object',
		properties: properties
	};
	if (required.length > 0) {
		modelSchemaEx.required = required;
	}

	// Schema for describing the model fields (used in create/update).
	const modelSchema = JSON.parse(JSON.stringify(modelSchemaEx));
	modelSchema.id = this.getModelSchemaId(model);
	modelSchema.additionalProperties = false;

	const modelSchemas = [
		modelSchema,
		modelSchemaEx
	];

	// Extensible schema for model fields containing Id (used in API swagger returns)
	const pkName = model.getPrimaryKeyName();

	if (!apiBuilderConfig.flags.enableModelsWithNoPrimaryKey || pkName) {
		const pkType = apiBuilderConfig.flags.usePrimaryKeyType
			? { type: model.getPrimaryKeyType() } : {};

		// 'date' is not one of the accepted json schema validation types. We support providing
		// dates as strings, so we need to coerce the PK type to 'string' here (see RDPP-5819).
		if (pkType.type === 'date') {
			pkType.type = 'string';
		}

		const modelSchemaFullEx = JSON.parse(JSON.stringify(modelSchemaEx));
		modelSchemaFullEx.id = this.getModelSchemaFullExId(model);
		modelSchemaFullEx.properties[pkName] = pkType;
		modelSchemaFullEx.required = (modelSchemaFullEx.required || []).concat(pkName);
		modelSchemas.push(modelSchemaFullEx);

		// Schema for model fields containing Id (used in endpoint upsert/returns)
		const modelSchemaFull = JSON.parse(JSON.stringify(modelSchemaFullEx));
		modelSchemaFull.id = this.getModelSchemaFullId(model);
		modelSchemaFull.additionalProperties = false;
		modelSchemas.push(modelSchemaFull);
	}

	return modelSchemas;
};

/**
 * Generates the standardized APIs from all loaded models.
 */
APIBuilder.prototype.createAPIsFromModels = function () {
	Object.keys(this.models).forEach(function routeModelIterator(name) {
		var model = this.models[name];
		this.createAPIsFromModel(model);
	}.bind(this));
};

/**
 * Generates the standardized APIs from a particular model.
 */
APIBuilder.prototype.createAPIsFromModel = function (model) {
	if (model.connector && typeof model.connector === 'string') {
		try {
			model._connector = model.connector;
			model.connector = this.getConnector(model.connector, true);
			model.connector.emit('init-model', model);
		} catch (e) {
			this.logger.trace(e.stack);
			throw new Error('Error loading connector: ' + model._connector + ' for model: ' + model.name + '. ' + e.message);
		}
	}
	if (model.autogen) {
		const modelAPIs = makeAPIsFromModel(model, this.config.apiPrefix);
		modelAPIs.forEach(function modelAPIConstructorIterator(API) {
			var api = new API(this.objConfig, this);
			this.apis.push(api);
		}.bind(this));
	}
};

function makeAPIsFromModel(model, apiPrefix) {
	// if autogen off, don't generate APIs for Model
	if (!model.autogen
		|| (model.connector && model.connector.enabled === false)
		|| !model.connector) {
		return [];
	}

	const apis = [];
	const { name, shortName, connectorName } = model;

	// the resource we bind must be escaped, e.g. these chars: ()+
	if (apiBuilderConfig.flags.enableModelNameEncoding) {
		const hasConnectorSlash = name !== shortName;
		if (hasConnectorSlash && apiBuilderConfig.flags.enableModelNameEncodingWithConnectorSlash) {
			// Slash is actually ok in paths. We'll keep it for the case when
			// the model name is prefixed with the connector.
			// We know that the Model name is prefixed with the connector if name !== shortName.
			// and we're also flagged we'll use a unencoded / to seperate the encoded names in the
			// API path.
			const encodedName = utils.encodeNameForURI(shortName);
			const encodedConnectorName = utils.encodeNameForURI(connectorName);
			model.prefix = model.prefix || `${apiPrefix}/${encodedConnectorName}/${encodedName}`;
		} else {
			// whole name is encoded
			const encodedName = utils.encodeNameForURI(name);
			model.prefix = model.prefix || `${apiPrefix}/${encodedName}`;
		}
	} else {
		// un-encoded
		model.prefix = model.prefix || `${apiPrefix}/${name.toLowerCase()}`;
	}
	model.singular = model.singular || pluralize(name.toLowerCase(), 1);
	model.plural = model.plural || pluralize(name.toLowerCase());

	for (var key in model) {
		if (key.slice(-3) === 'API') {
			var val = model[key],
				isAPIDescriptor = _.isFunction(val),
				describes = key.slice(0, -3),
				describesUC = describes.substr(0, 1).toUpperCase() + describes.substr(1),
				enabled = true;

			if (!isAPIDescriptor) {
				continue;
			}
			var api = model[key]();
			if (!api) {
				continue;
			}

			// Check to see if the underlying connector has the necessary methods to support this
			// API.
			var connectorMethods = (api.dependsOnAny || api.dependsOnAll || [ describes ])
				.filter(function (depConnectorMethod) {
					return !!model.getConnector()[depConnectorMethod];
				});
			if (connectorMethods.length < (api.dependsOnAll ? api.dependsOnAll.length : 1)) {
				enabled = false;
				delete api.enabled;
			}

			// Should we disable based on our action or action groups being disabled?
			if (model.actions.indexOf(describes) === -1
				&& (!api.actionGroup || model.actions.indexOf(api.actionGroup) === -1)) {
				enabled = false;
			}
			if (model.disabledActions && model.disabledActions.indexOf(describes) >= 0) {
				enabled = false;
				delete api.enabled;
			}

			// Handle some defaults for the API.
			if (!api.path) {
				api.path = model.prefix;
			} else if (api.path.substr(0, 2) === './') {
				api.path = model.prefix + api.path.substr(1);
			}

			_.defaultsDeep(api, {
				responses: {
					404: {
						description: 'No results were found.',
						schema: {
							$ref: '#/definitions/ErrorModel'
						}
					},
					500: {
						description: 'Something went wrong during the request; check out the logs on your server.',
						schema: {
							$ref: '#/definitions/ErrorModel'
						}
					},
					504: {
						description: 'The request took too long to process, and the server timed it out.',
						schema: {
							$ref: '#/definitions/ErrorModel'
						}
					},
					default: {
						description: 'Response from server',
						schema: {
							$ref: '#/definitions/ResponseModel'
						}
					}
				}
			});

			apis.push(API.extend(_.defaults(api, {
				enabled: enabled,
				generated: true,
				group: name,
				describes: describes,
				method: 'GET',
				parameters: {},
				singular: model.singular,
				plural: model.plural,
				model: name,
				pre: _.flatten(_.compact([
					model['pre' + describesUC], model['before' + describesUC],
					model['pre' + (api.method || 'GET')], model['before' + (api.method || 'GET')],
					model.pre, model.before
				])),
				post: _.flatten(_.compact([
					model['post' + describesUC], model['after' + describesUC],
					model['post' + (api.method || 'GET')], model['after' + (api.method || 'GET')],
					model.post, model.after
				]))
			})));
		}
	}

	return apis;
}

/**
 * Removes an API from the server.
 * @param {String} filename Name of the file of the API to remove.
 * @param {Function} [callback] Callback function passed an Error object (or null if successful).
 */
APIBuilder.prototype.removeAPIByFilename
	= util.deprecate(function removeAPIByFilename(filename, callback) {
		var api = _.filter(this.apis, function (api) {
			return api.filename === filename;
		})[0];

		if (api) {
			api.remove(this, callback);
		} else {
			callback && callback(new Error('couldn\'t find an API at ' + filename));
		}
	}, 'APIBuilder.removeAPIByFilename is deprecated. See: https://docs.axway.com/bundle/api-builder/page/docs/deprecations/index.html#D022', 'D022');

/**
 * Reloads any changes found in Models, Blocks, Routes or APIs.
 * @param {Function} [callback] Callback to execute after the reload.
 */
APIBuilder.prototype.reload = function reload(callback) {
	this.logger.debug('reload called');
	if (this.pendingReload) {
		this.logger.debug('concurrent reload invocation is ignored');
		if (callback) {
			return callback(null, this);
		}
	} else {
		this.pendingReload = true;
		this.stop(() => {
			globalAPIBuilder = new APIBuilder(this.initialConfig);
			globalAPIBuilder.reloaded = true;
			globalAPIBuilder.start((err) => {
				this.pendingReload = false;
				if (!err) {
					this.logger.debug('reload finished!');
					this.emit('reloaded');
				}
				if (callback) {
					return callback(err, globalAPIBuilder);
				} else if (err) {
					this.emit('error', err);
				}
			});
		});
	}
};

/**
 * Stops the APIBuilder server instance.
 * @param {Function} [callback] Callback to execute after the server stops.
 */
APIBuilder.prototype.stop = function stop(callback) {
	this.shuttingdown = true;

	if (!this.server) {
		this.logger.debug('stop called but server not started');
	}

	var tasks = [];

	// stop events
	tasks.push(async () => {
		try {
			// unbind system events, e.g. "shutdown"
			allTasks.systemEvents.unbindEvents.call(this);
		} catch (ex) {
			this.logger.error(ex);
		}
	});

	// stop triggers
	tasks.push(async () => {
		try {
			await allTasks.stopTriggers.call(this);
		} catch (ex) {
			this.logger.error(ex);
		}
	});

	// clear schemas
	tasks.push(function (next) {
		this.logger.trace('clearing schemas');
		schemas.clear();
		next();
	}.bind(this));

	tasks.push(next => {
		this.logger.trace('clearing API cache');
		this.apis = [];
		API.clearAPIs();
		next();
	});

	// stop middlewares
	tasks.push(async () => await allTasks.stopMiddlewares(this));

	// stop billing manager
	tasks.push(async () => await allTasks.stopBilling.call(this));

	tasks.push(next => {
		// destroy HTTP agents from @axway/requester
		destroyAgents();
		next();
	});

	if (this.server && !this.stopped) {
		// Remove the server from the global list
		// Unbinds any event listeners if this is the last server
		this.logger.trace('removing globals');
		globals.removeServer(this);

		// REFACTOR: I think `stopped` should really be last
		this.stopped = true;
		this.emit('stopping');

		// first stop the server so we don't serve request
		tasks.push(function serverCloseTask(next) {
			try {
				// ignore any errors on shutdown
				this.logger.trace('destroying server');
				this.server.destroy(next);
			} catch (err) {
				this.logger.error(err);
				next();
			}
		}.bind(this));

		// stop the SSL server if we have one
		if (this.sslServer) {
			tasks.push(function serverCloseTask(next) {
				try {
					// ignore any errors on shutdown
					this.logger.trace('destroying ssl server');
					this.sslServer.destroy(next);
				} catch (err) {
					this.logger.error(err);
					next();
				}
			}.bind(this));
		}
	}

	// stop the admin UI if attached, and that the admin UI is at least 4.8.0,
	// which adds the stop method.
	if (this.admin && this.admin.stop) {
		tasks.push((next) => {
			this.logger.trace('stopping admin');
			this.admin.stop(next);
		});
	}

	// Disconnect all dataconnectors if provided a disconnect method. Delete
	// the models associated with the connector (generated and fs) so that we
	// don't run into duplicate errors when loadComponents tries to load fs
	// models. Delete the _createdModelsFromSchema flag so arrow-orm knows to
	// re-grab models from schema (generated). Delete connector.started so
	// startDataconnector() will kick off
	tasks.push(allTasks.stopConnectors.bind(this));

	tasks.push(function cleanupWatchers(next) {
		this.logger.trace('removing renderers');
		// This clean up method is registered only if renderers has been
		// configured in the first place. So we might skip registering if
		// this.configWeb.needRenderers is false. But to avoid edge cases where
		// the needRenders is out of sync we always register this callback
		// function but only call cleanuWatcher in case hbs middleware has been
		// registered.
		const middleware = this.getMiddleware();
		if (middleware) {
			const handlebars = middleware.getRendererEngine('hbs');
			// stop the handlerbars watcher if running
			if (handlebars) {
				handlebars.cleanupWatchers();
			}
		}
		next();
	}.bind(this));

	// Delete all plugins from require cache so they can be loaded
	// fresh when we restart
	tasks.push(next => {
		this.logger.trace('removing plugins');
		for (const plugin in this.apibuilderPlugins) {
			delete require.cache[plugin];
		}
		next();
	});

	// now fire our lifecycle event
	async.series(tasks, function asyncCallback() {
		this.emit('stopped');
		this.logger.info('Server stopped');
		loadedModelDirs = [];
		callback && callback();
	}.bind(this));

	try {
		this.logger.trace('removing flow-nodes');
		// Unregister node handlers.  This is not done as a task because it is
		// possible to be partially started (and fail).  These need to be done
		// reglardless of start state.
		this.registeredNodes.forEach(function (uri) {
			this.flowManager.unregisterNode(uri);
		}.bind(this));
		this.registeredNodes = [];

		unregisterFlowCoreNodeHandlers(this.flowManager);
		unregisterAPIBuilderNodeHandlers(this);
		unregisterAuthorizationNodeHandlers(this.flowManager);
	} catch (e) {
		// ignore error
	}
};

/**
 * @method createLogger
 * Creates a logger instance.
 * @param {Object} config
 * @param {Object} opts Additional initialization options.
 * @returns {APIBuilder.Logger}
 */
/**
 * @method createLogger
 * @static
 * Creates a logger instance.
 * @param {Object} config - Logger config options.
 * @param {Object} opts - Deprecated: Additional initialization options.
 * @returns {APIBuilder.Logger}
 */
APIBuilder.prototype.createLogger
	= APIBuilder.createLogger = Logger.createLogger;

// create a continuation monkey patch in the case the server hasn't yet loaded
// and we've created a Model
function createModelClassContinuationPatch(Model) {
	if (globalAPIBuilder && !globalAPIBuilder.loaded) {
		// monkey patch any methods that must have a valid connector that is running before we
		// can call it
		var methods = [
			'create', 'delete', 'replace', 'save', 'update', 'delete', 'deleteAll', 'find', 'findAll', 'findByID',
			'findById', 'findOne', 'fetch', 'query', 'remove', 'removeAll'
		];
		methods.forEach(function (fnName) {
			var ModelFn = Model[fnName];
			if (ModelFn) {
				Model[fnName] = createModelMethodMonkeyPatch(Model, ModelFn, fnName);
			}
		});

		// unwrap the methods after the apibuilder loads
		function builderLoader() {
			var methods = [
				'create', 'delete', 'replace', 'save', 'update', 'delete', 'deleteAll', 'find', 'findAll', 'findByID',
				'findById', 'findOne', 'fetch', 'query', 'remove', 'removeAll'
			];
			methods.forEach(function (fnName) {
				if (Model[fnName] && Model[fnName].originalFunction) {
					Model[fnName] = Model[fnName].originalFunction;
				}
			});
			globalAPIBuilder.removeListener('loaded', builderLoader);
		}
		globalAPIBuilder.on('loaded', builderLoader);
	}
}

// create a function wrapper that will watch for the server to finish loading
// (which will have started the connectors) before we actually continue with the
// function. the method (fn) being passed in must be async for this to work
function createModelMethodMonkeyPatch(ModelClass, fn, name) {
	// if we're not yet loaded, we can't call methods against the
	// ModelClass. in which case we're going to wait until we're loaded
	// and then once loaded, we'll continue
	function modelMethodMonkeyPatched() {
		var args = arguments;
		function builderLoader() {
			// make sure we resolve the connector to the real connector instance
			if (typeof ModelClass.connector === 'string') {
				ModelClass.connector = APIBuilder.getConnector(ModelClass.connector);
			}
			globalAPIBuilder.removeListener('loaded', builderLoader);
			// re-patch it back to the original so subsequent doesn't come back through this block
			// anymore
			ModelClass[name] = fn;
			// go ahead invoke
			return fn.apply(ModelClass, args);
		}
		// wait for loaded to fire
		if (globalAPIBuilder.loaded) {
			builderLoader();
		} else {
			globalAPIBuilder.on('loaded', builderLoader);
		}
	}

	modelMethodMonkeyPatched.originalFunction = fn;

	return modelMethodMonkeyPatched;
}

/*
 * monkey patch Model.extend to make sure that we set the instance of the
 * connector before returning
 */
const ModelExtend = APIBuilder.Model.extend;
const ModelReduce = APIBuilder.Model.reduce;

// interface is now .extend(originalModelName, name, definition)
APIBuilder.Model.extend = createModelMonkeyPatch(ModelExtend, 'extend');
APIBuilder.Model.reduce = createModelMonkeyPatch(ModelReduce, 'reduce');

function createModelMonkeyPatch(ModelClass, method) {
	function createModel() {
		// if we're extending a named model, resolve it first
		var model;
		if (arguments.length === 3) {
			// if we're in the middle of loading models on startup, we need to deal
			// with the case we are extending a model that has not been loaded yet,
			// in which case we want to record the dependency and then load later
			if (globalAPIBuilder && globalAPIBuilder.loadingModels) {
				var args = arguments,
					self = this;
				function fn() {
					globalAPIBuilder.removeListener('loadedModels', fn);
					createModel.apply(self, args);
				}
				globalAPIBuilder.on('loadedModels', fn);
				return { deferred: true };
			}
			// tricky. we need to check to see if the incoming connector referenced by
			// the new model is referencing a connector that is disabled and if so, just
			// return null so that the model load just fails silently (which is OK)
			if (arguments[2].connector) {
				var connector = typeof arguments[2].connector === 'string' ? APIBuilder.getConnector(arguments[2].connector) : arguments[2].connector;
				if (connector && !connector.enabled) {
					var connectorName = connector.name || arguments[2].connector;
					globalAPIBuilder && globalAPIBuilder.logger.debug('connector (' + connectorName + ') disabled, skipping model', arguments[1]);
					return;
				}
			}
			var extendModel = typeof arguments[0] === 'string' ? APIBuilder.getModel(arguments[0], true) : arguments[0],
				name = arguments[1],
				def = arguments[2];
			model = extendModel[method](name, def);
			// we need to set in case it wasn't set. this happens in cases where we loaded async
			model.name = name;
			model._parent = extendModel;
			model._supermodel = extendModel.name;
			if (!model.connector) {
				model.connector = extendModel.connector;
			}
			// if the extended model is autogen (like a built-in connector model) but we didn't
			// specify one in our own definition, assume we want to autogen it
			if (!extendModel.autogen && def.autogen === undefined) {
				model.autogen = true;
			}
			// make sure we record it. this happens in the case we async load and we didn't put it
			// in because of that...
			if (!isModelDuplicate(model.name)) {
				globalAPIBuilder.models[model.name] = model;
				// FIXME: This sucks that it's not going to get all the info that
				// loadModel adds to a Model. Not going to refactor now
				// but at least register it as used.
				globalAPIBuilder._internal.pluginUse.registerModel(model);
			}
		} else {
			// else we're creating a simple new model
			model = ModelClass.apply(APIBuilder.Model, arguments);
			isModelDuplicate(model.name);
		}

		if (model.connector && typeof model.connector === 'string') {
			// if we're running and we have a string, resolve it
			if (globalAPIBuilder && globalAPIBuilder.loaded) {
				model._connector = model.connector;
				model.connector = APIBuilder.getConnector(model.connector, true);
				model.connector.emit('init-model', model);
			} else {
				// we need to monkey patch to create continuation
				createModelClassContinuationPatch(model);
			}
		} else if (model.connector) {
			model.connector.emit('init-model', model);
		}

		return model;
	}
	return createModel;
}

/**
 * Creates a model class.
 * @static
 * @param {String} name Name of the new Model.
 * @param {APIBuilderModelDefinition} definition Model definition object.
 * @returns {APIBuilder.Model}
 */
APIBuilder.createModel = function _createModel() {
	return globalAPIBuilder.createModel.apply(globalAPIBuilder, arguments);
};

/**
 * @method createModel
 * @alias #static-method-createModel
 */
APIBuilder.prototype.createModel = APIBuilder.Model.extend;

/**
 * Adds a model class(es) on this instance.
 * @param {APIBuilder.Model/Array<APIBuilder.Model>} model Model class(es) to add.
 */
APIBuilder.prototype.addModel = function addModel() {
	this.logger.trace('adding model', ...arguments);
	for (var c = 0; c < arguments.length; c++) {
		var ModelClass = arguments[c];
		if (!isModelDuplicate(ModelClass.name)) {
			this.models[ModelClass.name] = ModelClass;
		}
		// Has the server already started?
		if (this.server) {
			var startAt = this.apis.length;
			this.createAPIsFromModel(ModelClass);
			for (var i = startAt; i < this.apis.length; i++) {
				this.apis[i].bind(this.app);
			}
		}
	}
};

/**
 * Gets a model by name.
 * @static
 * @param {String} name Name of the model to retrieve.
 * @param {Boolean} [failIfMissing] Set to `true` to throw an error if the model could not be found.
 * @returns {APIBuilder.Model}
 * @throws Error
 */
APIBuilder.getModel = function _getModel() {
	return globalAPIBuilder && globalAPIBuilder.getModel.apply(globalAPIBuilder, arguments);
};

/**
 * @alias #static-method-getModel
 */
APIBuilder.prototype.getModel = function getModel(name, failIfMissing) {
	if (!this.models) {
		// this is only initialized that the end of the APIBuilder constructor, so if an
		// error/exception is thrown early (e.g. in validateConfig), then this will not be set.
		return null;
	}
	var result = this.models[name];
	if (!result) {
		var tokens = name.split('/');
		if (tokens.length > 1) {
			var connectorName = tokens[0],
				modelName = tokens[1],
				connector = globalConnectors[connectorName];
			if (!connector && failIfMissing) {
				throw new Error('Couldn\'t find connector named: ' + connectorName);
			}
			result = connector
				&& connector.models
				&& (
					connector.models[modelName]
					|| connector.models[connectorName + '/' + modelName]
					|| connector.models[connector.name + '/' + modelName]
				);
		}
	}
	if (!result && failIfMissing) {
		throw new Error('Couldn\'t find model named: ' + name);
	}

	// If the model is composite, then ensure that any models of which it is
	// comprised, exist.  If not, this method will throw when the composite
	// model is not found in APIBuilder.prototype.getModel above.
	if (result && result.connector.name === 'composite') {
		for (let fieldName in result.fields) {
			if (result.fields.hasOwnProperty(fieldName)) {
				const field = result.fields[fieldName];
				const throwIfNotFound = true;
				this.getModel(field.model, throwIfNotFound);
			}
		}
	}
	return result;
};

/**
 * Gets an array of APIs available to the instance.
 * @returns {Array<APIBuilder.API>}
 */
APIBuilder.prototype.getAPIs = function getAPIs() {
	return this.apis;
};

/**
 * Returns an API for the given path and optional method in the case where more than one method.
 * may be invoked on a path. If you defined a nickname when creating the API instance, you may pass
 * the nickname to the function rather than the path and method.
 * @param {String} path Path of the API (or its nickname).
 * @param {String} [method] HTTP verb.
 * @returns {APIBuilder.API}
 */
APIBuilder.prototype.getAPI = function getAPI(path, method) {
	var pathAsRoute = path;
	if (path.substring(0, 1) !== '/') {
		pathAsRoute = '/' + path;
	}
	for (var c = 0; c < this.apis.length; c++) {
		if (
			(this.apis[c].path === pathAsRoute || this.apis[c].nickname === path)
			&& (
				!method
				|| (this.apis[c].method.toUpperCase() === method.toUpperCase())
			)
		) {
			return this.apis[c];
		}
	}
};

/**
 * Adds an API on this instance.
 * @param {APIBuilder.API} api API to add.
 */
APIBuilder.prototype.addAPI = function addAPI(APIConstructor) {
	if (_.isFunction(APIConstructor)) {
		var api = new APIConstructor(this.config, this);
		this.apis.push(api);
	} else {
		this.apis.push(APIConstructor);
	}
};

/**
 * Gets all models availabe to the instance.
 * @returns {Array<APIBuilder.Model>}
 */
APIBuilder.prototype.getModels = function getModels() {
	return this.models;
};

/**
 * Gets a block by name.
 * @param {String} name Name of the block to retrieve.
 * @param {Boolean} [failIfMissing] Set to `true` to throw an error if the block could not be found.
 * @returns {APIBuilder.Block}
 * @throws Error
 */
APIBuilder.prototype.getBlock = function getBlock(name, failIfMissing) {
	var result = this.blocks[name];
	if (!result && failIfMissing) {
		throw new Error('Couldn\'t find block named: ' + name);
	}
	return result;
};

/**
 * Gets all the flow definitions availabe to the instance.
 * @returns {Object}
 */
APIBuilder.prototype.getFlows = function getFlows() {
	return this.flowManager.getFlows();
};

/**
 * Gets the flow definition by id.
 * @param {String} flowId The id of the flow to retrieve.
 * @returns {Object}
 */
APIBuilder.prototype.getFlow = function getFlow(flowId) {
	return this.flowManager.getFlow(flowId);
};

/**
 * gets the schema for a specific node handlers
 * @param  {string} type - type/name of the schema
 * @return {Object}      - the schema for the handler
 */
APIBuilder.prototype.getRegisteredNodeSpec = function getRegisteredNodeSpec(type) {
	return this.flowManager.getRegisteredNodeSpec(type);
};

/**
 * gets all the schemas for the node handlers
 * @return {Object} - the schemas for the handlers
 */
APIBuilder.prototype.getRegisteredNodeSpecs = function getRegisteredNodeSpecs() {
	return this.flowManager.getRegisteredNodeSpecs();
};

/**
 * Gets an endpoint by path
 * @param  {String} endpoint The endpoint to get. ie '/greet'
 * @return {Object} or undefined
 */
APIBuilder.prototype.getEndpoint = function (endpoint) {
	return this.endpoints[endpoint].endpoint;
};

/**
 * Gets all loaded endpoints
 * @return {Object}
 */
APIBuilder.prototype.getEndpoints = function () {
	return this.endpoints || {};
};

/**
 * Gets a route by name.
 * @param {String} name Name of the route to retrieve.
 * @param {Boolean} [failIfMissing] Set to `true` to throw an error if the route could not be found.
 * @returns {APIBuilder.Router}
 * @throws Error
 */
APIBuilder.prototype.getRoute = function getBlock(name, failIfMissing) {
	var result = _.find(this.routes, { name: name });
	if (!result && failIfMissing) {
		throw new Error('Couldn\'t find route named: ' + name);
	}
	return result;
};

/**
 * Adds the block(s) on this instance.
 * @param {APIBuilder.Block/Array<APIBuilder.Block>} block Block(s) to add.
 */
APIBuilder.prototype.addBlock = function () {
	for (var c = 0; c < arguments.length; c++) {
		var Block = arguments[c];
		this.blocks[Block.name] = Block;
	}
};

/**
 * Gets all blocks.
 * @returns Array<APIBuilder.Block>
 */
APIBuilder.prototype.getBlocks = function getBlocks() {
	return this.blocks;
};

/**
 * Gets a codeblock by name.
 * @param {String} name Name of the codeblock to retrieve.
 * @param {Boolean} [failIfMissing] Set to `true` to throw an error if the codeblock could
 * @not be found.
 * @returns {APIBuilder.Codeblock}
 * @throws Error
 */
APIBuilder.prototype.getCodeblock = function getCodeblock(name, failIfMissing) {
	var result = this.codeblocks[name];
	if (!result && failIfMissing) {
		throw new Error('Couldn\'t find codeblock named: ' + name);
	}
	return result;
};

/**
 * Gets all codeblocks.
 * @returns Array<APIBuilder.Codeblock>
 */
APIBuilder.prototype.getCodeblocks = function getCodeblocks() {
	return this.codeblocks;
};

/**
 * Returns a registered connector by name.
 * @static
 * @param {String} name Name of the connector to retrieve.
 * @param {Boolean} [failIfMissing] Set to `true` to throw an error if the connector could
 * @not be found.
 * @throws Error
 */
APIBuilder.getConnector = function _getConnector() {
	if (!globalAPIBuilder) {
		throw new Error('an APIBuilder instance has not yet been created');
	}
	return globalAPIBuilder.getConnector.apply(globalAPIBuilder, arguments);
};

/**
 * Gets a connector by name.
 * @param {String} name Name of the connector to retrieve.
 * @param {Boolean} [failIfMissing] Set to `true` to throw an error if the connector could
 * @not be found.
 * @throws Error
 */
APIBuilder.prototype.getConnector = function getConnector(name, failIfMissing) {
	if (!name) {
		throw new Error('missing name');
	}

	let connector = globalConnectors[name];
	if (connector) {
		return connector;
	}

	// Find connector config
	let pluginName;
	let config = this.config || new Loader();

	if (config.connectors && name in config.connectors) {
		config = config.connectors[name];
		pluginName = config.connector;
	}

	if (!pluginName) {
		throw new Error(`Dataconnector ${name} is not configured correctly.`);
	}

	const plugin = this.apibuilderPlugins[pluginName];
	if (plugin && plugin.components.dataconnector) {
		// Instantiate the connector
		try {
			const ConnectorFactory = plugin.components.dataconnector;
			if (ConnectorFactory) {
				// re-entrant flag in case a Connector inadvertently calls
				// APIBuilder.loadModelsForConnector during this ConnectorFactory.create
				// which will cause us to re-enter this method into an infinite recursion
				// problem ... so we note and then do it again later if we have this happen
				inGetConnector = true;
				const Connector = ConnectorFactory.create(APIBuilder, this);
				inGetConnector = false;
				connector = new Connector(config || {});
				if (connector) {
					connector.filename = plugin.path;
					connector.name = name;
					// TODO: we need to register the connector for lookup later
					// (i.e. add an alias ref) to the plugin so it can look up
					// usage.
					this.registerConnector(connector);
					// if we have a post create lifecycle callback, call it this will allow
					// connectors to do things like call APIBuilder.loadModelsForConnector
					// after the connector is instantiated but before it is returned. If we
					// don't do this we will get into an infinite loop where things done in the
					// constructor (like load models) that require the connector will attempt
					// to re-instantiate the connector again (since it's not done registering)
					if (pendingModels) {
						connector.models = APIBuilder.loadModelsForConnector(
							connector.name, pendingModels.module, pendingModels.dir);
						pendingModels = null;
					}
					if (connector.postCreate) {
						connector.postCreate.call(connector);
					}
				}
			}
		} catch (e) {
			this.logger.error('Error loading connector: ' + name, e);
			throw e;
		}
	}
	if (!connector && failIfMissing) {
		throw new Error('Couldn\'t find connector named: ' + name);
	}

	return connector;
};

/**
 * @method getConnectors
 * Gets a list of registered connectors.
 * @returns {Array}
 */
APIBuilder.prototype.getConnectors = function getConnectors() {
	return globalConnectors;
};

/**
 * @method registerConnector
 * @static
 * Registers a connector.
 * @param {APIBuilder.Connector} connector Connector to register.
 */
/**
 * @method registerConnector
 * @alias #static-method-registerConnector
 */
APIBuilder.registerConnector
	= APIBuilder.prototype.registerConnector = function registerConnector(connector) {
		globalConnectors[connector.name] = connector;

		// attach a get model convenience function on the connector
		if (!connector.getModel) {
			connector.getModel = function (name) {
				return this.models && (this.models[name] || this.models[this.name + '/' + name]);
			};
		}

		if (connector.models) {
			Object.keys(connector.models).forEach(function keyIterator(name) {
				var model = connector.models[name];
				// map to the real connector instance
				model.connector = connector;
			});
		}
	};

function loadModels(models, dir, connectorName) {
	if (loadedModelDirs.indexOf(dir) >= 0) {
		return;
	}
	loadedModelDirs.push(dir);
	fs.readdirSync(dir).forEach(function modelResolver(name) {
		var p = path.join(dir, name);
		if (fs.statSync(p).isDirectory()) {
			loadModels(models, p, connectorName);
		} else if (path.extname(p) === '.js' && path.basename(p).charAt(0) !== '_') {
			// only do .js files that don't start with _
			var model = paths.requireComponent(p);
			if (model && !(model.name in models)) {
				if (model.fields && Object.keys(model.fields).length) {
					models[model.name] = model;
					// register that the connector is used by this model
					globalAPIBuilder && (model.connector = APIBuilder.getConnector(connectorName));
					model.filename = p;
					globalAPIBuilder && globalAPIBuilder.addModel(model);
				}
			} else {
				throw new Error('Model: ' + model.name + ' already exists in connector: ' + connectorName);
			}
		}
	});
}

/**
 * Removes a model from this instance.
 * @param {APIBuilder.Model} model Model to remove.
 */
APIBuilder.prototype.removeModel = util.deprecate(function removeModel(model) {
	delete this.models[model.name];
}, 'APIBuilder.removeModel is deprecated. See: https://docs.axway.com/bundle/api-builder/page/docs/deprecations/index.html#D018', 'D018');

/**
 * Removes a connector.
 * @param {APIBuilder.Connector} connector Connector to remove.
 */
APIBuilder.prototype.removeConnector = util.deprecate(function removeConnector(connector) {
	delete this.connectors[connector.name];
}, 'APIBuilder.removeConnector is deprecated. See: https://docs.axway.com/bundle/api-builder/page/docs/deprecations/index.html#D019', 'D019');

/**
 * Removes a block.
 * @param {APIBuilder.Block} block Block to remove.
 */
APIBuilder.prototype.removeBlock = util.deprecate(function removeBlock(block) {
	delete this.blocks[block.name];
}, 'APIBuilder.removeBlock is deprecated. See: https://docs.axway.com/bundle/api-builder/page/docs/deprecations/index.html#D020', 'D020');

/**
 * Removes an API.
 * @param {APIBuilder.API} api API to remove.
 */
APIBuilder.prototype.removeAPI = util.deprecate(function removeAPI(api) {
	for (var c = 0; c < this.apis.length; c++) {
		var a = this.apis[c];
		// eslint-disable-next-line security/detect-possible-timing-attacks
		if (a === api) {
			this.apis.splice(c, 1);
			break;
		}
	}
	api.remove(this);
}, 'APIBuilder.removeAPI is deprecated. See: https://docs.axway.com/bundle/api-builder/page/docs/deprecations/index.html#D021', 'D021');

/**
 * Removes a route.
 * @param {APIBuilder.Router} route Route to remove.
 */
APIBuilder.prototype.removeRoute = util.deprecate(function removeRoute(route) {
	if (route) {
		for (var i = 0; i < this.routes.length; i++) {
			var currentRoute = this.routes[i];
			if (currentRoute === route) {
				this.routes.splice(i, 1);
				break;
			}
		}
		route.remove(this);
	}
}, 'APIBuilder.removeRoute is deprecated. See: https://docs.axway.com/bundle/api-builder/page/docs/deprecations/index.html#D023', 'D023');

/**
 * returns an APIBuilder toJSON description
 */
APIBuilder.prototype.toJSON = function () {
	return '[object APIBuilder]';
};

// We leave that in always to work with older node versions
// and to prevent a breaking change when working with newers
APIBuilder.prototype.inspect = () => '[object APIBuilder]';
if (inspect) {
	// After Node 10.12 inspect should be used as shared symbol
	APIBuilder.prototype[inspect] = () => '[object APIBuilder]';
}

/**
 * Dynamically loads the models into the server if the connector updates them dynamically
 * (i.e. after connect has run and started);
 */
APIBuilder.prototype.registerModelsForConnector
	= function registerModelsForConnector(connector, models) {
		if (!models || !_.isObject(models)) {
			throw new Error('Invalid argument passed to registerModelsForConnector: connector/' + connector.name + '; models must be an object.');
		}

		// Remove models that have no fields as they are not usable.
		models = Object.keys(models).reduce(function (col, name) {
			if (models[name].fields && Object.keys(models[name].fields).length) {
				col[name] = models[name];
			}
			return col;
		}, {});

		Object.keys(models).forEach(function (name) {
			var Model = models[name];
			if (Model.visible || Model.visible === undefined) {
				this.models[name] = Model;
			}
		}.bind(this));
	};

/**
 * Called by a connector to attempt to load any connector bundled models.
 * @param {String} connectorName Name of the connector.
 * @param {Object} module Connector module instance.
 * @param {String} dir Directory of the connector's models. Default is the
 * @connector's models folder.
 */
APIBuilder.loadModelsForConnector = function loadModelsForConnector(connectorName, module, dir) {
	if (inGetConnector) {
		// handle re-entrant issue with ConnectorFactory that calls this during
		// instantiation if we're still loading. will cause us to do this after its done
		pendingModels = { module: module, dir: dir };
		return;
	}
	var modelsDir = path.resolve(dir || path.join(path.dirname(path.dirname(module.filename)), 'models'));

	// attempt to load any models packaged with the connector
	if (fs.existsSync(modelsDir)) {
		var models = {};
		loadModels(models, modelsDir, connectorName);
		return models;
	}
};

// map helper functions
APIBuilder.pluralize = util.deprecate(function doPluralize(name) {
	return pluralize(name);
}, 'APIBuilder.pluralize is deprecated. See https://docs.axway.com/bundle/api-builder/page/docs/deprecations/index.html#D031', 'D031');

APIBuilder.singularize = util.deprecate(function doSingularize(name) {
	return pluralize(name, 1);
}, 'APIBuilder.singularize is deprecated. See https://docs.axway.com/bundle/api-builder/page/docs/deprecations/index.html#D032', 'D032');

function setupSecurityHeaders(server) {
	server.use(xssfilter());
	server.use(frameguard({ action: 'deny' }));
	server.use(nocache());
	server.use(nosniff());
}

function setupStaticPublicMiddleware(server, appdir) {
	server.use(express.static(path.join(appdir, 'web', 'public')));
}

const adminExp = new RegExp(/^\/(console|adminapi)(\/.*)?$/);
function isRuntimeRequest(req) {
	return !adminExp.test(req.originalUrl);
}

function setupAuthenticationStrategy(apiBuilder) {
	apiBuilder.authStrategy = new Authentication(apiBuilder);
	apiBuilder.accessControlMiddleware = getAccessControlMiddleware({
		logger: apiBuilder.logger,
		config: apiBuilder.config,
		authStrategy: apiBuilder.authStrategy,
		isCORSReq: apiBuilder.corsAPI.isCORSReq,
		isCORSPreflight: apiBuilder.corsAPI.isPreflight,
		caseSensitive: () => {
			// this is a function to allow this to be set by the application
			return apiBuilder.app.get('case sensitive routing') || false;
		}
	});
}

/**
 * Returns the request information. If redaction is enabled, the request info
 * has some of its sensitive parts redacted. The redacted sections include:
 * authorization and apikey header values.
 *
 * If the redaction is disabled the undredacted request information is returned.
 *
 * @param {Object} req - The request.
 * @param {Boolean} enableRedaction - Toggles on/off the redaction of the req's
 *   sensitive header information.
 *
 * @returns The original request info in development or the redacted version in
 * 	production.
 */
function getRequestInfo(req, enableRedaction) {
	let headers = req.headers;
	if (enableRedaction) {
		const redactedString = '**********';

		// Makes a copy of the req.headers so we don't mutate the original req.
		headers = {
			...req.headers
		};

		// These are the exact keys we use for these headers. We don't have to
		// manually check for different types of cases.
		const { authorization, apikey } = headers;

		// Replace the sensitive info with a redacted string.
		if (authorization) {
			headers.authorization = redactedString;
		}
		if (apikey) {
			headers.apikey = redactedString;
		}
	}

	return {
		method: req.method,
		url: req.url,
		headers,
		remoteAddress: req.socket.remoteAddress,
		remotePort: req.socket.remotePort
	};
}

function getRequestMiddleware(enableRedaction) {
	return function requestMiddleware(req, resp, next) {
		// handle serialization to the log so that we only dump a subset of the object
		req.inspect = function () {
			return '[object Request]';
		};
		req.toJSON = function () {
			// The normal toJSON does not have the redaction of senstive info ON.
			return getRequestInfo(req, false);
		};

		resp.inspect = function () {
			return '[object Response]';
		};
		resp.toJSON = function () {
			// express creates a circular reference to req.res and res.req.
			return {
				statusCode: resp.statusCode,
				headers: resp.getHeaders()
			};
		};
		// Log admin ui and api requests at trace and everything else at info
		const level = isRuntimeRequest(req) ? 'info' : 'trace';

		if (req.logger.willLogAt(level.toUpperCase())) {
			const requestInfo = getRequestInfo(req, enableRedaction);
			// Its always been this way, but this can fail even though the chances
			// are slim. If it does fail it is questionable if we should fail the
			// whole middleware because we failed to log.
			req.logger[level]('Request', chalk.grey(JSON.stringify(requestInfo)));
		}

		next();
	};
}

/**
 * called at the end of a request once it's done sending
 */
function endRequestMiddleware(req, resp) {
	if (req.pendingReqCount) {
		pendingRequests--;
		if (pendingRequests < 0) {
			pendingRequests = 0;
		}
		req.pendingReqCount = null;
		resp.once('finish', () => {
			const level = isRuntimeRequest(req) ? 'info' : 'trace';
			if (req.logger.willLogAt(level.toUpperCase())) {
				// Log admin ui and api responses at trace and everything else
				// at info.
				req.logger[level]('Response', chalk.grey(JSON.stringify(resp)));
			}
		});
	}
}
