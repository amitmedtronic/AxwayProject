const URL = require('url');
const _ = require('lodash');
const fs = require('fs-extra');
const path = require('path');

/* List of default headers the server whitelists that browsers are allowed to access.
	Can be overridden in config using:
	cors: {
		'Access-Control-Expose-Headers': ['foo-header', 'bar-header']
	}

	NOTE: The 6 headers are always exposed by default are:
	Cache-Control, Content-Language, Content-Type, Expires, Last-Modified, Pragma
*/
const DEFAULT_SAFE_EXPOSE_HEADERS = [
	'request-id',
	'response-time'
];

/* List of default headers the server accepts. Can be overridden in config using:
	cors: {
		'Access-Control-Allow-Headers': ['foo-header', 'bar-header']
	}
*/
const DEFAULT_SAFE_REQUEST_HEADERS = [
	'x-requested-with',
	'accept',
	'origin',
	'content-type',
	'authorization',
	'x-titanium-id',
	'x-native-id'
];

// Headers that are manipulated based on the request conditions.
const HEADERS = {
	allowOrigin: 'Access-Control-Allow-Origin',
	vary: 'vary',
	allowMethods: 'Access-Control-Allow-Methods',
	allowHeaders: 'Access-Control-Allow-Headers',
	exposeHeaders: 'Access-Control-Expose-Headers',
	allowCredentials: 'Access-Control-Allow-Credentials'
};

module.exports = (ctx, options = {}) => {
	return {
		isCORSOn,
		isCORSReq,
		isPreflight,
		addCORSHeaders,
		middlewareForAPIs,
		middleware,
		middlewareForStaticResources
	};

	/**
	 * Middleware function for static resources.
	 * Attaches CORS headers if static resource is available.
	 *
	 * @param {Object} req - the request.
	 * @param {Object} resp - the response.
	 * @param {Object} next - callback for passing control flow to next middleware.
	 */
	async function middlewareForStaticResources (req, resp, next) {
		// A list of the allowed methods for the static resources
		const ALLOWED_STATIC_METHODS = [ 'GET' ];

		if (isCORSReq(req)) {
			const isStatic = await isStaticResource(ctx.publicDirectory, req.path)
				.then((staticResource) => {
					if (!staticResource) {
						return false;
					}
					let corsConf = _.clone(options);
					// Add the allowed methods for the CORS config
					corsConf.defMethods = ALLOWED_STATIC_METHODS;
					addCORSHeaders(corsConf, req, resp);
					return true;
				});

			if (isStatic && isPreflight(req)) {
				return resp.status(200).end();
			}
		}

		next();
	}

	/**
	 * Returns an Express middleware to add CORS headers to the response. Works
	 * on paths bind with PathManager - legacy Endpoints paths and with new
	 * protocol triggers.
	 *
	 * @param {Object} apibuilderInstance - the apibuilder instance
	 * @param {Object} endpointPathItemObj - the endpoint's path item object containing methods
	 */
	function middleware(req, res, next) {
		if (isCORSReq(req)) {
			const pathInfo = ctx.pathManager.getPathInfo(req.path);
			// if we dont't have bound path move to the next middleware.
			if (pathInfo) {
				const corsConf = { ...(options || {}) };
				const preflight = isPreflight(req);
				corsConf.defMethods = [];
				corsConf.defHeaders = [];
				// extract related data from the api object (methods, headers etc)
				if (preflight) {
					corsConf.defMethods = pathInfo.methods;
				} else {
					corsConf.defHeaders = pathInfo.responseHeaders;
				}
				addCORSHeaders(corsConf, req, res);
				if (preflight) {
					return res.status(200).end();
				}
			}
		}
		next();
	}

	/**
	 * Middleware for CORS. Used with old APIs.
	 * It applies CORS headers after some condition checks:
	 * -> is it cors on
	 * -> is it valid origin
	 * -> is it preflight or actual request
	 *
	 * @param {object} req the request
	 * @param {object} resp the response
	 * @param {object} next callback for passing control flow to next middleware
	 */
	function middlewareForAPIs(req, resp, next) {
		const path = req.path;
		if (isCORSReq(req)) {
			const apis = isStaticPath(path)
				? [{ method: 'GET' }] : (ctx.getAPIsForPath(path) || []);
			if (apis.length) {
				const corsConf = _.clone(options || {});
				const preflight = isPreflight(req);
				const methods = {};
				const headers = {};

				// extract related data from the api object (methods, headers etc)
				if (preflight) {
					// CORS should be enabled for our logs XHR
					apis.forEach(function (api) {
						methods[api.method.toUpperCase()] = undefined;
					});
				} else {
					apis.forEach(function (api) {
						// extract headers from the response definition
						api.responses && Object.keys(api.responses).forEach(function (response) {
							const hdrs = api.responses[response].headers;
							hdrs && Object.keys(hdrs).forEach(function (header) {
								// storing in an object to avoid dedupe cost
								headers[header] = undefined;
							});
						});
					});
				}

				// insert extracted data into the cors configs to be used by the addCORSHeaders
				corsConf.defMethods = Object.keys(methods);
				corsConf.defHeaders = Object.keys(headers);
				addCORSHeaders(corsConf, req, resp);
				if (preflight) {
					return resp.status(200).end();
				}
			}
		}
		next();
	}

	/**
	 * Checks if it is CORS request from allowed host.
	 * @param {*} req
	 */
	function isCORSReq(req) {
		const origin = req.headers.origin || '';
		const host = req.headers.host || '';
		const originHost = URL.parse(origin, false).host;
		const confOrigin = options['Access-Control-Allow-Origin'];

		// reset the lastIndex of the RegExp (else wont work for the next request)
		confOrigin && confOrigin.lastIndex && (confOrigin.lastIndex = 0);

		// first check if its a valid CORS request by checking if the origin contains the host.
		// Then check if the origin is allowed or not based on the configuration (The match covers
		// *, single or space separated values, array and regex)
		return origin && originHost !== host
			&& (confOrigin === '*'
				|| (
					typeof confOrigin === 'string'
					&& confOrigin.split(/\s* /).indexOf(origin) !== -1
				)
				|| (confOrigin instanceof Array && confOrigin.indexOf(origin) !== -1)
				|| (confOrigin instanceof RegExp && confOrigin.test(origin)));
	}

	/**
	 * Check if the requested path is among the static paths.
	 * Thoese paths point to some resources like apidocs.
	 *
	 * @param {string} path the requested path
	 * @returns {boolean} true if the path is among static paths
	 */
	function isStaticPath(path) {
		return ((path === ctx.apidocPath) || (path === ctx.apidocPathLegacy));
	}

	/**
	 * Fast check if CORS request is configured on the first place.
	 * It is used to decide if the CORS middleware should be attached at all.
	 * If it is attached we still check if the CORS is from allowed origin with isCORSReq.
	 */
	function isCORSOn() {
		return options['Access-Control-Allow-Origin'] !== undefined;
	}

	/**
	 * Checks if it is preflight request
	 * @param {*} req
	 */
	function isPreflight(req) {
		return req.method === 'OPTIONS' && !!req.headers['access-control-request-method'];
	}

	/**
	 * Adds required CORS headers to the response (assuming its a valid and allowed CORS request)
	 * Implementation is based on https://www.w3.org/TR/2014/REC-cors-20140116/
	 * @param {object} config - apibuilder configuration.cors (support 2 additional fields,
	 *                          1) defMethods: array of methods found in the API definition
	 *                          2) defHeaders: array of headers found in the API definition
	 * @param {Object} req - Express' request object
	 * @param {object} resp - Express' response object
	 * @returns
	 */
	function addCORSHeaders(config, req, resp) {
		const corsConfig = config || {};
		const confCredentials = corsConfig[HEADERS.allowCredentials];
		const origin = req.headers.origin;

		resp.setHeader(HEADERS.allowOrigin, origin);
		resp.setHeader(HEADERS.vary, 'Origin');

		if (isPreflight(req)) {
			let confMethods = convertToArray(corsConfig[HEADERS.allowMethods]);
			// calculate the allowed methods based on bound methods and the ones in the config
			confMethods = confMethods.map(function (val) {
				return val.toUpperCase();
			});
			const safeHeaders = corsConfig.safeHeaders || DEFAULT_SAFE_REQUEST_HEADERS;
			const confHeaders = convertToArray(corsConfig[HEADERS.allowHeaders]);
			const allowHeaders = confHeaders.length ? confHeaders : safeHeaders;
			const defMethods = corsConfig.defMethods || [];
			const allowMethods = confMethods.length
				? _.intersection(defMethods, confMethods) : defMethods;

			// set allow-methods and allow-headers(all supported headers) value
			resp.setHeader(HEADERS.allowMethods, allowMethods.join(', '));
			resp.setHeader(HEADERS.allowHeaders, allowHeaders.join(', '));
		} else {
			// if its an actual request populate the value of expose-headers from configs,
			// definitions and DEFAULT_SAFE_EXPOSE_HEADERS
			const confExpose = convertToArray(corsConfig[HEADERS.exposeHeaders]);
			const defHeaders = convertToArray(corsConfig.defHeaders);
			const exposeHeaders = _.uniq(
				confExpose.concat(DEFAULT_SAFE_EXPOSE_HEADERS, defHeaders));
			resp.setHeader(HEADERS.exposeHeaders, exposeHeaders.join(', '));
		}
		confCredentials && resp.setHeader(HEADERS.allowCredentials, confCredentials);
	}
};
// END MODULE

// convert single or comma seperated values to an array (lower case)
function convertToArray(value) {
	if (Array.isArray(value)) {
		return value.map(function (val) {
			return val.toLowerCase();
		});
	} else if (typeof value === 'string' || value instanceof String) {
		return value.trim().split(/\s*,\s*/).map(function (val) {
			return val.toLowerCase();
		});
	} else {
		return [];
	}
}

/**
 * Determines wheather or not the requested path is to one of the static resources.
 *
 * @param {string} publicDirectory - The path to the static resources in the application.
 * @param {string} resourcePath - The path to the requested resource.
 *
 * @returns {Promise} - Promise object represents the boolean equivelent to being a static
 * resource or not.
 */
function isStaticResource(publicDirectory, resourcePath) {
	return new Promise((resolve) => {
		// Check if the file exists in the public directory.
		fs.access(path.join(publicDirectory, resourcePath), fs.constants.F_OK, (error) => {
			const isStatic = !error;

			resolve(isStatic);
		});
	});
}
