const _ = require('lodash');

const isBuiltinType = (o) => (
	o instanceof Number
	|| o instanceof Object
	|| o instanceof Array
	|| o instanceof String
	|| o instanceof Boolean
	|| o instanceof Date
	|| o instanceof RegExp
);

const Model = (model) => {
	const fields = {};
	for (const fieldName in model.fields) {
		const newField = {},
			originalField = model.fields[fieldName];
		for (const fieldPropertyName in originalField) {
			let fieldProperty = originalField[fieldPropertyName];
			// in objectmodel_test, added field to a test, and the fieldProperty
			// always has a name so this condition can never be true, e.g.:
			// {withfunc: { default: () => 'huh' }}
			// the problem is, I do not know how an anonymous function gets a
			// name, so I'll ignore it.
			/* istanbul ignore if */
			if (_.isFunction(fieldProperty) && !fieldProperty.name) {
				// eww
				let fn = String(fieldProperty),
					i = fn.indexOf('function ('),
					fnName = fieldPropertyName + 'Function';
				if (i === 0) {
					// give it a name
					fn = fn.substring(0, 9) + fnName + ' (' + fn.substring(i + 10);
					fieldProperty = fn;
				}
			} else if (isBuiltinType(fieldProperty)) {
				if (!fieldProperty.name) {
					fieldProperty = fieldProperty.source;
				}
				fieldProperty = fieldProperty && fieldProperty.name
					&& fieldProperty.name.toLowerCase() || String(fieldProperty);
			} else if (_.isObject(fieldProperty)) {
				fieldProperty = String(fieldProperty);
			}
			newField[fieldPropertyName] = fieldProperty;
		}
		newField.type = newField.type || 'string';
		newField.required = !!newField.required;
		newField.optional = !newField.required;
		newField.readonly = !!newField.readonly;
		newField.writeonly = !!newField.writeonly;
		newField.type = String(newField.type.name
			? newField.type.name : newField.type).toLowerCase();
		fields[fieldName] = newField;
	}
	return {
		name: model.name,
		plural: model.plural,
		singular: model.singular,
		description: model.description,
		fields: fields,
		connector: model.connector && (typeof model.connector === 'string'
			? model.connector : model.connector.name),
		metadata: model.metadata
	};
};

const API = (api) => {
	return {
		name: api.method.toUpperCase() + ' ' + (api.pathUnescaped ? api.pathUnescaped : api.path),
		description: api.description,
		responses: api.responses,
		path: api.path,
		pathUnescaped: api.pathUnescaped,
		method: api.method,
		model: api.model && typeof api.model === 'string' ? api.model : api.model && api.model.name,
		response: api.response && typeof api.response === 'string'
			? api.response : api.response && api.response.name,
		responseIsArray: api.responseIsArray === true,
		parameters: api.parameters,
		enabled: !!api.enabled,
		generated: !!api.generated,
		nickname: api.nickname,
		singular: api.singular,
		plural: api.plural
	};
};

class ObjectModel {
	constructor(apibuilder) {
		const models = apibuilder.getModels(),
			apis = apibuilder.getAPIs();

		this.models = {};
		this.apis = {};

		for (const name in models) {
			this.models[name] = Model(models[name]);
		}

		for (const object of apis) {
			let name = object.group || object.name,
				group = this.apis[name];
			if (!group) {
				group = this.apis[name] = {
					endpoints: []
				};
			}
			const api = API(object);
			group.endpoints.push(api);
		}
	}
}

module.exports = ObjectModel;
