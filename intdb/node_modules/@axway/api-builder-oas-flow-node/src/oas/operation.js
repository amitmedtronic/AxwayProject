const contentTypeParser = require('content-type');
const JsonRefs = require('json-refs');
const OASParameter = require('./parameter');
const OASResponse = require('./response');
const getRequestBody = require('./requestBody');
const { sortResponses, generateFunctionName, sortContentTypes } = require('../utils');

class OASOperation {
	/**
	 * Construct a wrapper around Sway operation.
	 *
	 * @param {object} operation - Sway operation object
	 * @param {object} [hostInfo = null] - OAS2 host information object
	 * @param {string} [hostInfo.host] - OAS2 host
	 * @param {string} [hostInfo.basePath] - OAS2 basePath
	 * @param {string} [hostInfo.schemes] - OAS2 schemes
	 * @param {object[]} servers - OAS3 servers
	 * @param {object[]} securitySchemes - Security schemes
	 * @param {string} oasVersion - The OAS version, either 2 or 3.
	 */
	constructor(operation, hostInfo, servers, securitySchemes, oasVersion) {
		// Define non-enumerable private props
		Object.defineProperty(this, '_operation', {
			value: operation
		});
		Object.defineProperty(this, '_oasVersion', {
			value: oasVersion
		});
		Object.defineProperty(this, '_globalServers', {
			value: servers
		});
		Object.defineProperty(this, '_globalHostInfo', {
			value: hostInfo
		});
		Object.defineProperty(this, '_globalSecuritySchemes', {
			value: securitySchemes
		});

		const { description, summary, path } = this._operation.pathObject;

		// Public properties
		this.method = this._operation.method;
		this.path = path;
		this.description = this._operation.description || this._operation.summary
			|| description || summary || '';
		this.name = this._getName();

		// Set parameters related properties
		// 'consumes' has to be before parameters calculation
		this.consumes = this._getConsumes();
		const {
			parameters,
			requestBody,
			requestBodyName
		} = this._getParametersAndRequestBody(operation);
		this.parameters = parameters;
		this._setProperty('requestBody', requestBody);
		this._setProperty('requestBodyName', requestBodyName);

		// Set response related properties
		this.responses = this._getResponses(operation);
		this.produces = this._getProduces();

		// Set security related properties
		this.security = this._operation.getSecurity() || [];
		this.securitySchemes = this._getSecuritySchemes();
		this.requiredSecurity = this._getRequiredSecurity();

		// Set server related properties
		this.servers = this._getServers();
		this.hostInfo = this._getHostInfo();
	}

	_setProperty(name, value) {
		if (value !== undefined) {
			this[name] = value;
		}
	}

	_getName() {
		if (this._operation.definition.operationId) {
			return this._operation.definition.operationId;
		}
		return generateFunctionName(this.method, this.path);
	}

	_getConsumes() {
		let consumes;
		if (this._oasVersion === '2') {
			consumes = filterAndSortConsumes(this._operation);
		} else {
			if (!this._operation.requestBody) {
				return [];
			}
			consumes = Object.keys(this._operation.requestBody.content || []);
			consumes.sort(sortContentTypes);
		}
		return parseContentTypes(consumes);
	}

	_getParametersAndRequestBody(operation) {
		const isVersion2 = this._oasVersion === '2';
		const parameters = [];
		let requestBody;
		let requestBodyName;
		// Sway handles body differently in OAS2 vs OAS3.  In OAS2 it
		// is a parameter.  In OAS3, it is a requestBody.  Unfortunately,
		// this makes it quite difficult to handle.  The code below will
		// make them consistent.  Note that sway parameter is circular,
		// so use `parameter.definition` (which includes references)
		for (const parameter of operation.getParameters()) {
			if (isVersion2 && parameter.in === 'body') {
				requestBody = getRequestBody.fromParameter(
					parameter.definition,
					this.consumes
				);
				requestBodyName = parameter.definition.name;
				continue;
			} else if (isVersion2 && parameter.in === 'formData') {
				requestBody = getRequestBody.fromForm(
					parameter.definition,
					this.consumes,
					requestBody
				);
				continue;
			} else {
				parameters.push(new OASParameter(parameter, this._oasVersion));
			}
		}
		if (!isVersion2 && operation.requestBody) {
			// We do not want `operation.requestBody` because it is the
			// fully dereferenced body.  Instead, we want the raw
			// definition because it may have a schema $ref.
			requestBody = operation.definition.requestBody;
			if (!JsonRefs.isRef(requestBody)) {
				// For consistency, explicitly set required if body is not
				// a ref
				requestBody.required = requestBody.required || false;
			}
		}
		return {
			parameters,
			requestBody,
			requestBodyName
		};
	}

	_getResponses(operation) {
		const responses = [];
		for (const response of operation.getResponses().sort(sortResponses)) {
			responses.push(new OASResponse(response, this._oasVersion));
		}
		return responses;
	}

	_getProduces() {
		let produces;
		if (this._oasVersion === '2') {
			produces = this._operation.produces;
		} else {
			produces = [];
			for (const response of Object.values(this.responses)) {
				if (response.content) {
					const contentTypes = Object.keys(response.content);
					produces.push(...contentTypes);
				}
			}
		}
		return parseContentTypes(produces);
	}

	_getRequiredSecurity() {
		const required = { ...this.securitySchemes };
		for (const requirement of this.security) {
			for (const name in required) {
				if (!requirement[name]) {
					delete required[name];
				}
			}
		}
		return Object.keys(required);
	}

	_getServers() {
		if (this._oasVersion === '3') {
			return this._operation.definition.servers
				|| this._operation.pathObject.servers
				|| this._globalServers;
		} else {
			return this._globalServers;
		}
	}

	_getHostInfo() {
		if (this._oasVersion === '2') {
			if (this._operation.definition.schemes) {
				// method schemes override
				return {
					...this._globalHostInfo,
					schemes: this._operation.definition.schemes
				};
			}
			return this._globalHostInfo;
		}
	}

	_getSecuritySchemes() {
		const securitySchemes = {};
		for (const requirement of this.security) {
			for (const name in requirement) {
				const scheme = this._globalSecuritySchemes[name];
				if (!scheme) {
					throw new Error(`security requirement not defined: ${name}`);
				}
				securitySchemes[name] = scheme;
			}
		}
		return securitySchemes;
	}
}

function filterAndSortConsumes(operation) {
	const FORM_CONTENT_TYPES = [
		'application/x-www-form-urlencoded',
		'multipart/form-data'
	];
	const MULTIPART_FIRST_FORM_CONTENT_TYPES = [
		'multipart/form-data',
		'application/x-www-form-urlencoded'
	];
	let isFormData = false;
	let isFile = false;
	for (const parameter of operation.getParameters()) {
		if (parameter.in === 'body') {
			const consumes = operation.consumes
				.filter(a => !FORM_CONTENT_TYPES.includes(a));
			// We default to 'application/json' when consumes is empty because
			// there are cases where it is possible to be empty, and even
			// though the spec is probably incorrect/ambiguous in some way,
			// there *is* a body specified and it *must* have a content-type
			// defined.  So, we either error (a bit harsh), or we default to
			// 'application/json' because it is reasonable for a REST API.
			return consumes.length
				? consumes.sort(sortContentTypes) : [ 'application/json' ];
		} else if (parameter.in === 'formData') {
			isFormData = true;
			if (parameter.type === 'file') {
				isFile = true;
				break;
			}
		}
	}

	if (isFormData) {
		// Swagger that have formData and does not have form content type
		// is not semantically valid. Old plugin did not catch this.
		// So for backward compatibility add form content types by default
		// if type is missing.
		const consumes = operation.consumes
			.filter(a => FORM_CONTENT_TYPES.includes(a));
		if (!consumes.length || consumes.length === 2) {
			return isFile ? MULTIPART_FIRST_FORM_CONTENT_TYPES : FORM_CONTENT_TYPES;
		} else {
			return consumes;
		}
	}

	return operation.consumes.sort(sortContentTypes);
}

/**
 * Parses an array of content-types and returns a list of only valid
 * content-types, free of duplicate values and stripping off any options.
 * @param {string[]} contentTypes - An array of content-types.
 * @return {string[]} A filtered array of valid content-types.
 */
function parseContentTypes(contentTypes) {
	const types = [];
	for (const type of contentTypes) {
		try {
			const parsed = contentTypeParser.parse(type);
			types.push(parsed.type);
		} catch (ex) {
			// gobble
		}
	}
	// We don't want any duplicates in the list
	return [ ...new Set(types) ];
}

module.exports = OASOperation;
