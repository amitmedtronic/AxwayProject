const debug = require('debug');
const JsonRefs = require('json-refs');
const draft06 = require('ajv/lib/refs/json-schema-draft-06.json');
const draft06Properties = Object.keys(draft06.properties);
const encodeURIComponentRFC3986 = require('strict-uri-encode');

const log = debug('oas-flow-node');

// https://tools.ietf.org/html/draft-wright-json-schema-validation-01#section-8.3
const allowedFormats = [
	'date-time',
	'email',
	'hostname',
	'ipv4',
	'ipv6',
	'uri',
	'uri-reference',
	'uri-template',
	'json-pointer'
];

// schema keys used to identify a simple object definition
const simpleSchemaKeys = [
	'additionalProperties',
	'properties',
	'type',
	'title',
	'description',
	'required'
];

// keys allowed in an oas2 parameter
const oas2ParameterKeys = [
	'type',
	'description',
	'format',
	'items',
	'default',
	'maximum',
	'exclusiveMaximum',
	'minimum',
	'exclusiveMinimum',
	'maxLength',
	'minLength',
	'pattern',
	'maxItems',
	'minItems',
	'uniqueItems',
	'enum',
	'multipleOf'
];

const parameterTypes = [
	'query',
	'header',
	'path',
	'formData',
	'body'
];

// Creates a new object with properties picked from the original
function pickProperties(obj, props) {
	return props.reduce((newObj, prop) => {
		if (obj[prop] !== undefined) {
			newObj[prop] = obj[prop];
		}
		return newObj;
	}, {});
}

// Remove any formats that aren't json-schema compliant.
// Could update ajv with unknownFormats
function removeUnknownFormats(prop) {
	if (allowedFormats.includes(prop.format)) {
		return;
	}
	delete prop.format;
}

/**
 * Recursively sanitizes json-schema by removing non-json-schema properties.
 * and converts OAS schema (extended subset of draft 4 or 5) to a draft 6
 * @param {object} oasSchema - OAS2 JSON schema object.
 * @param {object} [options={}] - Export options.
 * @param {function} [options.after=null] - A callback function that is called
 * on each schema component within `oasSchema`. The function has the signature:
 * `function after(origSchema, schema)`, where `origSchema` is the component
 * that was converted, and `schema` is the conversion. Additional changes can
 * be made to `schema` in this function.
 * @param {boolean} [options.allowUnknownFormats=false] - When disabled, this
 * filters formats that are not declared in the wright schema. If enabled, you
 * need to configure Ajv to handle unknown formats.
 * @return {object} Converted and santized json-schema
 */
function convertOASSchemaToDraft06(oasSchema, options = {}) {
	const {
		after = null,
		allowUnknownFormats = false
	} = options;
	const schema = JSON.parse(JSON.stringify(oasSchema));

	// Migrate to draft 06
	// http://json-schema.org/draft-06/json-schema-migration-faq.html
	// Whenever `exclusiveMaximum` or `exclusiveMinimum` are true, change
	// the value to the corresponding `minimum` or `maximum` value and
	// remove the `minimum` or `maximum` keyword.
	if (typeof schema.exclusiveMaximum === 'boolean') {
		if (schema.exclusiveMaximum) {
			schema.exclusiveMaximum = schema.maximum;
			delete schema.maximum;
		} else {
			delete schema.exclusiveMaximum;
		}
	}
	if (typeof schema.exclusiveMinimum === 'boolean') {
		if (schema.exclusiveMinimum) {
			schema.exclusiveMinimum = schema.minimum;
			delete schema.minimum;
		} else {
			delete schema.exclusiveMinimum;
		}
	}

	if (schema.properties) {
		Object.keys(schema.properties).forEach(propertyName => {
			schema.properties[propertyName] = convertOASSchemaToDraft06(
				schema.properties[propertyName],
				options
			);
		});
	}
	if (schema.additionalProperties
		&& typeof schema.additionalProperties === 'object') {
		schema.additionalProperties = convertOASSchemaToDraft06(
			schema.additionalProperties,
			options
		);
	}
	if (schema.allOf) {
		schema.allOf = schema.allOf
			.map(item => convertOASSchemaToDraft06(item, options));
	}
	if (schema.items) {
		// If type is array, then sanitize array items
		schema.items = convertOASSchemaToDraft06(schema.items, options);
	}
	// these apply to oas3 schemas
	if (schema.oneOf) {
		schema.oneOf = schema.oneOf
			.map(item => convertOASSchemaToDraft06(item, options));
	}
	if (schema.anyOf) {
		schema.anyOf = schema.anyOf
			.map(item => convertOASSchemaToDraft06(item, options));
	}
	if (schema.not) {
		schema.not = convertOASSchemaToDraft06(schema.not, options);
	}

	if (!allowUnknownFormats) {
		removeUnknownFormats(schema);
	}
	// pick only draft 6 properties from schema
	const converted = pickProperties(
		schema, [ ...draft06Properties, 'schema', 'id' ]);
	if (after) {
		after(oasSchema, converted);
	}
	return converted;
}

/**
 * OAS2 parameters have a subset of JSON schema applied to them,
 * and they can also have a 'schema'.  Extract the "schema" bits
 * from the parameter, and convert the param schema,
 * and merge them.
 *
 * @param {object} parameter OAS 2 parameter.
 * @return {object} JSON Schema
 */
function convertOAS2ParameterToSchema(parameter) {
	if (!parameterTypes.includes(parameter.in)) {
		throw new Error(`Unrecognized parameter in: ${parameter.in}`);
	}

	// The parameter.schema is optional.  If it has a schema, then the
	// parameter.in is a "body".  Take the schema. or pull out the v4 props
	const schema = parameter.schema
		? { ...parameter.schema }
		: pickProperties(parameter, oas2ParameterKeys);

	// String is chosen because it's the only valid JSON type that can be provided. Buffers / File
	// objects are prefereable but you cannot represent these in JSON.
	if (parameter.type === 'file') {
		schema.type = 'string';
		schema.format = 'binary';
	}
	enhanceSchemaDescription(parameter.description, schema);

	return schema;
}

/**
 * OAS2 response schemas are identical to regular OAS schemas aside from
 * the type, which can also be "file". In OAS3 this is not valid so when we
 * "upgrade" we should change the type.
 * https://github.com/OAI/OpenAPI-Specification/blob/master/versions/2.0.md#response-object
 * @param {object} responseSchema the schema for an OAS response
 * @returns {object} The original schema, or a new OAS schema with "file" type
 * transformed to "string".
 */
function convertOAS2ResponseSchemaToSchema(responseSchema) {
	if (responseSchema.type !== 'file') {
		return responseSchema;
	}
	return {
		...responseSchema,
		type: 'string',
		format: 'binary'
	};
}

/**
 * Takes two descriptions amd returns
 * a combination of the two as the schema description to ensure
 * no information is lost.
 * @param {string} description description
 * @param {object} schema schema object with optional description
 */
function enhanceSchemaDescription(description, schema) {
	if (description && schema.description) {
		let paramDesc = description.trim();
		const schemaDesc = schema.description.trim();
		if (paramDesc !== schemaDesc) {
			if (!paramDesc.endsWith('.')) {
				paramDesc += '.';
			}
			schema.description = `${paramDesc} ${schemaDesc}`;
		}
	} else if (description) {
		schema.description = description;
	}
}

/**
 * OAS2 headers have a subset of JSON schema applied to them,
 * Extract the "schema" bits from the header, and convert to an OAS schema
 *
 * @param {object} header OAS 2 header.
 * @return {object} JSON Schema
 */
function convertOAS2HeaderToSchema(header) {
	return pickProperties(header, oas2ParameterKeys);
}

/**
 * Formats the JSON schema reference `ref` as an axway schema:/// reference,
 * replacing the `refPrefix` with the `uriPrefix` and returning the result.
 *
 * @param {string} ref - The JSON pointer to rewrite.
 * @param {string} refPrefix - The JSON pointer prefix to rewrite.
 * @param {string} uriPrefix - The schema prefix that replaces `refPrefix`.
 * @return {string} The formatted schema reference.
 */
function formatSchemaRef(ref, refPrefix, uriPrefix) {
	// converts "#/definitions/foo~1Bar" to "#/definitions/foo/Bar"
	// this basically affects only references that have ~1 and ~0
	const unescaped = JsonRefs.decodePath([ ref ])[0];
	const schemaName = unescaped.replace(refPrefix, '');

	// Schema references are of the form "schema:///{scope}/{name}", where
	// `scope` is URI encoded and the `name` is URI encoded (RFC 3986).
	// The `ref` here is a URI Fragment Identifier Representation of a
	// JSON pointer reference
	// (see Section 6 https://tools.ietf.org/html/rfc6901#section-6).
	// The JSON pointer `ref` is URI encoded already, and it should be URI
	// encoded with RFC-3986.  We are effectively stripping off
	// "#/definitions/". First, URI decode the remainder (which might not
	// be RFC-3986), and then re-encode using RFC-3986. This ensures
	// that the schema reference will be valid RFC-3986 (which Ajv requires):
	// https://amplify.git-pages.ecd.axway.int/api-builder/#/schema-references
	const decodedSchemaName = decodeURIComponent(schemaName);
	return `${uriPrefix}/${encodeURIComponentRFC3986(decodedSchemaName)}`;
}

/**
 * Rewrites JSON schema $refs in the referenced document, starting with
 * `options.from`, to a new value provided by `options.to`. The document need
 * not be OAS 2 or 3 specifically, this function supports any JSON document
 * that supports JSON schema.
 *
 * The `references` is an object of references that were returned from
 * `JsonRefs.resolveRefs` and are filtered so that they are all valid, and all
 * start with `options.from`. Note that `references` already contains handles to
 * the source document and this function manipulates those handles to achieve
 * rewriting.
 *
 * For example in OAS 2, from "#/definitions/" to "schema://banana". The key
 * immediately following `options.from` is retained as the name of the component
 * that is being rewritten, e.g. "Pet" if the reference is "#/definitions/Pet".
 * The $ref will be rewritten as: "schema://banana/Pet". If the $ref is for
 * properties deeper than the component, e.g. "#/definitions/Pet/properties/name",
 * then the remainder of the URI is retained as local "anchor" reference to the
 * property, e.g. "schema://banana/Pet#/properties/name".
 *
 * @param {object} references - Resolved local references.
 * @param {object} options - Rewrite options.
 * @param {string} options.from - JSON references with this prefix will be
 * rewritten. This must end in a slash.
 * @param {string} options.to - The schema prefix to replace.
 * @return {object} An object that maps the a JSON schema pointer URI $ref that
 * was rewritten (i.e. a URI to the "component" mentioned above), to an array of
 * JSON schema pointer URI that referenced it.
 */
function rewriteReferences(references, options) {
	const { from, to } = options;
	log('rewriting', options);

	const rewritten = {};
	// note that `from` always ends in a slash when calling this function, so
	// splitting `#/components/` will yield `[ 'components', 'schema', '' ]`,
	// which is the length we need to slice from the reference below (i.e. 3).
	// The part that follows this is the name of the definition being rewritten.
	const fromPathLength = JsonRefs.pathFromPtr(from).length;
	for (const jsonPointer in references) {
		const ref = references[jsonPointer];
		log('rewriting $ref:', ref.uri);

		// To explain what happens below, this gets the definition name that was
		// rewritten. For example, if `from` is `#/components/schema/`, and this
		// is rewriting a `$ref` to this: `#/components/schema/Pet/properties/name`,
		// then the JSON pointer URI to the definition is `#/components/schema/Pet`,
		// and the `$ref` is added to the array of `$ref` that referenced it.,
		// e.g. `"#/components/schema/Pet": [ "#/components/schema/Pet/properties/name" ]`

		// Store the name/paths to the rewritten definition for later deletion
		const parts = JsonRefs.pathFromPtr(ref.uri);

		// Get the path to the component being rewritten. For example,
		// '#/components/schema/Pet'.  To do this, strip off the `from` ref
		// prefix off of the `ref.uri`. This returns first 3 array elements,
		// `[ 'components', 'schema', 'Pet' ]`, and then converts to a URI,
		// '#/components/schema/Pet'.
		const defPtr = JsonRefs.pathToPtr(parts.slice(0, fromPathLength));
		if (!(defPtr in rewritten)) {
			rewritten[defPtr] = [];
		}
		// e.g. "#/components/schema/Pet"
		log('component ptr:', defPtr);

		// Get the anchor (if present). It is possible to have references to a
		// property e.g. '#/components/schemas/Pet/properties/name'. When
		// rewriting, we want to ensure that we preserve the part after the
		// definition name e.g. '/properties/name' in the new ref. But because
		// the new ref is an external URI, it becomes an anchor, relative to
		// the external document, e.g. "schema:///Pet/properties/name".
		const anchor = ref.uri.replace(defPtr, '');
		log('anchor:', anchor);

		// Record what was rewritten
		if (!rewritten[defPtr].includes(ref.uri)) {
			rewritten[defPtr].push(ref.uri);
		}

		// Rewrite the reference in `definition`
		let schemaUri = formatSchemaRef(defPtr, from, to);
		if (anchor) {
			// anchor is already an encoded URI
			schemaUri = `${schemaUri}#${anchor}`;
		}
		log('rewritten uri:', schemaUri);
		// This actually updates the original definition's reference; it is
		// where the rewrite happens
		ref.def.$ref = schemaUri;
	}
	log('rewritten definitions:', rewritten);
	return rewritten;
}

/**
 * Tests if a `schema` defines a simple object with `properties`.  Anything
 * complex, e.g. `additionalProperties`, `oneOf`, `anyOf`, etc. are
 * deemed to be _not_ simple.
 *
 * @param {object} schema - The schema to test
 * @returns {boolean} True if the schema is simple.
 */
function isSimpleSchema(schema) {
	if (schema.type !== 'object') {
		return false;
	}
	if (!schema.properties || !Object.keys(schema.properties).length) {
		return false;
	}
	// Disallow when additionalProperties `true` (or a schema object). Undefined
	// also implies `true` but it's often left out without implying anything.
	// Lets let it through in that case.
	if (schema.additionalProperties) {
		return false;
	}
	for (const key in schema) {
		if (!simpleSchemaKeys.includes(key)) {
			// schema has a key that is not simple, e.g. `oneOf`
			return false;
		}
	}
	return true;
}

module.exports = {
	convertOASSchemaToDraft06,
	convertOAS2ParameterToSchema,
	convertOAS2ResponseSchemaToSchema,
	convertOAS2HeaderToSchema,
	enhanceSchemaDescription,
	rewriteReferences,
	formatSchemaRef,
	isSimpleSchema
};
