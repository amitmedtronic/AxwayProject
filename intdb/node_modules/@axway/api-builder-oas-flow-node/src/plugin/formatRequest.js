const url = require('url');
const chalk = require('chalk');
const debug = require('debug');
const validateSecurityRequirements = require('./validateSecurityRequirements');

const log = debug('oas-flow-node');

/**
 * Formats a request with request parameters, setting headers, query options
 * and formatting the URL.
 *
 * @param {OASOperation} operation - The operation object.
 * @param {object} parameterMap - Map with namespaced names and parameters.
 * @param {object} params - The request parameters.
 * @param {object} options - The request options.
 * @param {object} options.logger - The logger.
 * @param {object} options.authorizations - The request authorization.
 * @param {object} [options.config] - Plugin config overrides.
 * @param {object} [options.config.uri] - URI overrides.
 * @param {string} [options.config.uri.protocol] - URI protocol override.
 * @param {string} [options.config.uri.host] - URI host override.
 * @param {string|number} [options.config.uri.port] - URI port override.
 * @param {string} [options.config.uri.basePath] - URI basePath override.
 * @return {object} Info for making the request:
 * `{ method, uri, headers, cookies, body, options }`
 */
function formatRequest(operation, parameterMap, params, options) {
	const { config, logger, authorizations } = options;
	const query = {};
	const headers = {};
	const cookies = {};
	let body;
	let serverUrl;
	let path = operation.path;

	log('config', config);
	log('formatting request', params);

	// Format parameters
	const map = parameterMap.getMap();
	for (const [ propertyName, property ] of Object.entries(map)) {
		if (params[propertyName] === undefined && property.required) {
			const msg = `Missing required request property: ${propertyName}`;
			logger.error(chalk.red(msg));
			throw new Error(msg);
		}
		// lookup the original parameter name
		const paramName = map[propertyName].name;
		let value = params[propertyName];
		if (value === undefined) {
			// Optional parameter not supplied.  If the parameter has a default
			// value, then assign it here, otherwise, continue.  Note that use
			// of a default should be rare.  At this stage, only _accept,
			// _content-type, serverUrl and serverUrlVariable have
			// default values.
			if (property.default !== undefined) {
				value = property.default;
			} else {
				continue;
			}
		}
		log('formatting parameter', paramName, property);

		/* istanbul ignore else */
		if (property.in === 'query') {
			// TODO: Array format query parameters are not transformed
			// to what their OAS describes (collectionFormat in oas2, "style"
			// (plus more) in oas3 - "style" controls more than just query
			// params of type array though). We currently rely on the default
			// behavior of 'url'
			query[paramName] = value;
		} else if (property.in === 'path') {
			path = replacePathSlug(
				path, property.name, value, { logger }
			);
		} else if (property.in === 'header' && isHeaderValueOK(value)) {
			// Headers are always non-empty strings.  However, if someone uses
			// true/false, or number, we can convert.
			const name = paramName.toLowerCase();
			headers[name] = `${value}`;
		} else if (property.in === 'formData') {
			if (!body) {
				body = {};
			}
			body[paramName] = value;
		} else if (property.in === 'cookie' && isCookieValueOK(value)) {
			cookies[paramName] = value;
		} else if (property.in === 'body') {
			body = value;
		} else if (property.in === 'serverUrl') {
			serverUrl = value;
		} else if (property.in === 'serverUrlVariable') {
			const parts = property.name.split('.');
			const slugName = parts[parts.length - 1];
			serverUrl = replacePathSlug(
				serverUrl, slugName, value, { logger, failIfNotFound: false }
			);
		}
	}

	// Authorizations
	formatAuthorizations(
		operation, authorizations, query, headers, cookies
	);

	const hasCookie = Object.keys(headers)
		.map(a => a.toLowerCase()).includes('cookie');
	const cookieParameters = Object.keys(cookies);
	if (cookieParameters.length) {
		if (!hasCookie) {
			// TODO: support other serialisation methods described by parameter
			// No idea how this is possible when it's described per-parameter
			//
			// FIXME: this works for primitves but we need to encode array and
			// object correctly. Form style parameters defined by RFC6570.
			// This option replaces collectionFormat with a csv (when explode
			// is false) or multi (when explode is true) value from OAS 2.0.
			headers.cookie = cookieParameters
				// FIXME: entirely broken for object/array cookie parameters
				.map(name => `${name}=${cookies[name]}`)
				.join('; ');
		} else {
			const cookieNames = cookieParameters.join(', ');
			logger.warn(
				`Cookie header has already been set. Cannot send additional cookie parameters (${cookieNames}).`
			);
		}
	}

	const uri = formatRequestURL(serverUrl, path, query);
	return {
		method: operation.method,
		uri,
		headers,
		body,
		options: formatAdvancedHTTPOptions(config, params, headers)
	};
}

/**
 * Formats authorizations.
 *
 * @param {OASOperation} operation - The operation object.
 * @param {object} authorizations Authorizations.
 * @param {object} query Request parameters of type query.
 * @param {object} headers Request parameters of type headers.
 * @param {object} cookies Request parameters of type cookie.
 */
function formatAuthorizations(
	operation, authorizations, query, headers, cookies
) {
	// Validate requirements - will throw if there are requirements and none are met.
	validateSecurityRequirements.validate(operation.security, authorizations);
	for (const name in authorizations) {
		const value = authorizations[name];
		const scheme = operation.securitySchemes[name];
		log(`authorization scheme ${name}:`, scheme);
		if (scheme.type === 'apiKey' && scheme.in === 'header') {
			// e.g. Authorization: Basic ABC1234==
			headers[scheme.name] = value;
		} else if (scheme.type === 'apiKey' && scheme.in === 'query') {
			// e.g. ?api_key=ABS1234
			query[scheme.name] = value;
		} else if (scheme.type === 'apiKey' && scheme.in === 'cookie') {
			cookies[scheme.name] = value;
		} else if (scheme.type === 'http' && scheme.scheme === 'basic') {
			headers.Authorization = `Basic ${value}`;
		} else if (scheme.type === 'oauth2') {
			headers.Authorization = `Bearer ${value}`;
		} else if (scheme.type === 'http') {
			const error = `The HTTP ${scheme.scheme} security scheme for the authorization parameter "${name}" is currently unsupported.`;
			throw new Error(error);
		} else if (scheme.type === 'openIdConnect') {
			const error = `The OpenID Connect security scheme for the authorization parameter "${name}" is currently unsupported.`;
			throw new Error(error);
		} else {
			const error = `The security scheme of type "${scheme.type}" for the authorization parameter "${name}" is currently unsupported.`;
			throw new Error(error);
		}
	}
}

/**
 * Produces the options used by axway requester to fine tune
 * the http request. Requester could take configurations from
 * the plugin config and from the UI parameters.
 *
 * @param {object} config - Plugin config.
 * @param {object} params - UI parameters.
 * @param {object} headers - Request headers.
 * @return {object} The HTTP requester options.
 */
function formatAdvancedHTTPOptions(config, params, headers) {
	const ALLOWED_REQUESTER_CONFIG = [ 'proxy', 'insecureSSL' ];
	const requesterOptions = {};

	// configuration from 1) pluginConfig
	ALLOWED_REQUESTER_CONFIG.forEach((keyName) => {
		if (config.hasOwnProperty(keyName)) {
			requesterOptions[keyName] = config[keyName];
		}
	});

	// configuration from 2) UI parameters
	if (params['_decode-response'] !== undefined) {
		requesterOptions.decode = params['_decode-response'];
	}
	if (params['_headers'] !== undefined) {
		const headerMap = Object.keys(headers).reduce((acc, cur) => {
			acc[cur.toLowerCase()] = cur;
			return acc;
		}, {});

		for (const [ header, headerValue ] of Object.entries(params['_headers'])) {
			const lcheader = header.toLowerCase();
			if (headerValue === null) {
				const headerName = headerMap[lcheader];
				delete headers[headerName];
			} else {
				const lcHeader = header.toLowerCase();
				headers[lcHeader] = `${headerValue}`;
			}
		}
	}
	return requesterOptions;
}

/**
 * Constructs the URL based on what is specified in plugin config.
 * Falls back to what is specified in the operation (from OAS spec).
 *
 * @param {OASOperation} serverUrl - The `operation.url`.
 * @param {string} path - The resolved URL path.
 * @param {string} query - The request query.
 * @return {object} The formated URL.
 */
function formatRequestURL(serverUrl, path, query) {
	const parsedURL = new url.URL(serverUrl);
	// The URL.pathname can have a trailing slash.  We don't want that.
	const parsedPath = parsedURL.pathname.replace(/\/$/, '');
	const basePath = parsedPath || '';
	const protocol = parsedURL.protocol;
	const hostname = parsedURL.hostname;
	const port = parsedURL.port;
	const pathname = `${basePath}${path}`;
	return url.format({
		protocol,
		hostname,
		pathname,
		port,
		query
	});
}

/**
 * Replace parametrized part of the path with the actual value.
 *
 * @param {string} path - The path to instrument.
 * @param {string} name - Parametrized parameter.
 * @param {string} value - The value for the parametrized part.
 * @param {object} logger - The logger.
 * @return {string} The request path.
 */
function replacePathSlug(
	path, name, value, { logger, failIfNotFound = true }
) {
	const slug = `{${name}}`;
	const pos = path.indexOf(slug);
	if (pos >= 0) {
		logger.trace(`replace slug "${slug}" with "${value}" in "${path}"`);
		path = path.replace(slug, value);
	} else if (failIfNotFound) {
		const msg = `Failed to find path slug: ${slug} in ${path}`;
		logger.error(chalk.red(msg));
		throw new Error(msg);
	}
	return path;
}

/**
 * Test `value` for suitability as sending as a header value.
 * @param {*} value - The value to test
 * @return {boolean} True if the value is a valid HTTP header.
 */
function isHeaderValueOK(value) {
	return value !== '' && value !== undefined && value !== null;
}

/**
 * Test `value` for suitability as sending as a cookie value.
 * @param {*} value - The value to test
 * @return {boolean} True if the value is a valid HTTP cookie.
 */
function isCookieValueOK(value) {
	return value !== undefined && value !== null;
}

module.exports = formatRequest;
