const formatRequest = require('./formatRequest');
const { request } = require('@axway/requester');

/**
 * Gets an `action` method for the `operation`.
 *
 * @param {OASOperation} operation - The operation object.
 * @param {object} parameterMap - Map with namespaced names and parameters.
 * @param {object} config - Plugin config.  See `OASPlugin.generate`
 *		`options.config`.
 * @return {function} Function related with preparation and execution of http requests.
 */
function getAction(operation, parameterMap, config) {
	/**
	 * Controls the flow related with preparation and execution of http requests
	 * based on OAS operation and parameters information.
	 *
	 * This includes:
	 * 	- formatting the input based on the operation and parameters map
	 * 	- delegating to the http client for doing actual request
	 * 	- invokes the corresponding output with the execution result
	 *
	 * @param {object} params the request data coming from the flow
	 * @param {object} options options passed from the flow manager
	 * @param {object} options.logger logger scoped to the context of the current flow
	 * @param {object} options.authorizations provided authorizations
	 * @returns {*} when done just returns the execution flow to the invoking function
	 */
	return async function action(params, { logger, authorizations, setOutput }) {
		logger.trace('raw flow-node request', { params });

		const requestInfo = formatRequest(
			operation,
			parameterMap,
			params,
			{ config, logger, authorizations }
		);
		const {
			uri,
			method,
			headers,
			body,
			options
		} = requestInfo;

		logger.trace('sending request', requestInfo);

		const response = await request({
			url: uri,
			headers,
			method,
			body
		}, {
			...options,
			logger
		});

		const result = {
			status: response.status,
			headers: response.headers
		};
		logger.trace('receive body', response.body);
		if (response.body) {
			if (response.body instanceof Buffer) {
				if (response.body.length) {
					logger.trace('received raw body');
					result.data = response.body;
				} else {
					logger.trace('received empty body');
				}
			} else {
				logger.trace('received decoded body');
				result.data = response.body;
			}
		}

		const outputKey = calculateOutputKey(response.status, operation.responses, logger);
		logger.trace(`invoking output: ${outputKey}`);
		return setOutput(outputKey, result);
	};
}

/**
 * Calculates the output key for that output that needs to be invoked.
 *
* @param {object} respStatus the response status
* @param {object} responses responses described in the spec for the action
* @param {object} logger logger scoped to the context of the current flow
* @returns {string} returns the output key
*/
function calculateOutputKey(respStatus, responses, logger) {
	const status = `${respStatus}`;
	logger.trace('response status', status);
	const outputKey = responses.find(a => a.statusCode === status);
	if (outputKey === undefined) {
		logger.trace(`flow-node does not have output for: ${status}, using 'default'`);
		return 'default';
	} else {
		return outputKey.statusCode;
	}
}

module.exports = getAction;
