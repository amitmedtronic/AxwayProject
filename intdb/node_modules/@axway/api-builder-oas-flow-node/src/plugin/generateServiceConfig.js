const fs = require('fs');
const path = require('path');
const debug = require('debug');
const createStubCredentials = require('./createStubCredentials');

const log = debug('oas-flow-node');

const template = (oasVersion, id, pluginName, friendlyName, credentials) => {
	let oas2Config = '';
	if (oasVersion === '2') {
		oas2Config = `
				// It is possible to override URI options when constructing
				// outbound requests to this service.
				uri: {
					// protocol: 'https',
					// host: 'hostname',
					// port: 443,
					// basePath: '/api'
				}
			`;
	}

	return `\
module.exports = {
	// The configuration settings for the OAS${oasVersion} flow-node: ${friendlyName}
	pluginConfig: {
		'${pluginName}': {
			'${id}': {${oas2Config}}
		}
	}${!credentials.length ? '' : `,
	// The following authorization credentials needed to use this service.
	// Please follow this guide to manually configure these credentials:
	// https://docs.axway.com/bundle/api-builder/page/docs/developer_guide/credentials/index.html
	authorization: {
		credentials: {
${credentials}
		}
	}`}
};
`;
};

/**
 * Tests whether or not the API Builder application is in developer mode.  The test
 * is to check to see if @axway/api-builder-admin exists.
 *
 * @returns {boolean} True if in developer mode.
 */
function isDeveloperMode() {
	try {
		// If we are in "development mode" we are going to have @axway/api-builder-admin
		// dependency installed. So we guarantee that only generate config files in
		// "development mode" and ensure immutable production environments.
		// eslint-disable-next-line import/no-unresolved
		require('@axway/api-builder-admin');
		return true;
	} catch (ex) {
		log('@axway/api-builder-admin not found (dev mode). skipping config generation', ex);
		return false;
	}
}

/**
 * Generates configuration based on a unique Swagger service name (e.g. filename prefix).
 *
 * @param {string} oasVersion - The OAS version, either '2' or '3'.
 * @param {string} swaggerId - The unique id of the Swagger service flow-node.
 * @param {string} friendlyName - The friendly name of the flow-node.
 * @param {string} pluginName - The plugin name.
 * @param {object} [credentials=null] - A set of stub credentials for the service, e.g.
 *		from `{@link createStubCredentials}`.
 * @returns {string} The Swagger service configuration file.
 */
function generateConfig(oasVersion, swaggerId, friendlyName, pluginName, credentials = null) {
	let credentialsString = '';
	if (credentials) {
		// This isn't pretty, but it is quite challenging to generate configuration.
		// The best approach was to JSON encode each credential,
		// and then munge it to have the correct indentation and quotation.
		Object.keys(credentials).forEach((name, i, arr) => {
			let credential = JSON.stringify(credentials[name], null, '\t');
			credential = credential
				// changes "{" to (indented) "$name: {"
				.replace(/{/, `\t\t\t'${friendlyName} ${name}': {`)
				// changes "key":"value" to (indented) key:"value"
				.replace(/\t+"(.*)":/g, '\t\t\t\t$1:')
				// changes all " quotes to '
				.replace(/"/g, '\'')
				// indents trailing "}"
				.replace(/}/, '\t\t\t}');

			if (i + 1 < arr.length) {
				credential += ',\n';
			}
			credentialsString += credential;
		});
	}
	return template(oasVersion, swaggerId, pluginName, friendlyName, credentialsString);
}

/**
 * Writes a file to disk. If a file already exists at the specified location,
 * the file will be written with .1 .2 etc.. appended to the name.  The `config`
 * should be generated from `{@link generateConfig}`.
 *
 * @param {string} configDir - The config dir where the file will be written.
 * @param {string} name - The main portion of the config file name.
 * @param {string} configData - The configuration data to write.
 * @param {object} logger - The logger which allow you to log from within the swagger plugin.
 */
function writeUniqueConfigFile(configDir, name, configData, logger) {
	const filename = write(name);
	logger.info(`${filename} plugin configuration file has been copied to your API Builder conf directory. You may want to configure this file.`);
	function write(filename, count = 0) {
		const fn = path.join(configDir, `${filename}.default.js`);
		try {
			// statSync will throw when config file does not exist yet
			// In that case we create config file in the catch clause.
			fs.statSync(fn);

			// File already exists. Try with a different name.
			return write(`${name}.${count}`, ++count);
		} catch (err) {
			if (err.code === 'ENOENT') {
				fs.writeFileSync(fn, configData);
				return fn;
			}
			throw err;
		}
	}
}

function getFriendlyPluginName(pkg) {
	// [a-z]{2} filters out common prefixes like -fn- -dc- or custom ones
	// that happen to follow a similar convention to us (like -gm-)
	const match = /(?:@.*\/)?api-builder-plugin-(?:[a-z]{2}-)?(.*)/.exec(pkg);
	const name = match[1];
	return `${name[0]}${name.substring(1)}`;
}

/**
 * Gets or generates the service configuration from `serviceConfig` by the name
 * `swaggerName`. If the configuration object exists in `serviceConfig`, it is
 * returned.  If it does not exist, then when in developer mode, it will
 * generate and save a config file with stub configuration and at the same time
 * will add those stub credentials to the CredentialManager so that the
 * credentials are bootstrapped for the first time.
 *
 * @param {object} options - The options
 * @param {object} options.config - The api builder config object for this
 *		plugin
 * @param {string} options.id - The id of the Swagger service
 * @param {string} options.plugin - The name of the plugin package
 * @param {string} options.oasVersion - The OAS version, either '2' or '3'.
 * @param {string} [options.configPrefix] - Custom prefix for config files
 * @param {object} options.securitySchemes - OAS security schemes object
 * @param {string} options.name - the friendly name of the flow-node
 * @param {object} options.logger - The logger which allow you to log from
 * 		within the swagger plugin.
 */
function generateServiceConfig(options) {
	const {
		id,
		plugin,
		oasVersion,
		securitySchemes,
		name,
		logger,
		configPrefix,
		appDir
	} = options;

	let APIBuilder;
	try {
		APIBuilder = require('@axway/api-builder-runtime');
	} catch (ex) {
		throw new Error('Plugin is not loaded via an existing @axway/api-builder-runtime instance');
	}
	const instance = APIBuilder.getGlobal();
	if (!instance) {
		logger.warn('No API Builder instance found, not generating config (this is expected when testing)');
		return;
	}

	// builds a set of `credentials` from the found in the swagger
	// `method.authorization`
	const stubCredentials = createStubCredentials(securitySchemes, logger);

	// The plugin configuration does not yet exist, but the user is in
	// developer mode, so generate one and include credential stubs.
	const configData = generateConfig(oasVersion, id, name, plugin, stubCredentials);

	// Use provided prefix or generate a new one from the plugin name
	// api-builder-plugin-fn-petstore and will create the prefix
	// "petstore-"
	// eslint-disable-next-line eqeqeq, no-eq-null
	const filename = configPrefix != null
		? `${configPrefix}${id}`
		: `${getFriendlyPluginName(plugin)}-${id}`;

	const configDir = path.join(appDir, 'conf');
	writeUniqueConfigFile(configDir, filename, configData, logger);

	// As discussed 2018-11-19, we will get access to the APIBuilder
	// runtime instance and write all stub credentials to the
	// CredentialManager.  This is so that these new (stubbed) credentials
	// can be bootstrapped and available to the UI the first time.
	// After, they will be read from the generated configuration file only.
	for (const credential in stubCredentials) {
		instance.flowManager.credentialManager.addCredential({
			name: `${name} ${credential}`,
			...stubCredentials[credential]
		});
	}
}

module.exports = {
	generateConfig,
	writeUniqueConfigFile,
	isDeveloperMode,
	generateServiceConfig
};
