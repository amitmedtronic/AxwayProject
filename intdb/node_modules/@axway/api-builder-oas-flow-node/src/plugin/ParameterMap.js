class ParameterMap {
	/**
	 * @param {OASOperation} operation - The operation object.
	 */
	constructor() {
		// Holds disambiguated property name to parameter mapping in
		// non-enumerable private props.
		Object.defineProperty(this, 'map', { value: {} });
		Object.defineProperty(this, 'count', { value: {} });
	}

	/**
	 * Adds the `name` of a parameter to the map and keeps track of the count.
	 * @param {string[]|string} names - The names to add to the map.
	 */
	add(names) {
		let array = names;
		if (typeof names === 'string') {
			array = [ names ];
		}
		for (const name of array) {
			this.count[name] = (this.count[name] || 0) + 1;
		}
	}

	/**
	 * Registers the parameter in the parameter map and returns an appropriate
	 * property name.  If multiple parameters exist with the same name, a
	 * prefix (`location`) will be added to the name.  E.g. if 'foo' was
	 * registered in `location` "path" and "header", then the property name
	 * that is returned would be `path.foo` and `header.foo`.
	 *
	 * @param {string} parameterName Parameter name to disambiguate.
	 * @param {object} [parameter.location] - The location of the parameter.
	 *		must be one of: header|cookie|path|query.
	 * @param {object} [parameter.name] - The name of the parameter.
	 * @param {*} [parameter.defaultValue] - The default value.
	 * @returns {string} - The unique property name.
	 */
	register(parameterName, { location, name, required, defaultValue }) {
		const propertyName = this.count[parameterName] > 1
			? `${location}.${parameterName}` : parameterName;
		this.map[propertyName] = {
			in: location,
			name
		};
		if (defaultValue !== undefined) {
			this.map[propertyName].default = defaultValue;
		}
		if (required !== undefined) {
			this.map[propertyName].required = required;
		}
		return propertyName;
	}

	/**
	 * @returns {Object} - The parameter map.
	 */
	getMap() {
		return this.map;
	}
}

module.exports = ParameterMap;
