const { isSimpleSchema } = require('../utils');
const { convertOASSchemaToDraft06 } = require('../utils/schema');
const getSchemaFromContent = require('./getSchemaFromContent');
const debug = require('debug');
const addParameter = require('./addParameter');

const log = debug('oas-flow-node');

const FORM_CONTENT_TYPES = [
	'application/x-www-form-urlencoded',
	'multipart/form-data'
];

const rawBodyDescription = 'The data to send as a raw body';

/**
 * Adds the `operation` body parameter to the flow-node.
 *
 * @param {SDK} sdk - The current SDK flow-node.
 * @param {OASOperation} operation - The operation object.
 * @param {ParameterMap} parameterMap - The disambiguated parameter names.
 */
function addRequestBodyParameter(sdk, operation, parameterMap) {
	const { requestBody } = operation;
	// Note that the requestBody has properties: description | content | required
	const contentTypes = Object.keys(requestBody.content);

	// First, convert the requestBody into a JSON schema. If it has a oneOf that either means
	// it originally had a oneOf or it's a combination of multiple different schemas per content
	// type. Either way it's not simple when we check it with isSimpleForm
	const bodySchema = getSchemaFromContent(requestBody.content);

	// And then convert to draft06.
	let body = convertOASSchemaToDraft06(bodySchema, { after: preserveBinary });

	// Improve UX and create individual parameters for form-data content-type(s) only, and if it's
	// a very simple schema describing an object
	if (isSimpleForm(bodySchema, contentTypes)) {
		// If the content-type is a kind of HTTP form, and the requestBody is simple (i.e. just
		// properties and not oneOf), then make each property a separate parameter on the method.
		const form = body.properties;
		const required = body.required || [];
		for (const name in form) {
			const prop = form[name];
			parameterMap.add(name);
			addParameter(sdk, {
				in: 'formData',
				name,
				type: prop.type,
				description: prop.description,
				required: required.includes(name),
				schema: prop
			}, parameterMap);
		}
		return;
	}

	// The `requestBody` is more complex. We want to add the anyOf in all other
	// occasions, except when the body.type is a string, or the body is `{}`
	// i.e. an "any".
	if (body.type !== 'string' && Object.keys(body).length) {
		// The OAS3 body parameter can have multiple content-types, so we already have added the
		// anyOf.
		if (body.anyOf) {
			body.anyOf.push({
				type: 'string',
				description: rawBodyDescription,
				format: 'multiline'
			});

			// The body is quite complex and is an `anyOf`, meaning that the requestBody had
			// multiple content-types.
			if (requestBody.description) {
				body.description = requestBody.description;
			}
		} else {
			const { description, title } = body;

			delete body.title;
			delete body.description;

			body = {
				anyOf: [
					body,
					{
						type: 'string',
						description: rawBodyDescription,
						format: 'multiline'
					}
				]
			};
			body.title = title;
			if (description) {
				body.description = description;
			}
		}

		if (!body.description) {
			body.description = 'The request body.  Please refer to the info icon for schema.';
		}
	}

	// At this stage, all of the parameter names have been counted, *except* for body. It is
	// important to now count 'body' and get the correct (and possibly disambiguated) body name for
	// the flow-node. We use body.title for backwards compatibility with nodehandler utils where it
	// used the body parameter name.
	const bodyName = body.title || 'body';
	parameterMap.add(bodyName);

	addParameter(sdk, {
		schema: body,
		name: bodyName,
		in: 'body',
		required: requestBody.required
	}, parameterMap, { convertSchema: false });

	log('body', operation.name, bodyName, body);
}

/**
 * Tests that the body content types are only form-data content types, and that it is a simple
 * property/name form, as opposed to a complex schema, e.g `oneOf`.
 * @param {object} bodySchema - The operation's requestBody schema.
 * @param {string[]} contentTypes - An array of the operation's content-types.
 * @return {boolean} True if the operation is a form.
 */
function isSimpleForm(bodySchema, contentTypes) {
	return contentTypes.every(
		type => FORM_CONTENT_TYPES.includes(type))
		&& isSimpleSchema(bodySchema);
}

function preserveBinary(origSchema, schema) {
	if (origSchema.type === 'string' && origSchema.format === 'binary') {
		// In some cases, file uploads can be `{type:'string',format:'binary'}`.
		// In this case, a conversion to a draft-06 schema to add a parameter
		// would strip the `format` leaving `{ type: 'string' }` and this is not
		// compatible if `Buffer` is used as a value.  To ensure any supported
		// value can be used, if the schema is used for binary content, then the
		// schema should instead be converted to any `{}`.
		delete schema.type;
		delete schema.format;
	}
}

module.exports = addRequestBodyParameter;
