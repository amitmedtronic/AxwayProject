const debug = require('debug');
const JsonRefs = require('json-refs');
const jsonPointer = require('@axway/json-pointer');
const YAML = require('js-yaml');
const SwaggerApi = require('@axway/axsway/lib/types/api');
const { removeCirculars } = require('@axway/axsway/lib/helpers');
const { rewriteReferences } = require('../utils/schema');
const OAS = require('../oas');

const log = debug('oas-flow-node');

function getOASVersion(spec) {
	return spec.swagger ? '2' : '3';
}

/**
 * Loads an OAS spec.  The `spec` can be file, URL, or object.  If the `spec`
 * is a file or URL, it will also fetch any external resources.  If it is an
 * object, then the spec will be taken as-is, and external resources will not
 * be fetched.
 *
 * The returned OAS spec will: have all remotes resolved (if relevant);
 * dereference any $ref that are not schema/components; and will rewrite the
 * remaining $ref that are schema/components to schema:///.
 *
 * @param {string|object} spec - The OAS specification to load.
 * @param {string} scope - The scope used when rewriting schema URI.
 * @return {OAS} The OAS object.
 */
async function loadOAS(spec, scope) {
	log('loading', spec);
	const refOptions = {
		includeInvalid: true,
		filter: (item) => {
			if (item.type === 'relative' || item.type === 'remote') {
				return true;
			}
			// If the $ref is local and starts with a schema definition, then
			// it will be rewritten.
			const filtered = item.type === 'local'
				&& !(item.uri.startsWith('#/definitions/')
					|| item.uri.startsWith('#/components/schemas/'));
			return filtered;
		},
		loaderOptions: {
			processContent: (res, cb) => {
				// Sway has found an external/relative file and has extracted
				// the text and uses `processContent` to parse it.
				let value;
				try {
					value = YAML.safeLoad(res.text);
				} catch (err) {
					return cb(err);
				}
				cb(null, value);
			}
		}
	};

	// Resolve raw definition
	let definition;

	// NOTE: JsonRefs.resolveRefs returns "ResolvedRefsResults". This means that
	// definition.refs contains all the info we need, but the "def" property is
	// *not* an object reference to the original object passed into resolveRefs.

	if (typeof spec === 'string') {
		// If a path, it will resolve relative files too, resolving 'relative',
		// 'remote', but *not* 'local' refs to schemas (see filter above).
		// returns: RetrievedResolvedRefsResults
		// https://github.com/whitlockjc/json-refs/blob/master/docs/API.md#module_json-refs.RetrievedResolvedRefsResults
		definition = await JsonRefs.resolveRefsAt(spec, refOptions);
	} else {
		// If an object, it will resolve, resolving 'relative', 'remote', but
		// *not* any 'local' schemas (see filter above).
		// returns: ResolvedRefsResults
		// https://github.com/whitlockjc/json-refs/blob/master/docs/API.md#module_json-refs.ResolvedRefsResults
		definition = await JsonRefs.resolveRefs(spec, refOptions);
	}

	// Resolve local references and copy all that were found to the
	// `definition.refs` (for validation). A local reference is within the spec,
	// e.g. #/definitions/Banana.
	const local = await JsonRefs.resolveRefs(definition.resolved, {
		...refOptions,
		filter: 'local'
	});
	for (const item in local.refs) {
		definition.refs[item] = local.refs[item];
	}

	removeCirculars(definition.resolved);

	// rewrite all `$ref` as `schema:///{scope}`, checking `definition.refs`
	// for invalid local references.
	const rewrittenSchemas = rewriteSchemaReferences(definition, scope);

	// Delete the target definitions of the `$ref` as they are unused and
	// we want `SwaggerApi` to load without complaint (otherwise it will
	// spit out lots of UNUSED_REFERENCE). Keep the original schemas
	// because they are needed for export later.
	const schemas = deleteUnusedSchema(definition.resolved, rewrittenSchemas);

	// Sway does not really use the raw `definition`; `remotesResolved` is
	// used for iterating and json-pointer resolution; and the `fullyResolved`
	// is used for the object properties.  Ours is all 3 combined.  The
	// `definition.references` are unresolved references and is is what sway
	// uses for further validation.  Because we rewrote _after_ loading and
	// resolving, `definition.references` should be empty under normal
	// circumstances and our schema:/// will not be 'unresolved'.
	const swagger = new SwaggerApi(
		definition.resolved, // definition
		definition.resolved, // remotesResolved
		definition.resolved, // fullyResolved
		definition.refs,
		{}
	);

	const oas = new OAS(swagger);

	// The OAS object currently has no schemas (or unused schema).  However,
	// they are needed for export later, so update OAS with the original.
	oas.components = schemas;

	return oas;
}

/**
 * Rewrites JSON schema references in `definition` to use the schema:///{scope}.
 *
 * @param {object} definition - A definition that was resolved using `JsonRefs`.
 * @param {string} scope - The scope used when rewriting schema URI.
 * @return {object} An object that maps all the JSON schema pointer URI $refs
 * that were rewritten (i.e. a URI to the component), to an array of JSON schema
 * pointer URI that referenced it.
 */
function rewriteSchemaReferences(definition, scope) {
	// Rewrite local schema $refs in definition (with remotes resolved) to
	// schema:///
	const oasVersion = getOASVersion(definition.resolved);
	const schemaRefPrefix = oasVersion === '2'
		? '#/definitions/' : '#/components/schemas/';

	// The `definition` has been dereferenced, and any unresolved $ref are
	// marked as "missing" in `definition.refs`.  However, below, we want to
	// find all the component refs using `JsonRefs.findRefs`, excluding the
	// missing ones, but `JsonRefs.findRefs` doesn't have "missing", so we build
	// up a keyed cache for quick lookup of missing $refs.
	const invalidRefs = {};
	for (const item in definition.refs) {
		const ref = definition.refs[item];
		if (ref.missing) {
			log('missing $ref:', ref.uri);
			invalidRefs[ref.uri] = true;
		}
	}

	// NOTE: JsonRefs.findRefs returns "UnresolvedRefsResults". This means that
	// definition.refs contains all the info we need, but the "def" property *is*
	// an object reference to the original object passed into resolveRefs. This
	// subsequently means that modifying "def" will mutate the object passed to
	// findRefs. This won't be possible with resolveRefs.

	// These references exclude invalid/missing ones, and any that do not start
	// with the `schemaRefPrefix` prefix.
	const references = JsonRefs.findRefs(definition.resolved, {
		filter: (ref) => {
			if (invalidRefs[ref.uri]) {
				return false;
			}
			return ref.uri.startsWith(schemaRefPrefix);
		}
	});
	log('references', references);

	// Rewrites the $ref in the definition.resolved.
	const rewritten = rewriteReferences(references, {
		from: schemaRefPrefix,
		to: `schema:///${scope}`
	});
	return rewritten;
}

/**
 * Deletes unused schema from the `definition` and returns the original schema
 * from OAS 2 `#/definitions` or OAS 3 `#/components/schemas`.  The
 * `rewrittenReferences` is a map of definition name to an array of strings
 * representing the path in `definition` to the name that was rewritten.
 *
 * @param {object} definition - The OAS definition to modify.
 * @param {object} rewrittenReferences - A map of unused definitions.
 * @returns {object} The original schemas from `definition`.
 */
function deleteUnusedSchema(definition, rewrittenReferences) {
	let schemas = {};
	const oasVersion = getOASVersion(definition);
	const components = (oasVersion === '2')
		? definition.definitions
		: definition.components && definition.components.schemas;
	if (components) {
		schemas = { ...components };

		// Delete the definitions that are no longer used
		for (const uri in rewrittenReferences) {
			const defPtr = decodeURI(uri);
			log('deleting (unused)', defPtr);
			jsonPointer.remove(definition, defPtr.substr(1));
		}
	}
	return schemas;
}

module.exports = loadOAS;
