const debug = require('debug');
const regexEscape = require('regex-escape');
const { decodeValue } = require('./decodeValue');
const coerce = require('./coerce');
const match = require('./match');
const { DecodeError } = require('./errors');

const log = debug('api-builder:oas-style:decode');

/**
 * Executes the specified `expr` against the provided parameter `value` to
 * determine if it is valid.
 *
 * @param {string} name - The OAS 3 parameter name.
 * @param {string} value - The value to validate.
 * @param {Object|function} expr - The regex or function to validate the value with.
 * @param {string} style - The style of the parameter this value belongs to.
 *
 * @throws {DecodeError} - When the value does not match the specified style.
 */
function validateValue(name, value, expr, style) {
	// Empty values are deemed valid
	if (expr === undefined || value === '') {
		return;
	}
	if (expr instanceof RegExp) {
		const match = expr.exec(value);
		if (!match) {
			throw new DecodeError(
				`The parameter value "${value}" does not match the expected style "${style}" from the spec.`
			);
		}
	} else {
		try {
			expr(name, value);
		} catch (ex) {
			throw new DecodeError(
				`The parameter value "${value}" does not match the expected style "${style}" from the spec. ${ex.message}.`
			);
		}
	}
}

/**
 * Builds a list of options required to decode the value of the label style.
 *
 * Runs a vary basic regex on top of the value, in our best effort to determine
 * if the value matches the specified style.
 *
 * @param {string} name - The OAS 3 parameter name.
 * @param {string} value - The value to decode.
 * @param {boolean} explode - The explode flag.
 * @param {string} schemaType - The value type based on the schema.
 *
 * @throws {DecodeError} - When the value does not match the specified style.
 * @returns {Object} - The options required to decode the value.
 */
function _matrix(name, value, explode, schemaType) {
	// A regex used to pre-validate the value before trying to decode when possible.
	let regex;
	let options;
	if (schemaType === 'array') {
		if (explode) {
			// e.g. ;color=blue;color=black;color=brown
			const escName = regexEscape(name);
			// eslint-disable-next-line
			regex = new RegExp(`^(?:;(?:${escName}*=?[^;]*))+`);

			options = {
				propertyKeyExp: /^(.+)=/,
				delimiter: ';',
				ignoreFirst: false
			};
		} else {
			// e.g. ;color=blue,black,brown
			const escName = regexEscape(name);
			regex = new RegExp(`^;${escName}=?.*`);

			const keyExp = new RegExp(`;(${escName})(?:=|$)`);
			options = {
				keyExp,
				delimiter: ','
			};
		}
	} else if (schemaType === 'object') {
		if (explode) {
			// e.g. ;R=100;G=200;B=150
			regex = match.matrixExplodeObject;
			options = {
				propertyKeyExp: /^(.+)=/,
				delimiter: ';',
				ignoreFirst: true
			};
		} else {
			// e.g. ;color=R,100,G,200,B,150
			regex = match.matrixObject;
			options = {
				keyExp: /^;(.*?)(?:=|$)/,
				delimiter: ','
			};
		}
	} else {
		// string, number, boolean, etc.
		const escName = regexEscape(name);
		regex = new RegExp(`;${escName}=?.*`);
		const keyExp = new RegExp(`;(${escName})(?:=|$)`);
		options = {
			keyExp
		};
	}

	validateValue(name, value, regex, 'matrix');

	return options;
}

/**
 * Builds a list of options required to decode the value of the label style.
 *
 * Runs a vary basic regex on top of the value, in our best effort to determine
 * if the value matches the specified style.
 *
 * @param {string} name - The OAS 3 parameter name.
 * @param {string} value - The value to decode.
 * @param {boolean} explode - The explode flag.
 * @param {string} schemaType - The value type based on the schema.
 *
 * @throws {DecodeError} - When the value does not match the specified style.
 * @returns {Object} - The options required to decode the value.
 */
function _label(name, value, explode, schemaType) {
	// A regex used to pre-validate the value before trying to decode when possible.
	let regex;
	let options;
	if (schemaType === 'object') {
		if (explode) {
			// e.g. .R=100.G=200.B=150
			regex = /^\.$|^(?:\.[^.]*=[^.]*)/;
			options = {
				delimiter: '.',
				ignoreFirst: true,
				propertyKeyExp: /^(.+)=/
			};
		} else {
			regex = /^\.$|^(?:(?:\.[^.]*){2})+$/;
			options = {
				delimiter: '.',
				ignoreFirst: true
			};
		}
	} else {
		// string, number, boolean, etc. AND Array
		// e.g. . | .blue | .blue.black.brown
		regex = /^\./;
		options = {
			delimiter: '.',
			ignoreFirst: true
		};
	}

	validateValue(name, value, regex, 'label');

	return options;
}

/**
 * Builds a list of options required to decode the value of the label style.
 *
 * Runs a vary basic regex on top of the value, in our best effort to determine
 * if the value matches the specified style.
 *
 * @param {string} name - The OAS 3 parameter name.
 * @param {string} value - The value to decode.
 * @param {boolean} explode - The explode flag.
 * @param {string} schemaType - The value type based on the schema.
 *
 * @throws {DecodeError} - When the value does not match the specified style.
 * @returns {Object} - The options required to decode the value.
 */
function _simple(name, value, explode, schemaType) {
	// A regex used to pre-validate the value before trying to decode when possible.
	let regex;
	let options;

	if (schemaType === 'object') {
		if (explode) {
			// e.g.	R=100,G=200,B=150
			regex = match.simpleExplodeObject;
			options = {
				delimiter: ',',
				propertyKeyExp: /^(.+)=/
			};
		} else {
			// e.g. R,100,G,200,B,150
			regex = match.simpleObject;
			options = {
				delimiter: ','
			};
		}
	} else if (schemaType === 'array') {
		// e.g. blue,black,brown
		regex = /^(.+)/;
		options = {
			delimiter: ','
		};
	}

	validateValue(name, value, regex, 'simple');

	return options;
}

/**
 * Decodes a `value` that was encoded as per the OAS parameter styles, see:
 * https://github.com/OAI/OpenAPI-Specification/blob/main/versions/3.1.0.md#style-values
 * The `value` should be obtained from the appropriate express request parameter
 * values. For example, a path parameter value 'q' should be obtained from
 * `req.path.q`. The `param` properties `name`, `style` and `schema` are
 * required.
 *
 * @param {string|string[]|object} value - The value to decode.
 * @param {object} param - The OAS 3 parameter definition.
 * @param {object} param.name - The OAS 3 parameter name.
 * @param {object} param.style - The OAS 3 parameter style.
 * @param {object} param.schema - The OAS 3 parameter spec.
 * @param {boolean} param.explode - When this is true, parameter values of type array or object
 * generate separate parameters for each value of the array or key-value pair of the map.
 * @param {object} [parameters={}] - An object to store the decoded parameter
 * `value`.
 * @param {object} [flags={}] - Flags to configure decode behavior
 * @returns {object} The supplied `parameters`, updated with the the decoded
 * `value`.
 *
 * @example
 * decode(req.params.q, {in:'path',style:'matrix',schema:{type:'number'}});
 * @example
 * decode(req.query.q, {in:'query',style:'form',schema:{type:'number'}});
 * @example
 * decode(req.headers.q, {in:'header',style:'simple',explode:true,schema:{type:'number'}});
 * @example
 * decode(req.cookies.q, {in:'cookie',style:'form',schema:{type:'number'}});
 */
function decode(value, param, parameters = {}, flags = {}) {
	const {
		name,
		style,
		explode,
		schema
	} = param;
	const { coerceDate } = flags;

	if (!name) {
		throw new Error('Missing required: param.name');
	}
	if (!style) {
		throw new Error('Missing required: param.style');
	}
	if (!schema) {
		throw new Error('Missing required: param.schema');
	}

	if (value === undefined) {
		throw new DecodeError('Invalid parameter value: undefined.');
	}

	const schemaType = schema.type;
	if (schemaType === undefined) {
		// this is "any"
		parameters[param.name] = value;
		return parameters;
	}
	if (Array.isArray(value) && schemaType !== 'array') {
		throw new DecodeError(
			`The parameter value is of type Array. Failed to match the defined parameter type: ${schemaType}.`);
	} else if (typeof value === 'object' && !Array.isArray(value) && schemaType !== 'object') {
		throw new DecodeError(
			`The parameter value is of type Object. Failed to match the defined parameter type: ${schemaType}.`);
	}

	let options = {};
	log('decode:', value, { name, style, explode, type: schemaType });

	if (style === 'matrix') {
		options = _matrix(name, value, explode, schemaType);
	} else if (style === 'label') {
		options = _label(name, value, explode, schemaType);
	} else if (style === 'form') {
		if (schemaType === 'object') {
			if (explode) {
				if (typeof value === 'object') {
					log('converting object:', value);
					parameters[name] = coerce.object(value, schema, { coerceDate });
					return parameters;
				} else {
					if (param.in === 'cookie') {
						throw new Error(
							`The cookie parameter "${name}" uses an unsupported style "form", explode "true".`
						);
					}
					const regex = /^(?:[^=]*=[^=]*&?)+/;
					validateValue(name, value, regex, 'form');
					options = {
						delimiter: '&',
						propertyKeyExp: /^(.+)=/
					};
				}
			} else {
				// e.g. R,100,G,200,B,150
				// Very tricky case, so instead of the usual regex we manually check the number
				// of commas. Only odd number is valid(i.e. key/value pair being completed).
				function validate(value) {
					const count = (value.match(/,/g) || []).length;
					return (count % 2) !== 0;
				}

				if (value !== '' && !validate(value)) {
					throw new Error(
						`The parameter value "${value}" does not match the expected style "form" from the spec.`
					);
				}
				options = {
					delimiter: ','
				};
			}
		} else if (schemaType === 'array') {
			if (explode) {
				if (param.in === 'cookie') {
					throw new Error(
						`The cookie parameter "${name}" uses an unsupported style "form", explode "true".`
					);
				}

				if (Array.isArray(value)) {
					log('converting array:', value);
					parameters[name] = coerce.array(value, schema.items, { coerceDate });
					return parameters;
				} else {
					// expected when form, explode=true, but given one item
					log('input is not exploded array');
				}
			} else {
				// blue | blue, |  blue, black, brown
				options = {
					delimiter: ','
				};
			}
		} else {
			// string, number, boolean, etc.
			options = {};
		}
	} else if (style === 'simple') {
		options = _simple(name, value, explode, schemaType);
	} else if (style === 'spaceDelimited') {
		// e.g. blue%20black%20brown => blue black brown as Array
		if (schemaType === 'object') {
			// e.g. R%20100%20G%20200%20B%20150 => R 100 G 200 B 150 as Object
			validateValue(name, value, match.spaceDelimitedObject, style);
		}
		options = {
			delimiter: ' '
		};
	} else if (style === 'pipeDelimited') {
		// e.g.	blue|black|brown as Array
		if (schemaType === 'object') {
			// e.g. R|100|G|200|B|150 as Object
			validateValue(name, value, match.pipeDelimitedObject, style);
		}
		options = {
			delimiter: '|'
		};
	} else if (style === 'tsv') {
		options = {
			delimiter: '\t'
		};
	} else if (style === 'deepObject') {
		// e.g. color[R]=100&color[G]=200&color[B]=150
		// is automatically decoded by `qs` to: `{ R: '100', G: '200', B: '150' }`
		parameters[name] = coerce.object(value, schema, { coerceDate });
		return parameters;
	} else {
		throw new Error(`Unknown style: ${style}`);
	}

	return decodeValue(value, schema, {
		key: name,
		parameters,
		coerceDate,
		...options
	});
}

module.exports = decode;
