const debug = require('debug');
const log = debug('api-builder:oas-style:coerce');

/**
 * Converts a request parameter from a string value to a JavaScript native
 * value, given the schema for it.
 *
 * @param {string|string[]} value - The string value of the parameter to convert.
 * @param {object} schema - The schema of the parameter to convert.
 * @param {object} [options={}] - Coercion options.
 * @param {boolean} [options.coerceDate=false] - Coerce date and date-time formats to Date object.
 * @returns {integer|string|date|boolean} The converted value, or if unable to
 * coerce, the original value.
 */
function coerceString(value, schema, options = {}) {
	const { coerceDate } = options;
	// NOTE: OAS 3 does not restrict input parameters to having any specific
	// schema, so arguably can support `anyOf` and `oneOf` (but `allOf` is an
	// object so does not apply here). A future enhancement could be made to
	// support these.
	if (!schema || !schema.type || schema.anyOf || schema.oneOf || schema.allOf) {
		log('not coerced:', value, schema);
		return value;
	}

	let toValue;
	if (value === undefined || value === null) {
		toValue = '';
	} else {
		toValue = value;
	}

	log(`coercing "${value}" to`, schema);
	const schemaType = schema.type;
	if (Array.isArray(value) && schemaType !== 'array') {
		log('an array was passed, taking first item', value);
		toValue = value[0];
	}

	// istanbul ignore else
	if (schemaType === 'integer' || schemaType === 'number') {
		// the extended JSON schema formats are technically covered:
		// https://github.com/OAI/OpenAPI-Specification/blob/main/versions/3.1.0.md#data-types
		const parse = (schemaType === 'number')
			? strictParseFloat : strictParseInt;
		const num = parse(toValue, 10);
		if (!Number.isNaN(num)) {
			toValue = num;
		} else if (Array.isArray(value)) {
			// failed to parse, revert to original (first array item)
			toValue = value[0];
		} else {
			// failed to parse, revert to original
			toValue = value;
		}
	} else if (schemaType === 'boolean') {
		if (!toValue || [ '0', 'false', 'F', 'N' ].includes(toValue)) {
			// only change if we match
			toValue = false;
		} else if ([ '1', 'true', 'T', 'Y' ].includes(toValue)) {
			// only change if we match
			toValue = true;
		}
		return toValue;
	} else if (schemaType === 'array') {
		if (value) {
			// questionable if this is necessary, but seems okay for interface
			toValue = [ value ];
		} else {
			// just return an empty array
			toValue = [];
		}
	} else if (schemaType === 'string') {
		if (coerceDate && [ 'date', 'date-time' ].includes(schema.format)) {
			toValue = new Date(toValue);
		}
	}

	if (value !== toValue) {
		log('coerced to:', toValue);
	} else {
		log('coercion not necessary:', toValue);
	}
	return toValue;
}

/**
 * Coerces each item in an `array` of strings to the specified `schema`. If
 * `array` is not an array, an empty array is returned.
 *
 * @param {string[]} array - The array of strings to coerce.
 * @param {object} schema - The schema to coerce each item.
 * @param {object} [options={}] - Coercion options.
 * @param {boolean} [options.coerceDate=false] - Coerce date and date-time formats to Date object.
 * @returns {array[]} The array of coerced items. If an array item cannot be
 * coerced, it's value will remain unchanged.
 */
function coerceArray(array, schema, options = {}) {
	if (!Array.isArray(array)) {
		return [];
	}
	return array.map(item => coerceString(item, schema, options));
}

/**
 * Coerces each property value in an `object` to the specified `schema`. If
 * `object` is not an object, an empty object is returned.
 *
 * @param {object} object - The object to coerce.
 * @param {object} schema - The schema to coerce each item.
 * @param {object} [options={}] - Coercion options.
 * @param {boolean} [options.coerceDate=false] - Coerce date and date-time formats to Date object.
 * @returns {object} A new object of coerced property values. If a property
 * value cannot be coerced, its value will remain unchanged.
 */
function coerceObject(object, schema, options = {}) {
	if (typeof object !== 'object') {
		return {};
	}

	// NOTE: OAS 3 does not restrict input parameters to having any specific
	// schema, so arguably can support `anyOf`, `oneOf`, and `allOf`. A future
	// enhancement could be made to support these.

	const coerced = {};
	for (const prop in object) {
		log('decoding object property:', prop);
		const propSchema = schema.properties && schema.properties[prop];
		coerced[prop] = coerceString(object[prop], propSchema, options);
	}
	return coerced;
}

/**
 * A stricter `parseInt` that is less forgiving.
 * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/parseInt#a_stricter_parse_function
 * @example
 * strictParseInt('421') => 421
 * @example
 * strictParseInt('-421') => -421
 * @example
 * strictParseInt('-42.1') => NaN
 * @example
 * strictParseInt('421banana') => NaN
 * @param {string} value - The value to parse.
 * @returns {integer|NaN} The parsed integer.
 */
function strictParseInt(value) {
	if (/^[-+]?(\d+|Infinity)$/.test(value)) {
		return Number(value);
	} else {
		return NaN;
	}
}

/**
 * A stricter `parseFloat` that is less forgiving.
 * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/Number
 * @example
 * strictParseFloat('3.14') => 3.14
 * @example
 * strictParseFloat('-3.14') => -3.14
 * @example
 * strictParseInt('') => NaN
 * @example
 * strictParseInt('3.14banana') => NaN
 * @param {string} value - The value to parse.
 * @returns {number|NaN} The parsed number.
 */
function strictParseFloat(value) {
	if (value === '') {
		return NaN;
	}
	return Number(value);
}

module.exports = {
	string: coerceString,
	array: coerceArray,
	object: coerceObject
};
