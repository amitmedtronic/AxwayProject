/**
 * Parses a `value` encoded as matrix explode:true, e.g.:
 * `;R=100;G=200;B=150`
 * @param {string} name - The parameter name.
 * @param {string} value - The value to parse.
 * @throws {Error} if encoding is not as expected
 */
function matrixExplodeObject(name, value) {
	let index = 0;
	let at = 0;
	let char;

	function consumeUntil(wanted) {
		for (; index < value.length; ++index) {
			char = value[index];
			if (char === wanted) {
				++index;
				break;
			}
		}
		return char;
	}

	while (index < value.length) {
		let char = value[index];
		if (char !== ';') {
			throw new Error(`Invalid encoding at position ${index}, expected ";"`);
		}
		++index; // consume `;`
		if (index >= value.length) {
			throw new Error(`Invalid encoding at position ${index}, expected property name`);
		}
		// consume property name
		at = index;
		char = consumeUntil('=');
		if (char !== '=') {
			throw new Error(`Invalid encoding at position ${at}, expected "="`);
		}
		if (index >= value.length) {
			// valid, no property value
			break;
		}
		// consume property value
		char = consumeUntil(';');
		if (index === value.length) {
			if (char === ';') {
				throw new Error(`Invalid encoding at position ${index - 1}, did not expect trailing ";"`);
			}
			break;
		} else {
			// encountered a `;`, roll it back and continue
			--index;
		}
	}
}

/**
 * Parses a `value` encoded as matrix explode:false, e.g.:
 * `;color=R,100,G,200,B,150`
 * @param {string} name - The parameter name.
 * @param {string} value - The value to parse.
 * @throws {Error} if encoding is not as expected
 */
function matrixObject(name, value) {
	let index = 0;
	let char = value[index];
	if (char !== ';') {
		throw new Error(`Invalid encoding at position ${index}, expected ";"`);
	}
	index++; // consume `;`
	if (name !== value.substr(index, name.length)) {
		throw new Error(`Invalid encoding at position ${index}, expected "${name}"`);
	}
	index += name.length; // consume key
	char = value[index];
	if (char !== '=' && index >= value.length) {
		// empty object
		return;
	}
	index += 1; // consume =
	// count all the commas, and if even, then invalid
	let commaCount = 0;
	for (; index < value.length; ++index) {
		char = value[index];
		if (char === ',') {
			++commaCount;
		}
	}
	if ((commaCount % 2) === 0) {
		throw new Error(`Invalid encoding at position ${index - 1}, expected "key,value"`);
	}
}

/**
 * Parses a `value` encoded as simple explode:true, e.g.:
 * `R=100,G=200,B=150`
 * @param {string} name - The parameter name.
 * @param {string} value - The value to parse.
 * @throws {Error} if encoding is not as expected
 */
function simpleExplodeObject(name, value) {
	let index = 0;
	let char;

	function consumeUntil(wanted) {
		for (; index < value.length; ++index) {
			char = value[index];
			if (char === wanted) {
				++index;
				break;
			}
		}
		return char;
	}

	while (index < value.length) {
		char = consumeUntil('=');
		if (char !== '=') {
			throw new Error(`Invalid encoding at position ${index}, expected "="`);
		}
		char = consumeUntil(',');
		if (index === value.length) {
			if (char === ',') {
				throw new Error(`Invalid encoding at position ${index - 1}, did not expect trailing ","`);
			}
			break;
		} else {
			// encountered a `;`, roll it back and continue
			--index;
		}
	}
}

/**
 * Parses a `value` encoded as simple explode:false, e.g.:
 * `R,100,G,200,B,150`
 * @param {string} name - The parameter name.
 * @param {string} value - The value to parse.
 * @throws {Error} if encoding is not as expected
 */
function simpleObject(name, value) {
	// use a trick - if the number of commas is even, then it's invalid
	const count = (value.match(/,/g) || []).length;
	if ((count % 2) === 0) {
		throw new Error('Invalid encoding, expected "key,value"');
	}
}

/**
 * Parses a `value` encoded as spaceDelimited, e.g.:
 * `R 100 G 200 B 150`
 * @param {string} name - The parameter name.
 * @param {string} value - The value to parse.
 * @throws {Error} if encoding is not as expected
 */
function spaceDelimitedObject(name, value) {
	// use a trick - if the number of commas is even, then it's invalid
	const count = (value.match(/ /g) || []).length;
	if ((count % 2) === 0) {
		throw new Error('Invalid encoding, expected "key value"');
	}
}

/**
 * Parses a `value` encoded as pipeDelimited, e.g.:
 * `R 100 G 200 B 150`
 * @param {string} name - The parameter name.
 * @param {string} value - The value to parse.
 * @throws {Error} if encoding is not as expected
 */
function pipeDelimitedObject(name, value) {
	// use a trick - if the number of commas is even, then it's invalid
	const count = (value.match(/\|/g) || []).length;
	if ((count % 2) === 0) {
		throw new Error('Invalid encoding, expected "key|value"');
	}
}

module.exports = {
	matrixExplodeObject,
	matrixObject,
	simpleExplodeObject,
	simpleObject,
	spaceDelimitedObject,
	pipeDelimitedObject
};
