const debug = require('debug');
const strictUriEncode = require('strict-uri-encode');

const log = debug('api-builder:oas-style:encode');

const QUERY_STYLES = [
	'form',
	'spaceDelimited',
	'pipeDelimited',
	'deepObject',
	'tsv'
];

const HEADER_STYLES = [
	'simple'
];

/**
 * HTTP headers allow all printable ASCII characters.  Everything else should
 * be percent encoded.
 * @param {string} value - The value to encode.
 * @returns {string} A HTTP header value correctly encoded.
 */
function headerEncoding(value) {
	return `${value}`.replace(/[^\x20-\x7E]+/g,
		(char) => `%${char.charCodeAt(0).toString(16).padStart(2, '0').toUpperCase()}`);
}

/**
 * Encodes a parameter with a given `paramName` and `value` using
 * [style](https://github.com/OAI/OpenAPI-Specification/blob/main/versions/3.0.0.md#style-values)
 * encodings as defined in the OAS 3.x spec.
 *
 * @param {string} paramName - The parameter name.
 * @param {string|integer|number|boolean|array|object} value - The parameter
 * value.
 * @param {object} options - OAS 3 encoding options.
 * @param {string} options.style - The style, one of: matrix|label|form|simple|
 * spaceDelimited|pipeDelimited|deepObject|tsv.
 * @param {boolean} options.explode - The explode option.
 * @param {boolean} options.allowReserved - The allowReserved option, allowing
 * the RFC-3986 set of reserved characters. This is only valid with styles:
 * form, spaceDelimited, pipeDelimited, tsv, and deepObject.
 * @param {boolean} options.printableOnly - Only allows printable characters,
 * and is used for style: simple for header encoding.
 * @returns {string} The encoded parameter.
 */
function encode(paramName, value, options) {
	const { style, explode, allowReserved, printableOnly } = options;
	log('encode', { paramName, ...options, value });
	const isArray = Array.isArray(value);
	const isEmpty = value === undefined || value === null;
	const isDate = value instanceof Date;
	const isObject = typeof value === 'object';

	// convert empty, primitives, and dates to an array before processing.
	if (isEmpty) {
		log('value is empty');
		// make it an empty array
		value = [];
	} else if (!isArray && !isObject) {
		log('value is a primitive');
		// primitive, and make whatever it is an array
		value = [ value ];
	} else if (isDate) {
		log('value is a date');
		// coerce to string
		value = [ value.toISOString() ];
	}
	// else, it is either already an array, or is an object

	// allowReserved only applies to query parameters.
	let encoding;
	if (QUERY_STYLES.includes(style) && allowReserved) {
		log('using encoding: encodeURIComponent');
		encoding = encodeURIComponent;
	} else if (HEADER_STYLES.includes(style) && printableOnly) {
		log('using encoding: headerEncoding');
		encoding = headerEncoding;
	} else {
		log('using encoding: strictUriEncode');
		encoding = strictUriEncode;
	}

	// assumption is that both keys and values need to be encoded.
	const name = encoding(paramName);

	// `value` may be a *new* Array (constructed above), or may be an object.
	if (Array.isArray(value)) {
		if (style === 'matrix') {
			// Path-style parameter expansion:
			// https://datatracker.ietf.org/doc/html/rfc6570#section-3.2.7
			// Allowable characters are those in the "unreserved" set
			if (!value.length) {
				return `;${name}`;
			} else if (!explode) {
				return `;${name}=${value.map(encoding).join(',')}`;
			} else {
				const vals = value.map(a => `${name}=${encoding(a)}`).join(';');
				return `;${vals}`;
			}
		} else if (style === 'label') {
			// Label-style parameter expansion:
			// https://datatracker.ietf.org/doc/html/rfc6570#section-3.2.5
			// Allowable characters are those in the "unreserved" set
			// The "." is in the unreserved set, so is not escaped
			return `.${value.map(encoding).join('.')}`;
		} else if (style === 'form') {
			// Form-style parameter expansion:
			// https://datatracker.ietf.org/doc/html/rfc6570#section-3.2.8
			// Allowable characters are those in the "unreserved" set
			if (!value.length) {
				return `${name}=`;
			} else if (!explode) {
				const values = value.map(encoding).join(',');
				return `${name}=${values}`;
			} else {
				return value.map(a => `${name}=${encoding(a)}`).join('&');
			}
		} else if (style === 'simple') {
			// Simple-style parameter expansion:
			// Allowable characters are those in the "unreserved" set
			// Note that simple is used for path and header types, but as a
			// header, this is more restrictive than it needs to be. ASCII
			// characters are the unreserved set for headers. It means that a
			// ISO 8601 date time will percent encode the ':' character.
			if (!value.length) {
				return '';
			}
			return value.map(encoding).join(',');
		} else if (style === 'spaceDelimited') {
			// OAS 3 does not define an encoding for spaceDelimited:
			// https://github.com/OAI/OpenAPI-Specification/blob/main/versions/3.0.0.md#style-values
			// It gives an example where spaces are percent-encoded, suggesting
			// they are (at least) using the "unreserved" set. Given the close
			// relationship with simple (csv), assuming the same set as 'simple'
			//
			// Also, it seems strange that spaceDelimited is n/a for a primitive
			// value in the OAS 3 example. Seems it should just be the value.
			if (!value.length || !isArray) {
				return '';
			}
			return value.map(encoding).join('%20');
		} else if (style === 'pipeDelimited') {
			// seems strange that pipeDelimited is n/a for a primitive value
			// assuming same set as 'simple'
			if (!value.length || !isArray) {
				return '';
			}
			return value.map(encoding).join('|');
		} else if (style === 'tsv') {
			// no analog for tsv in OAS 3
			// assuming same set as 'simple'
			if (!value.length) {
				return '';
			}
			return value.map(encoding).join('\t');
		}
		// deepObject, etc., n/a
		return '';
	} else {
		log('encoding object');
		if (style === 'matrix') {
			const values = [];
			const sep = explode ? '=' : ',';
			for (const key in value) {
				values.push(`${encoding(key)}${sep}${encoding(value[key])}`);
			}
			if (!values.length) {
				return `;${name}`;
			}
			// values are already encoded, just join them
			if (!explode) {
				return `;${name}=${values.join(',')}`;
			} else {
				return `;${values.join(';')}`;
			}
		} else if (style === 'label') {
			const values = [];
			const sep = explode ? '=' : '.';
			for (const key in value) {
				values.push(`${encoding(key)}${sep}${encoding(value[key])}`);
			}
			// handles empty object as "."
			return `.${values.join('.')}`;
		} else if (style === 'form') {
			const values = [];
			const sep = explode ? '=' : ',';
			for (const key in value) {
				values.push(`${encoding(key)}${sep}${encoding(value[key])}`);
			}
			if (!values.length) {
				return `${name}=`;
			}
			// values are already encoded, just join them
			if (!explode) {
				return `${name}=${values.join(',')}`;
			} else {
				return `${values.join('&')}`;
			}
		} else if (style === 'simple') {
			const values = [];
			const sep = explode ? '=' : ',';
			for (const key in value) {
				values.push(`${encoding(key)}${sep}${encoding(value[key])}`);
			}
			// handles n/a for empty object as empty string
			return `${values.join(',')}`;
		} else if (style === 'spaceDelimited') {
			const values = [];
			for (const key in value) {
				values.push(`${encoding(key)}%20${encoding(value[key])}`);
			}
			// handles n/a for empty object as empty string
			return `${values.join('%20')}`;
		} else if (style === 'pipeDelimited') {
			const values = [];
			for (const key in value) {
				values.push(`${encoding(key)}|${encoding(value[key])}`);
			}
			// handles n/a for empty object as empty string
			return `${values.join('|')}`;
		} else if (style === 'deepObject') {
			const values = [];
			for (const key in value) {
				values.push(`${encoding(name)}[${encoding(key)}]=${encoding(value[key])}`);
			}
			// handles n/a for empty object as empty string
			return `${values.join('&')}`;
		} else if (style === 'tsv') {
			const values = [];
			for (const key in value) {
				values.push(`${encoding(key)}%09${encoding(value[key])}`);
			}
			// handles n/a for empty object as empty string
			return `${values.join('%09')}`;
		}
		return '';
	}
}

module.exports = encode;
