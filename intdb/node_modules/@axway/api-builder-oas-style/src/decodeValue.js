const debug = require('debug');
const coerce = require('./coerce');

const log = debug('api-builder:oas-style:decodeValue');

/**
 * Decodes a `value` that is encoded into one of the possible "style" as defined
 * in OAS 3, see:
 * https://github.com/OAI/OpenAPI-Specification/blob/main/versions/3.1.0.md#style-examples
 *
 * @param {string} value - The value to decode
 * @param {object} schema - The JSON schema that defines the encoded value.
 * @param {object} options - Decode options.
 * @param {string} [options.delimiter] - Indicates that `value` is an array that
 * is delimited by the supplied character.
 * @param {boolean} [options.ignoreFirst=false] - If using `delimiter`, then this will
 * ignore the first item in the list of delimited items (e.g. if it leads with a
 * delimiter).
 * @param {string} [options.key] - Indicates that the value should be written into
 * `properties` with this key. Mutually exclusive with `options.keyExp`.
 * @param {RegExp} [options.keyExp] - Indicates that the key is encoded into the
 * `value` and this Regular Expression is used to extract it. Mutually exclusive
 * with `key`.
 * @param {RegExp} [options.propertyKeyExp] - Indicates that the key is a
 * property, and its value can be obtained from the regex group.
 * in the expression match is a primary key.
 * @param {object} [options.parameters={}] - The parameters used to store the
 * result.  If not supplied, a new object will be returned.
 * @returns {object} The supplied `parameters`, updated with the the decoded
 * `value`.
 */
function decodeValue(value, schema, options) {
	const {
		keyExp,
		delimiter,
		ignoreFirst,
		propertyKeyExp,
		parameters,
		coerceDate
	} = options;
	let key = options.key;
	let unparsed = value;

	if (Array.isArray(value)) {
		log('an array was passed, taking first item', value);
		unparsed = value[0];
	}

	if (keyExp) {
		log('key expression:', { keyExp });
		const match = keyExp.exec(unparsed);
		/* istanbul ignore else */
		if (match) {
			key = match[1];
			log('consuming key:', key, match);
			unparsed = unparsed.substr(match[0].length);
			log('after key consumed:', unparsed);
		}
	}

	log('parsing', { key, unparsed });

	if (!delimiter) {
		// no delimiter used, so value remains unparsed
		parameters[key] = coerce.string(unparsed, schema, { coerceDate });
		return parameters;
	}

	// value needs to be tokenized
	log('delimiter:', delimiter);

	let parts;
	if (unparsed.length && unparsed !== delimiter) {
		parts = unparsed.split(delimiter);
	} else {
		// an input "." and delimiter "." will cause parts: ["", ""]
		unparsed = '';
		parts = [];
	}

	if (ignoreFirst) {
		log('ignoring first part');
		// remove the leading item
		parts.shift();
	}
	log('parts:', parts);
	const schemaType = schema.type;
	if (schemaType === 'array') {
		const itemSchema = schema.items || { type: 'string' };
		if (propertyKeyExp) {
			// This is decoding each part as: key=value, and returning all the
			// values as an array. The "key" that is matched is _not_ checked
			// against the `key`. It is not valid to have mixed keys.
			log('key exp consume', key);
			parameters[key] = parts.reduce((acc, cur) => {
				const match = propertyKeyExp.exec(cur);
				log('key exp consume match:', match);
				if (match) {
					const parsedValue = cur.substr(match[0].length);
					acc.push(coerce.string(parsedValue, itemSchema, { coerceDate }));
				} else {
					log('failed to match property key expression', {
						exp: propertyKeyExp,
						value: cur
					});
				}
				return acc;
			}, []);
		} else {
			log('applying coercion on items array');
			parameters[key]
				= parts.map(v => coerce.string(v, itemSchema, { coerceDate }));
		}
	} else if (schemaType === 'object') {
		log('parsing object');
		parameters[key] = {};
		for (let i = 0; i < parts.length; ++i) {
			if (propertyKeyExp) {
				log('decoding properties from:', parts[i]);
				const match = propertyKeyExp.exec(parts[i]);
				if (match) {
					const propKey = match[1];
					const propValue = parts[i].substr(match[0].length);
					const propSchema = schema.properties
						&& schema.properties[propKey];
					log('property schema:', propSchema);
					parameters[key][propKey]
						= coerce.string(propValue, propSchema, { coerceDate });
				} else {
					// The main purpose is to decode an object, so if we cannot
					// acquire property key, then ignore the value
					log('failed to match property key expression', {
						exp: propertyKeyExp,
						value: parts[i]
					});
					break;
				}
			} else {
				const propKey = parts[i];
				const propValue = parts[++i];
				const propSchema = schema.properties
					&& schema.properties[propKey];
				log('property schema:', propSchema);
				parameters[key][propKey]
					= coerce.string(propValue, propSchema, { coerceDate });
			}
		}
	} else if (parts.length) {
		// primitive
		parameters[key] = coerce.string(parts[0], schema, { coerceDate });
	} else {
		parameters[key] = coerce.string(unparsed, schema, { coerceDate });
	}

	return parameters;
}

module.exports = {
	decodeValue
};
