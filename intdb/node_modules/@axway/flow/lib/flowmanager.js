const fs = require('fs');
const path = require('path');
const events = require('events');
const chalk = require('chalk');
const parseJson = require('parse-json');
const schemas = require('axway-schema');
const { promisify } = require('util');
const detectIndent = require('detect-indent');
const detectNewline = require('detect-newline');
const deepEqual = require('deep-equal');
const readFileAsync = promisify(fs.readFile);
const writeFileAsync = promisify(fs.writeFile);
const consoleLogger = require('./logger');
const Flow = require('./flow');
const UpgradeManager = require('./upgrademanager');
const noderegistry = require('./noderegistry');

const CRLF = '\r\n';
const newlineRegExp = /\n/g;

/**
 * Formats a node handler URI.  URI are lower-case.  The `module` must be alpha-numeric, including
 * dash, dot, underscore and forward slash.
 * @private
 * @param {string} module - A module name for scope, e.g. "twilio".
 * @param {string} type - A simple URL safe type name, e.g. "echo".
 * @returns {string} node handler URI
 */
function formatNodeHandlerUri(module, type) {
	if (!module) {
		throw new Error('Invalid argument: module');
	}
	if (!type) {
		throw new Error('Invalid argument: type');
	}
	return `nodehandler://${module}/${type}`;
}

/**
 * The Flow manager.
 * @public
 * @class
 */
class FlowManager extends events.EventEmitter {
	/**
	 * Create a server.
	 * @constructor
	 * @param {object} logger - The internal logger to use.
	 * @param {object} credentialManager - The credential manager to use
	 */
	constructor(logger, credentialManager) {
		super();
		this.cache = {};
		this.setLogger(logger);
		this.setCredentialManager(credentialManager);
		const upgradeDir = path.join(__dirname, 'upgrades');
		if (fs.existsSync(upgradeDir)) {
			this.upgrades = require(upgradeDir);
		} else {
			this.upgrades = {};
		}

		// TODO: [RDPP-1687] Handle flow versioning/schema validation better
		this.upgrademanager = new UpgradeManager(this.logger);
		// Register 'flow' as an upgrade type and all it's accessors
		this.upgrademanager.registerUpgradeType('flow', {
			getVersion: (flow) => {
				return flow.schemaVersion;
			},
			setVersion: (flow, newVersion) => {
				flow.schemaVersion = newVersion;
				return flow;
			}
		}, this.validate);
		this.upgrademanager.registerUpgrades(this.upgrades);
	}

	/**
	 * Sets the logger.  Set to `null` to use the default logger.
	 * @public
	 * @param {object} logger - The internal logger to use.
	 */
	setLogger(logger) {
		this.logger = logger || consoleLogger;
	}

	/**
	 * Sets the credential manager
	 * @param {object} credentialManager - The credential manager to use
	 */
	setCredentialManager(credentialManager) {
		if (credentialManager) {
			this.credentialManager = credentialManager;
		}
	}

	/**
	 * Formats a node handler URI.  URI are lower-case.
	 * @public
	 * @param {string} module - A module name for scope, e.g. "twilio".
	 * @param {string} type - A simple URL safe type name, e.g. "echo".
	 * @returns {string} formatted node handler URI
	 */
	formatNodeHandlerUri(module, type) {
		return formatNodeHandlerUri(module, type);
	}

	/**
	 * Registers upgrades for the flow
	 * @param {array} upgrades - array of upgrades to register with the flow upgrade manager
	 */
	registerUpgrades(upgrades) {
		this.upgrademanager.registerUpgrades(upgrades);
	}

	/**
	 * Unregisters upgrades which have been previously registered for the flow
	 * @param {array} upgrades - array of upgrades to unregister from the flow upgrade manager
	 */
	unregisterUpgrades(upgrades) {
		this.upgrademanager.unregisterUpgrades(upgrades);
	}

	/**
	 * Register a node handler.
	 * @public
	 * @param {string} uri - The unique uri of the node the handler to unregister
	 *		(see `formatNodeHandlerUri`).
	 * @param {FlowNode} handler - The handler implementation.
	 * @param {function} getHandlerSpec - A function to return the node handler definition.
	 */
	registerNode(uri, handler, getHandlerSpec) {
		this.logger.debug(`Registering flow-node: ${uri}`);

		// Validate the schema for the node handler.  The handler should have all its
		// dependencies met before registration (e.g. code blocks registered).
		const spec = getHandlerSpec && getHandlerSpec();
		if (spec) {
			this.logger.debug(`Validating spec for: ${uri}`);
			const error = schemas.validate('http://axway.com/schemas/flownode.json', spec);
			if (error) {
				throw new Error(`Unable to register flow-node: '${uri}'. ${error}`);
			}
		}
		noderegistry.registerNode(uri, handler, spec);
	}

	/**
	 * Unregister a node handler.
	 * @public
	 * @param {string} uri - The unique uri of the node the handler to unregister
	 *		(see `formatNodeHandlerUri`).
	 */
	unregisterNode(uri) {
		this.logger.debug(`Unregistering flow-node: ${uri}`);
		noderegistry.unregisterNode(uri);
	}

	/**
	 * Gets a registered node handler.
	 * @public
	 * @param {string} type - The type of the node the handler to get.
	 * @return {FlowNode} The node handler.
	 */
	getRegisteredNode(type) {
		return noderegistry.getRegisteredNode(type);
	}

	/**
	 * Gets the node handler spec for a registered node.
	 * @public
	 * @param {string} type - The type of the node the handler specification to get.
	 * @return {object} The node handler spec.
	 */
	getRegisteredNodeSpec(type) {
		return noderegistry.getNodeSpec(type);
	}

	/**
	 * Gets all of the available node handler specs.
	 * @public
	 * @returns {object|array} The node handler specs.
	 */
	getRegisteredNodeSpecs() {
		return noderegistry.getNodeSpecs();
	}

	/**
	 * Return a map of the flow definitions by id.
	 * @public
	 * @returns {Object} A map of flow definitions by id.
	 */
	getFlows() {
		return Object.keys(this.cache).reduce(
			(prev, cur) => {
				prev[cur] = this.cache[cur].flow;
				return prev;
			},
			{}
		);
	}

	/**
	 * Return the flow definition.
	 * @public
	 * @param {string} flowId - The flow to execute.
	 * @returns {Object} The flow definition.
	 */
	getFlow(flowId) {
		return this.cache && this.cache[flowId] && this.cache[flowId].flow;
	}

	/**
	 * Exceute the flow.
	 * @public
	 * @param {string} flowId - The flow to execute.
	 * @param {object} data - The data to execute the flow with.
	 * @param {object} [options] - options - The flow runtime options.
	 * @param {object} [options.logger] - The logger to use for the flow execution.
	 *		Uses the constructor default if not supplied.
	 * @param {boolean} [options.validateFlowParameter=true] - Validates `data` against flow input
	 *		parameter.
	 * @returns {Promise} A promise that will be resolved with the final context when the
	 *		flow execution completes.
	 */
	flow(flowId, data, options = {}) {
		const logger = (options && options.logger) || this.logger;
		if (!this.cache || !this.cache[flowId]) {
			logger.error(`Flow not found: ${flowId}`);
			throw Error(`Flow not found: ${flowId}`);
		}
		this.emit('preflow', flowId, data);
		logger.debug(chalk.dim(`Invoking: ${flowId}`));

		const promise = this.cache[flowId].invoke(data, options);
		this.emit('postflow', flowId, data, promise);
		return promise;
	}

	/**
	 * Load the flow.
	 * @public
	 * @param {string} flowPath - The path to the flow json definition.
	 * @param {object} [options] - options to apply when loading a flow
	 * @param {boolean} [options.saveUpdates] - Saves the changes to a flow back to disk after
	 *		loading
	 * @returns {Promise} A promise that when resolved contains the loaded flow.
	 */
	async load(flowPath, options = {}) {
		const data = await readFileAsync(flowPath, { encoding: 'utf8' });
		const id = path.basename(flowPath, path.extname(flowPath));
		let flow;
		try {
			// parse-json gives friendlier errors than JSON.parse
			const flowDefinition = parseJson(data, flowPath);
			flow = await this.createFlow(id, flowDefinition);
		} catch (e) {
			this.logger.error(e);
			throw new Error(`Unable to load flow ${id}. Syntax error in flow: ${flowPath}: ${e.message}`);
		}

		// cache the flow for reference later
		this._cacheFlow(flow, data);

		if (flow.wasUpgraded && options.saveUpdates) {
			try {
				// trim x-validation from a copy of the flow. Ideally it should be seperate
				// from the definition in the first place.
				const clonedFlow = JSON.parse(JSON.stringify(flow.flow));
				delete clonedFlow['x-validation'];
				await this.saveFlow(id, flowPath, clonedFlow);
			} catch (e) {
				this.logger.error(e);
				throw new Error(`Unable to write Flow ${id} updates to ${flowPath}`);
			}
		}

		const validation = flow.getValidation();
		if (validation.valid) {
			this.emit('loaded', flow);
		} else {
			this.logger.error(`Invalid Flow ${id}: ${JSON.stringify(validation, null, 2)}`);
			this.emit('invalidflow', flow);
		}
		return flow;
	}

	/**
	 * Saves a flow to disk preserving original formatting
	 * @param {string} id flow id
	 * @param {string} flowPath the path to write to
	 * @param {object} flow updated flow definition
	 * @returns {Promise} promise which resolves when file is written
	 */
	async saveFlow(id, flowPath, flow) {
		// See if the flow has already been cached with original data read from disk.
		const cache = this.cache[id];
		let newFlow;

		if (!cache) {
			// writing out a new flow with LF/tabs
			this.logger.trace(`Saving new flow (${id}) to ${flowPath}`);
			newFlow = JSON.stringify(flow, null, '\t');
		} else if (!deepEqual(cache.flow, flow, { strict: true })) {
			// updating a flow with existing formatting
			const { indent, newline } = cache.formatting;
			newFlow = JSON.stringify(flow, null, indent);
			if (newline === CRLF) {
				newFlow = newFlow.replace(newlineRegExp, CRLF);
			}
			this.logger.trace(`Saving flow (${id}) to ${flowPath}`);
		} else {
			// New flow is the same as old flow
			this.logger.trace(`Not modifying flow (${id})`);
			return;
		}

		return writeFileAsync(flowPath, newFlow);
	}

	/**
	 * Caches the flow in memory
	 * @param {object} flow - instance of the Flow class
	 * @param {string} originalData - the raw flow JSON file
	 */
	_cacheFlow(flow, originalData) {
		this.cache[flow.id] = flow;
		flow.formatting = {
			indent: detectIndent(originalData).indent,
			newline: detectNewline(originalData)
		};
	}

	/**
	 * Function to handle the basic creation, upgrade and validation of a flow
	 * without caching it in the manager
	 * @param {string} id id of the flow to create
	 * @param {object} flow flow definition. This will be modified if the flow is upgraded
	 * @returns {Flow} new Flow instance
	 */
	async createFlow(id, flow) {
		// validate the flow
		await this.validate(flow);
		// Flow is validated. Upgrade it if needed.
		const version = flow.schemaVersion;
		const upgradedFlow = await this.upgrademanager.upgradeFlow(flow, id);
		// check if the flow version changed.
		const wasUpgraded = version !== flow.schemaVersion;
		// Apply updated metdatata from the current flow-nodes
		this.applyMetadata(upgradedFlow);
		// init the flow and return it
		return new Flow(id, upgradedFlow, {
			wasUpgraded,
			logger: this.logger,
			credentialManager: this.credentialManager
		});
	}

	/**
	 * Runs schema validation on a flow definition
	 *
	 * @param {object} flowDef - The flow definition to validate
	 * @param {object} opts - validation options
	 * @returns {Promise} Will reject with validation errors if any are found
	 */
	validate(flowDef, opts = { graph: false, schema: true }) {
		// Validate
		return new Promise((resolve, reject) => {
			if (opts.graph) {
				const flow = new Flow(null, flowDef, {
					logger: this.logger,
					credentialManager: this.credentialManager
				});
				const graphValidation = flow.getValidation();
				if (!graphValidation.valid) {
					return reject(graphValidation);
				}
			}

			if (opts.schema) {
				let validation = schemas.validate('http://axway.com/schemas/flow.json', flowDef);
				if (validation) {
					// parse the validation error
					validation = this._parseValidation(validation);
					return reject(validation);
				}
			}

			return resolve();
		});
	}

	/**
	 * Apply additional metadata to each of the flow nodes in a given flow.
	 *
	 * For each node, the metadata includes:
	 *
	 *  - metaMethod - String - The name of the currently selected method for the given node.
	 *  - meta information on the node's parameters:
	 * 		Each parameter has these additional meta atrributes attached to it based on the spec:
	 * 			* metaName - String - The parameter's name.
	 * 			* metaDescription - String - The parameter's description.
	 *  - meta information on the node's outputs:
	 *  	metaName - String - For each of the outputs of the given node, stores the output name.
	 *
	 * Metadata is used as a fall back in the occasions where an update/deletion of node's data
	 * have been made and we want to assist the user in recovering and fixing any potential issues
	 * with that.
	 *
	 * @param {Object} flow The flow definition to add metadata to.
	 */
	applyMetadata(flow) {
		for (const nodeId in flow.nodes) {
			const node = flow.nodes[nodeId];
			let flowNode;
			try {
				// Get the registered flow-node for this node
				flowNode = this.getRegisteredNodeSpec(node.type);
			} catch (e) {
				// do nothing
			}

			// METHOD
			// get the method, if it exists (and if the flow-node exists)
			const method = flowNode && flowNode.methods[node.method];
			// apply the flow-node metaMethod and fall back to the id.
			if (method) {
				node.metaMethod = method.name || node.method;
			} else {
				// method no longer exists so keep the name and fall back to the id.
				node.metaMethod = node.metaMethod || node.method;
			}
			// PARAMETERS
			const methodParameters = method
				&& method.parameter
				&& method.parameter.properties
				|| {};
			// Go through all node parameters and add the meta data
			for (const param of node.parameters) {
				// name is actually the id
				const paramID = param.name;

				// The parameter details from the spec
				const paramDetails = methodParameters[paramID];
				if (paramDetails) {
					param.metaName = paramDetails.title || paramID;
					param.metaDescription = paramDetails.description;
				} else {
					param.metaName = param.metaName || paramID;
				}
			}

			// OUTPUTS
			// apply the flow-node ouput name metadata
			// The cases where outputs exist in the flow-node and not the flow
			// and the outputs exist in the flow but not the flow-node
			// need to be handled later.
			for (const outputId in node.outputs) {
				const flowOutput = node.outputs[outputId];
				const output = method && method.outputs[outputId];
				if (output) {
					// apply the output metaName and fall back to the output id
					flowOutput.metaName = output.name || outputId;
				} else {
					// output no longer exists so keep the name and fall back to the id.
					flowOutput.metaName = flowOutput.metaName || outputId;
				}
			}
		}
	}

	/**
	 * Convert known schema validation error string into something a bit more consumable
	 *
	 * @param {string} validation - schema validation
	 * @param {object} flowDef - flow definition
	 * @returns {object} validation Error or object describing validation error
	 */
	_parseValidation(validation) {
		if (/\$\.start should be string/.test(validation)) {
			return {
				valid: false,
				errors: [{
					code: 'INVALID_NODE',
					type: 'invalidStart'
				}]
			};
		}
		return new Error(validation);
	}
}

// convenience 'static' method
FlowManager.formatNodeHandlerUri = formatNodeHandlerUri;
module.exports = FlowManager;
