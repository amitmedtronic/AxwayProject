const getByJsonPath = require('./jsonpath').getByJsonPath;
const chalk = require('chalk');
const {
	formatNodeName,
	scopeNodeLogger,
	setEnumerableIfErrorLike
} = require('./utils');

class FlowNode {
	constructor(id, node, spec, flow) {
		this.node = node || {};
		this.id = id;
		this.spec = spec;
		this.flow = flow;
		this.title = new.target;
		if (new.target === FlowNode) {
			throw new TypeError('Cannot construct FlowNode instances directly.');
		}
	}

	/**
	 * Gets the action method information.
	 * @private
	 * @return {object} The method.
	 */
	_getActionMethod() {
		const methodNames = Object.keys(this.spec.methods);
		// note: spec does not allow 0 methods, so it exists
		if (methodNames.length > 1) {
			// If a node has more than one method, then `config.method` is required.
			if (!this.node.method) {
				throw new Error(`expected method config for node: ${this.id}`);
			}
		}

		const methodIdx = methodNames.indexOf(this.node.method);
		if (methodIdx < 0) {
			throw new Error(`node '${this.id}' is configured to use an unknown method: ${this.node.method}`);
		}
		const name = methodNames[methodIdx];
		const action = this[name];
		if (!action) {
			throw new Error(`expected handler for node '${this.id}' to have function named: ${name}`);
		}
		return {
			name,
			spec: this.spec,
			method: this.spec.methods[name],
			action: action.bind(this)
		};
	}

	/**
	 * Iterates over parameters specified by the flow-node `location` and resolves them against
	 * the runtime `ctx`.
	 * @param {object} ctx - The runtime context.
	 * @param {string} location - The flow-node parameter location to resolve.  One of:
	 *		authorizations, parameters.
	 * @return {object} The params object.
	 */
	_resolveInputs(ctx, location) {
		let params = null;
		this.node[location] && this.node[location].forEach(param => {
			params = params || {};
			let val = param.value;

			if (param.type === 'credential') {
				// resolve the credential via the manager
				val = this.flow.credentialManager && this.flow.credentialManager.getCredential
					&& this.flow.credentialManager.getCredential(param.value);
			} else if (param.type === undefined || param.type === 'jsonpath') {
				val = getByJsonPath(val, ctx.data);
			} else {
				try {
					val = JSON.parse(val);
				} catch (e) {
					val = undefined;
				}
			}

			// if value is undefined, do not assign to params - it does not resolve.
			if (val !== undefined) {
				params[param.name] = val;
			}

			// useful for debugging parameters:
			if (ctx.runtime && ctx.runtime.logger.willLogAt('TRACE')) {
				if (param.type === undefined || param.type === 'jsonpath') {
					ctx.runtime.logger.trace(chalk.dim(
						'resolved selector',
						param.value,
						`'${param.name}'`,
						'as',
						JSON.stringify(params[param.name]),
						'in',
						location
					));
				} else {
					ctx.runtime.logger.trace(chalk.dim(
						'resolved',
						`'${param.name}'`,
						'as',
						JSON.stringify(params[param.name]),
						'in',
						location
					));
				}
			}
		});
		return params;
	}

	/**
	 * Set up the callbacks.
	 * @param {object} actionMethod - the method to generate callback for
	 * @param {function} cb - the callback to bind outputs to
	 * @returns {object|function} the generated output callback
	 */
	curryOutputCallbacks(actionMethod, cb) {
		const self = this;
		const outputKeys = Object.keys(actionMethod.method.outputs);
		let outputCallback;

		// Set the default cb(err, result) target. This is required for upgrade where
		// existing nodehandlers may be unaware of the outputs and for handlers that have
		// no outputs.
		if (!outputKeys.length) {
			// No ouputs defined - callback is for completion only
			outputCallback = (err) => cb(null, err);
		} else if (outputKeys.length === 1) {
			// There's only one output, it's the de-facto default
			outputCallback = (err, result) => cb(outputKeys[0], err, result);
		} else {
			// Get default as defined in the spec.
			const defaultOutput
				= outputKeys.find(
					(output) =>
						actionMethod.method.outputs[output].hasOwnProperty('default')
						&& actionMethod.method.outputs[output].default
				) || outputKeys[0];
			outputCallback = (err, result) => cb(defaultOutput, err, result);
		}

		// Curry the callback with the known possible outputs. So you can do:
		// cb.<output>(<err>, <result>)
		outputCallback = outputKeys.reduce(
			(col, cur) => {
				col[cur] = cb.bind(self, cur);
				return col;
			},
			outputCallback
		);

		return outputCallback;
	}

	_getDisplayName(node) {
		return formatNodeName(node);
	}

	async invoke(ctx) {
		let callback;
		const t0 = Date.now();
		const runtimeLogger = ctx.runtime && ctx.runtime.logger;
		const isTrace = runtimeLogger && runtimeLogger.willLogAt('TRACE');
		// This promise will be settled when the first output is called
		// by the action
		const outputResult = new Promise((resolve, reject) => {
			callback = (output, err, results) => {
				const t1 = Date.now();
				if (err) {
					if (isTrace) {
						runtimeLogger.trace(
							`${this._getDisplayName(this)} rejected.`);
					}
					return reject(err);
				}
				// If the output `Error` (or like it), set the message to be
				// enumerable so it will log/JSON.stringify with detail.  We
				// only need to do this on output (not input) because we will
				// not be passing `Error` as data into the flow, and if we do
				// need to, we can enable it, but one is enough for now.
				setEnumerableIfErrorLike(results);
				if (isTrace) {
					runtimeLogger.trace(
						`${this._getDisplayName(this)} ${output} resolved.`);
				}
				return resolve({ results, output, time: t1 - t0 });
			};
		});
		try {
			const input = {
				authorizations: this._resolveInputs(ctx, 'authorizations'),
				params: this._resolveInputs(ctx, 'parameters')
			};

			const actionMethod = this._getActionMethod();
			const callbacks = this.curryOutputCallbacks(actionMethod, callback);

			const actionOptions = {};
			if (runtimeLogger) {
				const scopeOptions = {
					reqId: ctx.data && ctx.data.request && ctx.data.request._reqid,
					nodeId: this.id,
					nodeName: this.node.name
				};

				actionOptions.logger = scopeNodeLogger(runtimeLogger, scopeOptions);
			}

			// action can be async, return a promise, or be a regular function
			const action = actionMethod.action(input, callbacks, actionOptions);
			// outputResult should be expected to resolve first, but this will avoid any
			// unhandled promise rejections if action rejects after an output is called.
			await Promise.race([ action, outputResult ]);
		} catch (err) {
			if (isTrace) {
				runtimeLogger.trace(`${this._getDisplayName(this)} rejected: ${err}`);
			}
			throw err;
		}
		// Resolve with the value of the first output callback to be called
		return outputResult;
	}
}

module.exports = FlowNode;
