const chalk = require('chalk');

/**
 * Returns the log scope for the method/flow-node.
 * This scope is indented to match the indentation of other flow logs
 * @param {string} nodeName - The node name.
 * @param {string} nodeId - The ID of the flow-node that is making the request.
 * @returns {string} The scope for new flow-node loggers
 * @example "  getInventory (petstore.1)"
 */
function getNodeScope(nodeName, nodeId) {
	return `  ${chalk.green(`${nodeName} (${nodeId})`)}`;
}

/**
 * Returns the options required for scoping the logging of requests/responses for nodes.
 *
 * Outputs the following format:
 * 	[request-id: abc1234] getInventory (petstore.1)
 *
 * @param {Object} scopeData - The data to build the scopped version of the logger with.
 * @param {string} scopeData.reqId - The originating request-id.
 * @param {string} scopeData.nodeId - The ID of the node that is making the request.
 * @param {string} scopeData.nodeName - The node name.
 *
 * @returns {Object} The node options for logger scoping.
 */
function buildScopeOptions(scopeData) {
	const { reqId, nodeId, nodeName } = scopeData;
	const prefix = `[request-id: ${reqId}] ${getNodeScope(nodeName, nodeId)}`;
	return {
		prefix
	};
}

/**
 * Returns a scoped logger based on the node's data.
 *
 * @param {Object} logger - A logger instance.
 * @param {Object} scopeData - The data to build the scopped version of the logger with.
 * @param {string} scopeData.reqId - The originating request-id.
 * @param {string} scopeData.nodeId - The ID of the node that is making the request.
 * @param {string} scopeData.nodeName - The node name.
 *
 * @returns {Object} The scopped logger based on the node's data.
 */
function scopeNodeLogger(logger, scopeData) {
	if (logger.getScoped) {
		const scope = getNodeScope(scopeData.nodeName, scopeData.nodeId);
		return logger.getScoped(scope);
	}

	// Legacy logger behavior
	const loggerOptions = buildScopeOptions(scopeData);

	// Scope the requst logger based on the node's details
	const reqLogger = logger.scope(null, loggerOptions);

	// Freeze the scopped logger, to prevent malicious changes
	return Object.freeze(reqLogger);
}

/**
 * Gets the name of a node via node id or node
 * @param  {object} nodeInput - A flow node
 * @return {string}      The node name followed by the node id
 */
function formatNodeName(nodeInput) {
	const { node, id } = (nodeInput || {});
	const name = (node && node.name && `${node.name} `) || '';
	const idStr = id ? `(${id})` : '';
	return `${name}${idStr}`;
}

/**
 * Tests the constructor of object `err` to see if it has the name `"Error"`.
 * If it does not, it will recursively check the prototype constructors
 * until one is found, or until it is null.
 *
 * @param {Object} err - The object to test.
 *
 * @returns {Object} Returns true if a constructor has the name `"Error"`.
 */
function hasErrorConstructor(err) {
	if (err.constructor.name === 'Error') {
		return true;
	}
	const parent = Object.getPrototypeOf(err);
	if (parent) {
		return hasErrorConstructor(parent);
	}
	return false;
}

/**
 * Check to see if `err` is an instanceof `Error` or looks like an instance
 * of `Error`.  It looks like an `Error` if it has a `message` property and
 * it's constructor name, or a parent prototype constructor name is `"Error"`.
 * This supports testing instances of `Error` created in different execution
 * contexts.
 *
 * @param {Object} err - The object to test.
 *
 * @returns {Object} Returns true if it is looks like `Error`
 */
function isErrorLike(err) {
	if (err === null || err === undefined || typeof err !== 'object') {
		return false;
	}
	if (err instanceof Error) {
		return true;
	}
	if (!('message' in err) || !('stack' in err)) {
		return false;
	}
	return hasErrorConstructor(err);
}

/**
 * Checks to see if `err` is an error (or is like an error), and if it is, it
 * will enable enumerable on the `message` property enabling it to be JSON
 * stringified.
 *
 * @param {*} err - The possible Error to check/change.
 */
function setEnumerableIfErrorLike(err) {
	if (isErrorLike(err)) {
		// alter the object to have an enumerable `message` prop
		Object.defineProperty(err, 'message', {
			enumerable: true
		});
	}
}

exports = module.exports = {
	formatNodeName,
	scopeNodeLogger,
	isErrorLike,
	setEnumerableIfErrorLike
};
