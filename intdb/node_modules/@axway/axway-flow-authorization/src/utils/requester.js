const contentType = require('content-type');
const querystring = require('querystring');
const requester = require('@axway/requester');
const { status, States } = require('../status');
const jwtUtils = require('./jwt');

const defaultHeaders = {
	'Content-Type': 'application/x-www-form-urlencoded',
	Accept: 'application/json'
};

/**
 * Formats the authentication URL for the credential. Used in accessCode flow.
 *
 * @param {Object} credential - The credential.
 * @param {Object} tcred - The redential types from typeofCredential.
 * @returns {string} A formatted URL.
 */
function formatAuthURL(credential, tcred) {
	const query = {};
	[ 'redirect_uri', 'client_id', 'scope' ]
		.filter(a => tcred[a] === 'string')
		.forEach(a => query[a] = credential[a]);
	query.state = credential.name;
	const sep = credential.authentication_url.indexOf('?') === -1 ? '?' : '&';
	const params = querystring.stringify(query);
	return `${credential.authentication_url}${sep}response_type=code&${params}`;
}

/**
 * Perform an oauth credential request and process the result.
 *
 * @param {Object} credential - The credential the request relates to.
 * @param {Object} params - The request specific parameters.
 * @returns {Promise} A promise that resolves with the new credential.
 */
async function accessCodeRequest(credential, params) {
	params = [ 'client_id', 'client_secret', 'redirect_uri' ].reduce((col, cur) => {
		col[cur] = credential[cur];
		return col;
	}, params);
	const { body, headers } = constructBodyAndHeaders(credential, params);
	const response = await requester.request({
		url: credential.token_url,
		headers,
		method: 'POST',
		body
	}, {
		keepAlive: false
	});
	return updateCredential(credential, response);
}

/**
 * Perform an oauth credential request and process the result.
 *
 * @param {Object} credential - The credential the request relates to.
 * @returns {Promise} A promise that resolves with the new credential.
 */
async function credentialsRequest(credential) {
	const { token_url, client_id, client_secret, scope } = credential;
	const params = {
		grant_type: 'client_credentials',
		client_id,
		client_secret
	};
	addScope(params, scope);
	const { body, headers } = constructBodyAndHeaders(credential, params);
	const response = await requester.request({
		url: token_url,
		headers,
		method: 'POST',
		body
	}, {
		keepAlive: false
	});
	return updateCredential(credential, response);
}

/**
 * Perform an JWT auth grant credential request and process the result.
 *
 * @param {Object} credential - The credential the request relates to.
 * @returns {Promise} A promise that resolves with the new credential.
 */
async function jwtAuthGrantRequest(credential) {
	const { client_id, token_url, private_key, passphrase, scope } = credential;
	const jwtToken = jwtUtils.sign(
		client_id,
		token_url,
		private_key,
		passphrase
	);
	const body = {
		grant_type: 'urn:ietf:params:oauth:grant-type:jwt-bearer',
		assertion: `${jwtToken}`
	};
	addScope(body, scope);
	const response = await requester.request({
		url: token_url,
		headers: defaultHeaders,
		method: 'POST',
		body
	}, {
		keepAlive: false
	});
	return updateCredential(credential, response);
}

/**
 * Perform an JWT client auth credential request and process the result.
 *
 * @param {Object} credential - The credential the request relates to.
 * @returns {Promise} A promise that resolves with the new credential.
 */
async function jwtClientAuthRequest(credential) {
	const { client_id, token_url, private_key, passphrase, scope } = credential;
	const jwtToken = jwtUtils.sign(
		client_id,
		token_url,
		private_key,
		passphrase
	);
	const body = {
		grant_type: 'client_credentials',
		client_assertion_type: 'urn:ietf:params:oauth:client-assertion-type:jwt-bearer',
		client_assertion: `${jwtToken}`
	};
	addScope(body, scope);
	const response = await requester.request({
		url: token_url,
		headers: defaultHeaders,
		method: 'POST',
		body
	}, {
		keepAlive: false
	});
	return updateCredential(credential, response);
}

function addScope(body, scope) {
	if (scope !== undefined && scope !== null) {
		body.scope = scope;
	}
}

function constructBodyAndHeaders(credential, body) {
	const headers = {
		...defaultHeaders
	};

	if (credential.basic_auth) {
		// if the `basic_auth` option is enabled, send the client_id and secret
		// as HTTP Basic auth, and remove them from the body.
		const buff = Buffer.from(`${body.client_id}:${body.client_secret}`);
		headers.Authorization = `Basic ${buff.toString('base64')}`;
		delete body.client_id;
		delete body.client_secret;
	}

	return { body, headers };
}

function updateCredential(credential, response) {
	if (response.status !== 200) {
		let message = `Expected 200 status code but got ${response.status}`;
		if (response.body && typeof response.body === 'object') {
			message += ` ${JSON.stringify(response.body)}`;
		}
		throw new Error(message);
	}
	const respContentType = contentType.parse(response.headers['content-type']);
	if (respContentType.type !== 'application/json') {
		throw new Error(`${credential.name} failed because the server responded with an unsupported mime-type: ${response.headers['content-type']}`);
	}
	const newCred = JSON.parse(JSON.stringify(credential));
	const { access_token, expires_in, scope, refresh_token } = response.body;
	newCred.access_token = access_token;
	newCred.expiry = expires_in
		? Date.now() + (expires_in * 1000)
		: null;

	if (scope) {
		newCred.scope = scope;
	}
	if (refresh_token) {
		newCred.refresh_token = refresh_token;
	}
	newCred.status = newCred.access_token
		? status({
			credential: States.credential.ok,
			action: States.action.none
		})
		: status(credential.status, { credential: States.credential.none });

	return newCred;
}

module.exports = {
	requests: {
		accessCode: accessCodeRequest,
		credentials: credentialsRequest,
		jwtAuthGrant: jwtAuthGrantRequest,
		jwtClientAuth: jwtClientAuthRequest
	},
	formatAuthURL
};
