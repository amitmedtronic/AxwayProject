const { status, States } = require('../../status');
const { formatAuthURL, requests } = require('../../utils/requester');
const { typeofCredential } = require('../handlerUtils');

const REQUIRED_ATTR = [
	'access_token',
	'authentication_url',
	'client_id',
	'client_secret',
	'flow',
	'token_url',
	'redirect_uri',
	'refresh_token'
];

const CRED_ATTRS = REQUIRED_ATTR.concat([ 'scope' ]);

/**
 * Tests for missing client credentials.  Specifically where either client_id or
 * client_secret are null, but neither are string.
 *
 * "type": "oauth2",
 * "client_id": null,
 * "client_secret": null,
 * "authentication_url": "non-null-looks-like-url",
 * "token_url": "non-null-looks-like-url",
 * "scope": "null-or-string",
 * "refresh_token": null,
 * "access_token": null
 *
 * @param {object} credential - The credential.
 * @param {object} tcred - The redential types from typeofCredential.
 * @returns {boolean} True if this credential needs client configuration.
 */
function needsClient(credential, tcred) {
	return tcred.authentication_url === 'string'
		&& tcred.token_url === 'string'
		&& tcred.flow === 'string'
		&& (tcred.client_id === 'null' || tcred.client_secret === 'null')
		&& (tcred.client_id !== 'string' || tcred.client_secret !== 'string')
		&& tcred.scope !== 'undefined'
		&& tcred.access_token === 'null'
		&& tcred.refresh_token === 'null';
}

/**
 * Tests for credentials that are valid enough to begin the access code grant flow.
 *
 * "type": "oauth2",
 * "client_id": "non-null",
 * "client_secret": "non-null",
 * "authentication_url": "non-null-looks-like-url",
 * "token_url": "non-null-looks-like-url",
 * "scope": "null-or-string",
 * "refresh_token": null,
 * "access_token": null
 *
 * @param {object} credential - The credential.
 * @param {object} tcred - The redential types from typeofCredential.
 * @returns {boolean} True if this credential has enough to begin access code grant flow.
 */
function hasGrantConfig(credential, tcred) {
	return CRED_ATTRS
		.filter(a => [ 'client_id', 'client_secret', 'redirect_uri' ].includes(a))
		.every(a => tcred[a] === 'string');
}

function init(credential, { baseurl, callback }) {
	// Set default redirect_uri
	if (!credential.redirect_uri && baseurl && callback) {
		credential.redirect_uri = baseurl + callback;
	}
	const tcred = getCredentialAttributeTypes(credential);
	checkRequiredAttributes(credential, tcred);

	const has = {
		NeedsClient: needsClient(credential, tcred),
		RefreshToken: tcred.refresh_token === 'string',
		AuthUrl: tcred.authentication_url === 'string',
		TokenUrl: tcred.token_url === 'string',
		GrantConfig: hasGrantConfig(credential, tcred)
	};

	// Create the formatted authentication url here to allow for customization
	if (has.AuthUrl) {
		credential.formatted_authentication_url
			= formatAuthURL(credential, tcred);
	}

	// Assume error
	credential.status = status({
		credential: States.credential.none,
		action: States.action.none
	});

	if (has.NeedsClient) {
		credential.status = status({
			credential: States.credential.none,
			action: States.action.needsClient
		});
		return;
	}

	if (has.GrantConfig) {
		// There is sufficient information for a refresh-token or auth-code grant flow, *except*
		//  that authentication_url, token_url, refresh_token, and access_token have not been
		// tested.
		if (!has.TokenUrl) {
			throw new Error(`Invalid configuration for credential ${credential.name}. token_url should be provided`);
		}

		if (!has.RefreshToken && !has.AuthUrl) {
			throw new Error(`Invalid configuration for credential ${credential.name}. refresh_token or authentication_url should be provided`);
		}

		if (tcred.access_token === 'null' && !has.RefreshToken) {
			credential.status = status({
				credential: States.credential.none,
				action: States.action.needsAuth
			});
			return;
		}
		if (tcred.access_token === 'null' && has.RefreshToken) {
			credential.status = status({
				credential: States.credential.none,
				action: States.action.needsRefresh
			});
			return;
		}
		credential.status = status({
			credential: States.credential.ok,
			action: States.action.none
		});
		return;
	}

	// Note, the code below is basically a catch-all for the logic above for
	// when there is sufficient details to achieve an auth code grant.  At this
	// stage we know: 1) it is not static; 2) There are not enough details for
	// the grant.  At this stage, the credential _should_ be invalid, but we
	// have these conditions that are a bit of a mess:
	//
	// 1. A credential of authentication_url (all others are null) is considered
	// valid (green in the UI) but it is not.
	//
	// 2. A credential of token_url (all others are null) is considered valid
	// (green in the UI) but it is not.
	//
	// 3. A credential of authentication_url, token_url, and any of (but not
	// all), client_id, client_secret, and redirect_uri (all others are null) is
	// considered valid (green in the UI) but it is not.

	// At some stage, it might be worth a REFACTOR just throw that the credential
	// is invalid here, but that is a breaking change, so needs a flag and not
	// worth it unless necessary.
	if (!has.AuthUrl && !has.TokenUrl) {
		throw new Error(`Invalid configuration for credential ${credential.name}. Requires an access_token, or authentication_url and/or token_url should be provided.`);
	}
}

function refreshable(credential) {
	return [ 'token_url', 'client_id', 'client_secret', 'redirect_uri', 'refresh_token' ]
		.every(key => credential.hasOwnProperty(key) && typeof credential[key] === 'string')
		&& !(credential.status && credential.status.action === States.action.needsAuth);
}

/**
 * Perform an oauth credential request.
 *
 * @param {Object} credential - The credential the request relates to.
 * @param {object} options - The request specific parameters.
 * @returns {Promise} A promise that resolves with the new credential.
 */
function refresh(credential) {
	return makeRequest(credential, {
		grant_type: 'refresh_token',
		refresh_token: credential.refresh_token
	});
}

function getToken(credential) {
	return credential.access_token || null;
}

/**
 * Perform an oauth credential request.
 *
 * @param {Object} credential - The credential the request relates to.
 * @param {object} options - The request specific parameters.
 * @returns {Promise} A promise that resolves with the new credential.
 */
function requestToken(credential, options) {
	return makeRequest(credential, {
		grant_type: 'authorization_code',
		code: options.code
	});
}

/**
 * Perform an oauth credential request.
 *
 * @param {object} credential - The credential the request relates to.
 * @param {object} options - The request specific parameters.
 * @returns {Promise} A promise that resolves with the new credential.
 */
function makeRequest(credential, options) {
	return requests.accessCode(credential, options);
}

/**
 * @param {Object} credential - the credentail for which the attribute types
 * should be taken
 * @returns {Object} the types of the values provided for the credentials
 * attributes using the logic in typeofCredential function.
 */
function getCredentialAttributeTypes(credential) {
	return CRED_ATTRS.reduce((acc, cur) => {
		acc[cur] = typeofCredential(credential[cur]);
		return acc;
	}, {});
}

/**
 * Tests for a valid static access token. Note that this is the only case that
 * allows undefined values. Specifically this case:
 *
 * "type": "oauth2",
 * "client_id": null | undefined,
 * "client_secret": null | undefined,
 * "authentication_url": null | undefined,
 * "token_url": null | undefined,
 * "scope": null | undefined,
 * "refresh_token": null | undefined,
 * "access_token": "non-null"
 *
 * @param {object} credential - The credential to test.
 * @returns {boolean} True if this credential is a valid static access token.
 */
function isStaticAccessToken(credential) {
	if (!credential.access_token) {
		return false;
	}
	const credentialAttributesTypes = getCredentialAttributeTypes(credential);
	return credentialAttributesTypes.access_token === 'string' && CRED_ATTRS
		.filter(a => ![ 'flow', 'access_token', 'redirect_uri' ].includes(a))
		.every(a => credentialAttributesTypes[a] !== 'string');
}

/**
 * Validates that credential has all of its attributes defined.
 *
 * @param {object} credential - The credential.
 * @param {object} credentialAttributesTypes - The credential attribute types.
 * calculated with typeofCredential function.
 */
function checkRequiredAttributes(credential, credentialAttributesTypes) {
	for (const attr of REQUIRED_ATTR) {
		if (credentialAttributesTypes[attr] === 'undefined') {
			throw new Error(`Invalid configuration for credential ${credential.name}. ${attr} is undefined`);
		}
	}
}

module.exports = {
	init,
	refreshable,
	refresh,
	getToken,
	requestToken,
	isStaticAccessToken
};
