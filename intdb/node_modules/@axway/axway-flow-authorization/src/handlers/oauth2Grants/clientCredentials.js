const { status, States } = require('../../status');
const { requests } = require('../../utils/requester');
const jwtUtils = require('../../utils/jwt');
const { typeofCredential } = require('../handlerUtils');

const REQUIRED_ATTR = [
	'flow',
	'token_url',
	'client_id',
	'access_token'
];
const CRED_ATTRS = [
	'flow',
	'token_url',
	'client_id',
	'client_secret',
	'access_token',
	'scope',
	'private_key',
	'passphrase',
	'access_token',
	'assertion_type'
];

const ASSERTION_TYPES = [ 'jwtClientAuth', 'jwtAuthGrant' ];

function hasNoAssertionType(tcred) {
	return tcred.assertion_type === 'undefined';
}

function hasValidAssertionType(credential) {
	return ASSERTION_TYPES.includes(credential.assertion_type);
}

function hasClientSecret(tcred) {
	return tcred.client_id === 'string'
		&& tcred.client_secret === 'string';
}

function isJWTConfigured(tcred) {
	return tcred.client_id === 'string'
		&& tcred.private_key === 'string'
		&& tcred.passphrase === 'string'
		&& tcred.token_url === 'string'
		&& tcred.assertion_type === 'string';
}

function isSharedSecretConfigured(tcred) {
	return tcred.client_id === 'string'
		&& tcred.client_secret === 'string'
		&& tcred.token_url === 'string';
}

function init(credential) {
	const tcred = getCredentialAttributeTypes(credential);
	checkRequiredAttributes(credential, tcred);
	if (typeof credential.token_url !== 'string') {
		throw new Error(`Invalid configuration for credential ${credential.name}. Requires token_url to be provided.`);
	}

	// We assume all is fine so the state needsAuth will trigger the token obtain
	// from the auth server.
	credential.status = status({
		credential: States.credential.none,
		action: States.action.needsAuth
	});

	if (hasNoAssertionType(tcred)) {
		if (!hasClientSecret(tcred)) {
			credential.status = status({
				credential: States.credential.none,
				action: States.action.needsClient
			});
		}
	} else {
		if (!hasValidAssertionType(credential)) {
			throw new Error(
				`Invalid configuration for credential ${credential.name}. Allowed assertion types are ${ASSERTION_TYPES.toString()}`);
		}

		if (!isJWTConfigured(tcred)) {
			credential.status = status({
				credential: States.credential.none,
				action: States.action.needsPK
			});
			return;
		}

		// dry run the jwt signing so we fail the startup if there is problem
		// with the private key
		try {
			jwtUtils.sign(
				credential.client_id,
				credential.token_url,
				credential.private_key,
				credential.passphrase
			);
		} catch (err) {
			throw new Error(
				`Unable to sign the JWT for credential ${credential.name}. Check your private_key and passphrase. ${err.message}`);
		}
	}
}

function refreshable(credential) {
	const tcred = getCredentialAttributeTypes(credential);
	return isJWTConfigured(tcred) || isSharedSecretConfigured(tcred);
}

/**
 * Perform an oauth credential request.
 *
 * @param {Object} credential - The credential the request relates to.
 * @returns {Promise} A promise that resolves with the new credential.
 */
function refresh(credential) {
	return requests[credential.assertion_type || 'credentials'](credential);
}

function getToken(credential) {
	return credential.access_token || null;
}

/**
 * Perform an oauth credential request and process the result.
 *
 * @param {Object} credential - The credential the request relates to.
 * @returns {Promise} A promise that resolves with the new credential.
 */
function requestToken(credential) {
	return refresh(credential);
}

/**
 * @param {Object} credential - the credentail for which the attribute types
 * should be taken
 * @returns {Object} the types of the values provided for the credentials
 * attributes using the logic in typeofCredential function.
 */
function getCredentialAttributeTypes(credential) {
	return CRED_ATTRS.reduce((acc, cur) => {
		acc[cur] = typeofCredential(credential[cur]);
		return acc;
	}, {});
}

/**
 * Tests for a valid static access token. Note that this is the only case that
 * allows undefined values. Specifically this case:
 *
 * "type": "oauth2",
 * "flow": "non-null"
 * "access_token": "non-null"
 *
 * @param {object} credential - The credential to test.
 * @returns {boolean} True if this credential is a valid static access token.
 */
function isStaticAccessToken(credential) {
	const tcred = getCredentialAttributeTypes(credential);
	return tcred.flow === 'string'
		&& tcred.access_token === 'string';
}

/**
 * Validates that credential has all of its attributes defined.
 *
 * @param {object} credential - The credential.
 * @param {object} credentialAttributesTypes - The credential attribute types.
 * calculated with typeofCredential function.
 */
function checkRequiredAttributes(credential, credentialAttributesTypes) {
	for (const attr of REQUIRED_ATTR) {
		if (credentialAttributesTypes[attr] === 'undefined') {
			throw new Error(`Invalid configuration for credential ${credential.name}. ${attr} is undefined`);
		}
	}
}

module.exports = {
	init,
	refreshable,
	refresh,
	getToken,
	requestToken,
	isStaticAccessToken
};
