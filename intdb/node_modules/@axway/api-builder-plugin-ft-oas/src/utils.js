const path = require('path');
const contentTypeParser = require('content-type');
const { readdir } = require('./afs');
const JSONContentType = /^application\/(.*\+)?json/;

/**
 * Gets the scope used for axway-schema, e.g. schema:///oas-ft-petstore-oas3/Pet
 * @param {String} name - The OAS file base name.
 * @returns {String} A name to use for scoping schema.
 */
function getSchemaScope(name) {
	return encodeURIComponent(`oas-ft-${name}`);
}

/**
 * Checks if the provided schema reprents date. Note that there might be more date
 * related formats but we are interested for those we check in this function.
 *
 * @param {Object} schema - the schema to check.
 * @returns {boolean} true if the schema is date schema.
 */
function isDateSchema(schema) {
	return schema.type === 'string'
		&& [ 'date', 'date-time' ].includes(schema.format);
}

/**
 * There are use cases when we want to convert strings to Date object in order to
 * match swagger-tools behaviour. This function works in conjunction with
 * "convertDateStringToObject" trigger parameter.
 *
 * @param {Object} schema - the schema to check.
 * @returns {boolean} true if the string date must be converted to Date object.
 */
function shouldConvertToDateObject(schema) {
	if (isDateSchema(schema)) {
		return true;
	} else if (schema.type === 'array' && schema.items) {
		return isDateSchema(schema.items);
	}
}

/**
 * Converts the input value to a Date object or array of Date objects.
 *
 * @param {string|array} value - the value to be converted to Date object.
 * @returns {string|array} - return Date object or an array of Date objects
 * depending on the input.
 */
function convertToDateObject(value) {
	if (value instanceof Array) {
		return value.map(val => new Date(val));
	} else {
		return new Date(value);
	}
}

function parseContentType(contentType) {
	const parsed = contentTypeParser.parse(contentType);
	parsed.json = JSONContentType.test(contentType);
	return parsed;
}

/**
 * Gets a file name, sanitize it, and returns an unique filename based on the
 * existing files in the destination directory. Only files with json|yaml|yml
 * extensions are considered. If a file already exists with that name, a count
 * will be appended to the filename until a file no longer exists with that
 * filename and count: e.g. myFile, myFile1, myFile2, etc.
 *
 * @param {string} dir - The directory to check the filename against.
 * @param {string} filename - The filename to use to generate a unique name.
 * @throws {Error} - re-throws any fs.readdir errors.
 * @returns {string} A unique filename.
 */
async function getUniqueFilename(dir, filename) {
	const basename = getBasenameFromFile(filename);
	const name = sanitizeName(basename);
	const files = await readdir(dir);
	let count = 0;
	let uniqueName;
	while (true) {
		uniqueName = count ? `${name}${count}` : name;
		const re = new RegExp(`${uniqueName}\\.(json|yaml|yml)$`);
		if (!files.find(a => a.match(re))) {
			break;
		} else {
			count += 1;
		}
	}
	return path.join(dir, `${uniqueName}${path.extname(filename)}`);
}

/**
 * Sanitizes the `basename`, removing characters that will cause the trigger-id
 * to fail validation. See `utils.encodeNameForURI` and the `strict-uri-encode`
 * package.
 *
 * @param {string} basename - The basename to sanitize.
 * @returns {string} The sanitized name.
 */
function sanitizeName(basename) {
	return basename.replace(/[^A-Za-z0-9-_.~]/g, '');
}

/**
 * Gets the basename from `file`.
 *
 * @param {string} file - The filename.
 * @returns {string} file name without extension.
 */
function getBasenameFromFile(file) {
	return path.basename(file, path.extname(file));
}

/**
 * Ensures the `filename` ends with a supported suffix that designates the
 * encoding. If the `filename` does not end in .yaml, .yml, or .json, then
 * ".yaml" will be appended to `filename`.
 * @param {string} filename - The filename to ensure.
 * @returns {string} The filename with a valid extension.
 */
function ensureExtension(filename) {
	if (![ '.yaml', '.yml', '.json' ].includes(path.extname(filename))) {
		return `${filename}.yaml`;
	}
	return filename;
}

module.exports = {
	getSchemaScope,
	shouldConvertToDateObject,
	convertToDateObject,
	parseContentType,
	getUniqueFilename,
	sanitizeName,
	getBasenameFromFile,
	ensureExtension
};
