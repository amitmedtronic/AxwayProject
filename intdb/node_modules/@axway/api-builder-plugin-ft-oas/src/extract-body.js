const contentTypeParser = require('content-type');

const formContentTypes = [
	'application/x-www-form-urlencoded',
	'multipart/form-data'
];

/**
 * Extracts body from the request.
 *
 * @param {Object} req - the Express request object
 * @param {Object} options - options.
 * @param {Object} options.logger - API Builder logger.
 * @returns {Object} bodyInfo - extracted client data plus meta-information that allows
 * further data processing.
 */
function extractBody(req, { logger }) {
	const contentTypeInfo = getContentTypeInfo(req, logger);
	const body = getBody(req, logger);
	const filesInfo = getFiles(req, logger);
	const bodyInfo = {
		body,
		contentType: contentTypeInfo.contentType,
		hasContentType: req.headers['content-type'] !== undefined,
		contentLength: getContentLength(req.headers),
		hasContentLength: req.headers['content-length'] !== undefined,
		hasContentHeaders: isBodyExplicitlyProvided(req.headers),
		isForm: formContentTypes.includes(contentTypeInfo.contentType),
		errors: contentTypeInfo.errors
	};

	/**
	 * Checks if there is a content body, which is when there exists `req.body`
	 * or `req.fields` and there exists an explicit `content-length` (a length
	 * of "0" is considered valid). Note that if `transfer-encoding` is used,
	 * this will return `false` because it is impossible to determine if the
	 * body was explicitly set or if it was just "empty".
	 * @returns {boolean} `true` if the request has a content body sent with an
	 * explicit `content-length` header.
	 */
	bodyInfo.hasContentBody = function () {
		return bodyInfo.hasBodyToValidate()
			&& bodyInfo.hasContentLength;
	};

	/**
	 * Checks if there is a body to validate, which is when there exists either
	 * `req.body` or `req.fields`.
	 * @returns {boolean} `true` if the request has a content body or fields.
	 */
	bodyInfo.hasBodyToValidate = () => {
		return bodyInfo.body !== undefined;
	};

	/**
	 * Combines the the provided body with filenames to be used for validation.
	 *
	 * CONSIDER: The JSON schema `minLength` and `maxLength` for files are
	 * possible. E.g. to restrict image/png to a maximum size that is less than
	 * the upload limit. Using filenames for validation is not the right thing
	 * to do, but equally, so is reading the full content of the files into
	 * memory. I think the best thing to do for multipart/form-data files is to
	 * tweak the user's JSON schema to omit any problematic properties, such as
	 * `minLength`, `maxLength`, and `pattern` before validating.
	 *
	 * @param {Object} [body] - the body data that will be combined with files.
	 * @returns {Object} body to validate.
	 */
	bodyInfo.withFilesToValidate = (body) => {
		const bodyOnly = body;
		let combinedBody;
		if (filesInfo.filesToValidate) {
			// When we have files, which is only with 'multipart/form-data' content
			// type, we want them validated too.
			combinedBody = {
				...bodyOnly,
				...filesInfo.filesToValidate
			};
		}
		return combinedBody || bodyOnly;
	};

	/**
	 * Tweaks `schema` if the body has file parameters containing any of these
	 * JSON schema constraints: minLength, maxLength, pattern. This is because
	 * we are not able to validate binary data and these will be validated
	 * against the filename (used to indicate the parameter was provided),
	 * instead of the actual data. The `schema` will not be tweaked if there
	 * are no constraints. It will also only handle simple object properties.
	 *
	 * @param {Object} schema - The schema to modify.
	 * @returns {Object} The modified schema.
	 */
	bodyInfo.tweakSchemaWithFiles = (schema) => {
		if (!filesInfo.filesToValidate) {
			return schema;
		}
		// NOTE: there is a cost to this loop that could be improved by making
		// a cache in this file. The problem is `extract-body` is currently
		// scoped per-request. To REFACTOR this, we'd need a place per-operation
		// to cache things, and that doesn't exist yet.
		const paramsWithConstraints = [];
		for (const paramId in filesInfo.filesToValidate) {
			if (!schema.properties || !schema.properties[paramId]) {
				continue;
			}
			const prop = schema.properties[paramId];
			if (prop.minLength !== undefined
				|| prop.maxLength !== undefined
				|| prop.pattern !== undefined) {
				paramsWithConstraints.push(paramId);
			}
		}
		if (!paramsWithConstraints.length) {
			return schema;
		}
		logger.warn(
			'The following properties have JSON schema constraint(s) "minLength", "maxLength", or "pattern", that cannot be validated with uploaded files:',
			paramsWithConstraints.join(', ')
		);
		const clone = JSON.parse(JSON.stringify(schema));
		for (const paramId of paramsWithConstraints) {
			delete clone.properties[paramId].minLength;
			delete clone.properties[paramId].maxLength;
			delete clone.properties[paramId].pattern;
		}
		return clone;
	};

	/**
	 * Combines the provided `coercedBody` with sent files so that they can
	 * both be provided to the flow. If `coercedBody` is undefined, then it uses
	 * the original.
	 *
	 * @param {Object|Buffer|undefined} coercedBody - the coerced body data that
	 * will be combined with files.
	 * @returns {Object} body to send to the flow.
	 */
	bodyInfo.withFiles = (coercedBody) => {
		const bodyOnly = coercedBody !== undefined ? coercedBody : bodyInfo.body;
		if (filesInfo.files) {
			return {
				...bodyOnly,
				...filesInfo.files
			};
		}
		if (Buffer.isBuffer(bodyOnly)) {
			return bodyOnly;
		}
		// body can be undefined when the content-type header is sent, but the
		// content-length header is not.
		if (bodyOnly === undefined && bodyInfo.isForm) {
			// with the above content types we want to return empty object when
			// body is undefined
			return {};
		}
		return bodyOnly;
	};

	/**
	 * Flattens body parameters into `request.params`.
	 * @param {OASOperation} op - The OAS operation
	 * @param {Object} [coercedBody] - The coerced body (if provided)
	 * @param {Object} request - The target request where params will be copied.
	 */
	bodyInfo.flattenParameters = (op, coercedBody, request) => {
		const bodyOnly = coercedBody !== undefined ? coercedBody : bodyInfo.body;
		if (op.requestBodyName) {
			// the body is an OAS 2.0 named parameter
			request.params = {
				...request.params,
				[op.requestBodyName]: bodyOnly
			};
		} else if (bodyInfo.isForm) {
			// the body is a 2.0 or 3.0 form. when it is a form, the body is
			// always an object of property/values.
			request.params = {
				...filesInfo.files,
				...bodyOnly,
				...request.params
			};
		}
	};

	if (isInvalidBody(bodyInfo)) {
		logger.trace('body is invalid, setting to undefined');
		bodyInfo.body = undefined;
	}

	if (isZeroLengthJSON(bodyInfo)) {
		bodyInfo.errors.push(
			'content-type "application/json" cannot have a zero-length body');
	}
	return bodyInfo;
}

/**
 * Tests if the body is invalid. It is invalid if the request lacks a
 * content-type or if the body is zero-length JSON.
 * @param {Object} bodyInfo - The bodyInfo to check.
 * @returns {boolean} `true` if the body is invalid.
 */
function isInvalidBody(bodyInfo) {
	if (!bodyInfo.hasContentType) {
		return true;
	}
	return isZeroLengthJSON(bodyInfo);
}

/**
 * Tests if the body is zero-length JSON, which is a body that is an empty
 * object `{}` and has a `content-type` of "application/json", and also has an
 * explicit `content-length` header set to `"0"`.
 * @param {Object} bodyInfo - The bodyInfo to check.
 * @returns {boolean} `true` if the body is zero-length JSON.
 */
function isZeroLengthJSON(bodyInfo) {
	return bodyInfo.contentType === 'application/json'
		&& bodyInfo.hasContentLength
		&& bodyInfo.contentLength === 0;
}

/**
 * Extract files from the request.
 * @param {Object} req - the Express request.
 * @param {Object} logger - the logger.
 * @returns {Object} data - has the following properties:
 * data.files - information for the uploaded files.
 * data.filesToValidate - the part of the files that needs ot be validated.
 */
function getFiles(req, logger) {
	const { files } = req;
	const data = {};
	if (files && Object.keys(files).length > 0) {
		logger.trace('received request files:', files);
		data.files = files;
		data.filesToValidate = {};
		for (const name in files) {
			data.filesToValidate[name] = files[name].file;
		}
	}
	return data;
}

/**
 * Inspects the request `headers` to determine if a body was explicitly
 * provided. It returns `true` if either `transfer-encoding` or `content-length`
 * header was provided.
 *
 * @param {Object} headers - the request headers.
 * @returns {boolean} true if the body has been explicitly provided, otherwise
 * returns false.
 */
function isBodyExplicitlyProvided(headers) {
	return headers['content-length'] !== undefined
		|| headers['transfer-encoding'] !== undefined;
}

/**
 * Returns the length of the request body. If the request contains a
 * `content-length` header, it is parsed and returned as an integer. If a
 * `transfer-encoding` header is in the request, then the `content-length` is
 * -1, otherwise it is 0.
 * @param {Object} headers - the request headers.
 * @returns {integer} The request body length
 */
function getContentLength(headers) {
	return parseInt(headers['content-length'], 10)
		|| ((headers['transfer-encoding'] === undefined) ? 0 : -1);
}

/**
 * Gets information about the body - the actual data sent by the client.
 *
 * @param {Object} req - Express request object.
 * @param {Object} logger - the logger.
 * @returns {Object} the body or undefined if the body is not provided.
 */
function getBody(req, logger) {
	const { body, headers, fields } = req;
	if (fields) {
		logger.trace('received request fields:', fields);
		return fields;
	} else if (!isBodyExplicitlyProvided(headers)) {
		logger.trace('request has no body');
		return;
	}
	return body;
}

/**
 * Gets the content type information from the client requests. If there is no
 * content-type header, or if there is an error parsing the content-type header,
 * `errors` can be returned.
 *
 * @param {Object} req - Express request object.
 * @param {Object} logger - the logger.
 * @returns {Object} An object of `{ contentType, errors: [] }`,
 * info.contentType - the extracted client request content type.
 * info.errors - contains an error in case the content-type does not exist or
 * cannot be parsed.
 */
function getContentTypeInfo(req, logger) {
	const info = {
		errors: []
	};
	const contentType = req.header('content-type');
	if (!contentType) {
		if (getContentLength(req.headers) > 0) {
			info.errors.push('missing content-type header');
		}
		return info;
	}
	try {
		const parsedContentType = contentTypeParser.parse(contentType);
		logger.trace('received content type:', parsedContentType.type);
		info.contentType = parsedContentType.type;
	} catch (ex) {
		logger.error('Fail to parse content type:', contentType);
		info.errors.push(`Error parsing content-type: "${contentType}" ${ex.message}`);
	}
	return info;
}

module.exports = extractBody;
