const path = require('path');
const loadOAS = require('@axway/api-builder-oas-flow-node/src/plugin/loadOAS');
const { OASSecuritySchemes } = require('@axway/api-builder-oas-flow-node/src/oas/security');
const YAML = require('js-yaml');
const fs = require('./afs');
const {
	getSchemaScope,
	getUniqueFilename,
	getBasenameFromFile,
	ensureExtension
} = require('./utils');
const afs = require('./afs');

const JSON_YAML_EXP = /(?:.json|.ya?ml)$/;
const SPEC_TYPE = 'openapi';

class SpecManager {
	set apiPrefix(prefix) { this._prefix = prefix; }
	set appDir(dir) {
		this._appDir = dir;
		this._openapiPath = path.join(dir, 'apidocs', SPEC_TYPE);
	}
	set logger(logger) { this._logger = logger; }
	set port(port) { this._port = port; }
	set sslPort(sslPort) { this._sslPort = sslPort; }
	set security(security) { this._security = security; }
	set overrides(overrides) { this._overrides = overrides; }

	constructor() {
		this._definitionPaths = {};
	}

	/**
	 * This function modifies the original spec with the following "tweaks"
	 * before returning it to be validated and loaded.
	 * 1. Will prepend (OAS3) or replace (OAS2) the host info from the doc so that it reflects the
	 *    current running API Builder server host, port and apiPrefix (see @returns usePrefix)
	 * 2. Will strip all security definitions and requirements from the doc
	 * 3. Will add a single security definition & requirement to all paths in the doc based on the
	 *    currently configured auth strategy.
	 *
	 * NOTE: This function is using the raw spec which has not been dereferenced. This is
	 * the document that we *want* to tweak, although we are missing the useful helpers that OAS
	 * provides for us. Arguably the code which determines usePrefix shouldn't be in here, but
	 * looping the paths a second time, or loading the spec a second time is also highly inefficient
	 * so if the tweaking gets any more complex then we'll want to figure out an alternative way.
	 * We always need to validate _after_ tweaking to ensure we don't serve an invalid doc.
	 * @param {object} spec - OpenAPI document
	 * @returns {object} map of properties that were determined during the tweak operation.
	 * "usePrefix" is a boolean and is true if the configured apiPrefix should be used
	 * when binding the paths. It will be set to false if all paths already begin with the
	 * configured apiPrefix, and therefore should not be bound twice.
	 */
	_tweak(spec) {
		const oasVersion = spec.openapi ? '3' : '2';
		let dedupePrefix = true;

		// TODO: Consider failing import validation if spec has security definitions/schemes
		// and make people define them elsewhere. OR we consider actually making use of the
		// defined schemes somehow which requires more architecture and thought.
		// OR we let users define whatever they like and implement it however they like
		// in a flow or plugin (api first)
		// This would mean that we don't have naive code here trying to iterate the document and
		// modify it. We just wanted this to happen in one place (oas class)
		// If we are modifying it we should tell users.

		// remove all pre-existing security and securitySchemes
		delete spec.security;
		delete spec.securityDefinitions; // oas2
		if (spec.components) {
			// oas3
			delete spec.components.securitySchemes;
		}
		// list of supported verbs in OAS3 (oas2 is a slightly smaller set)
		const verbs = [ 'get', 'put', 'post', 'delete', 'options', 'head', 'patch', 'trace' ];
		for (const pathName in spec.paths) {
			// For OAS3, all keys are real paths, for OAS2 however, keys may also be extensions.
			// only those which start with / should be considered as paths available for traversal.
			if (!pathName.startsWith('/')) {
				continue;
			}

			// We want to dedupe if all paths start with the apiPrefix. If we hit one that doesn't
			// start with it, then we're not going to dedupe.
			// If we already set dedupe to false, then there's no point testing the pathName again.
			if (dedupePrefix && !pathName.startsWith(this._prefix)) {
				dedupePrefix = false;
			}

			// Note pathItemObject could contain a $ref elsewhere in the doc which defines security
			// so we'd need to follow the ref and FIXME (you can see how this is messy)
			const pathItemObject = spec.paths[pathName];
			for (const verb in pathItemObject) {
				if (verbs.includes(verb)) {
					const operationObject = pathItemObject[verb];
					// remove the security requirement for the path
					delete operationObject.security;
				}
			}
		}
		// FIXME: OAS3 Callback Objects contain Path Item Objects which contain security
		// requirements as well.

		// add our own security and securitySchemes, the _security is defined
		// in OAS 2 format, so needs to be converted. this._security is undefined
		// if auth is disabled, or a plugin doesn't implement getSwaggerSecurity.
		if (this._security) {
			// Apply security requirements
			const { security, securityDefinitions } = this._security;
			spec.security = security;
			// Apply security definitions
			if (oasVersion === '2') {
				spec.securityDefinitions = securityDefinitions;
			} else {
				// Build OAS 3 securitySchemes from OAS 2 definitions
				const securitySchemes = new OASSecuritySchemes({
					// supposed to be an entire spec but only uses securityDefinitions
					definition: {
						securityDefinitions
					}
				}, '2');
				spec.components = spec.components || {};
				// turn it into plain key/values instead of a class
				spec.components.securitySchemes = { ...securitySchemes };
			}
		}

		if (oasVersion === '3') {
			if (this._overrides.servers !== undefined) {
				if (this._overrides.servers === null) {
					delete spec.servers;
				} else {
					spec.servers = this._overrides.servers;
				}
			} else {
				// OAS3 config.apidoc.overrides are not applied.
				// Add a new server for localhost:port with the apiprefix
				// keeping all existing servers
				const basePath = dedupePrefix ? '' : this._prefix;

				const servers = spec.servers || [];

				// If HTTPS is enabled, add it to the server list
				if (this._sslPort) {
					servers.unshift({
						url: `https://localhost:${this._sslPort}${basePath}`
					});
				}

				// If HTTP is enabled, add it to the server list. We decided to put the HTTP server
				// in front of everything else as it works without issues and it is the one we want
				// the users to use(the UI selects the first one by default).
				if (this._port) {
					servers.unshift({
						url: `http://localhost:${this._port}${basePath}`
					});
				}
				spec.servers = servers;
			}
		} else {
			// OAS2
			const { basePath, host, schemes } = this._overrides;

			// replace basePath with our apiPrefix
			// replace host and schemes with local API Builder server
			if (basePath !== undefined) {
				if (basePath === null) {
					delete spec.basePath;
				} else {
					spec.basePath = basePath;
				}
			} else if (!dedupePrefix) {
				spec.basePath = this._prefix;
			} else {
				delete spec.basePath;
			}

			spec.host = `localhost:${this._port}`;
			if (host !== undefined) {
				if (host === null) {
					delete spec.host;
				} else {
					spec.host = host;
				}
			} else if (this._sslPort) {
				// If SSL is enabled, it overrides the http defaults
				spec.host = `localhost:${this._sslPort}`;
			}

			spec.schemes = [ 'http' ];
			if (schemes !== undefined) {
				if (schemes === null) {
					delete spec.schemes;
				} else {
					spec.schemes = schemes;
				}
			} else if (this._sslPort) {
				// If SSL is enabled, it overrides the http defaults
				spec.schemes = [ 'https' ];
			}
		}
		return {
			usePrefix: !dedupePrefix
		};
	}

	/**
	 * Loads one OAS file from the openapi directory.
	 * @returns {object[]} `[{ name, file, triggerTypeId, scope, oas, parsedSpec, usePrefix }]`
	 * @throws {Error} on exception or if there are more than one OAS files
	 */
	async load() {
		const { _logger: logger } = this;
		const files = await getOpenAPIFileNames(this._openapiPath, { logger });
		const specs = [];
		for (const file of files) {
			const name = getBasenameFromFile(file);
			const triggerTypeId = getTriggerTypeId(name);
			const schemaScope = getSchemaScope(name); // oas-ft-greet
			logger.trace('loading:', file);
			const data = await fs.readFile(file);
			const parsedSpec = this.parse(data);
			// tweak the original spec, remove security, adjust host/port, etc.
			logger.trace('tweaking:', file);
			const { usePrefix } = this._tweak(parsedSpec);
			const oas = await loadOAS(parsedSpec, schemaScope);

			// validate
			logger.trace('validating:', file);
			const { warnings, errors } = oas.validate();
			if (warnings.length) {
				warnings.forEach((msg, i) => {
					logger.warn(`Validation item[${i}]:`, msg);
				});
			}
			if (errors.length) {
				errors.forEach((msg, i) => {
					logger.error(`Validation item[${i}]:`, msg);
				});
				throw new Error(`Failed to validate: ${file}`);
			}
			const res = checkSpec(oas, { logger });
			if (res.valid === false) {
				throw new Error(`Failed to validate: ${file}`);
			}
			this._definitionPaths[triggerTypeId] = file;
			specs.push({
				name,
				file,
				triggerTypeId,
				scope: schemaScope,
				oas,
				parsedSpec,
				usePrefix
			});
		}
		return specs;
	}

	parse(data) {
		return YAML.safeLoad(data);
	}

	/**
	 * Saves an OAS document to the apidocs/openapi directory. The
	 * basename of `filename` is used to create a unique identifier,
	 * `triggerTypeId` that links the `filename` to the flow-trigger. If a
	 * previous flow-trigger exists for the `filename` (ignoring the extension),
	 * then an Error will be thrown.
	 * @param {string} doc - The OAS document to save.
	 * @param {string} filename - The OAS file name to save.
	 * @returns {string} The unique `triggerTypeId` identifier for the file.
	 */
	async save(doc, filename) {
		const { _logger: logger } = this;
		await ensureOpenAPIDirectoryExists(this._appDir);
		const _filename = ensureExtension(filename);
		const filePath = await getUniqueFilename(this._openapiPath, _filename);
		logger.trace('saving', filePath);
		await fs.writeFile(filePath, doc);
		const basename = getBasenameFromFile(filePath);
		return getTriggerTypeId(basename);
	}

	/**
	 * Updates an OAS document to the apidocs/openapi directory identified by
	 * the `triggerTypeId`. If a the `triggerTypeId` does not exist, an Error is
	 * thrown. Otherwise, the original file basename will be preserved and
	 * updated with the new `doc` and extension of the `filename`, but the
	 * original `filename` will not be changed.
	 * @param {string} triggerTypeId - The unique identifier.
	 * @param {string} doc - The OpenAPI document to save.
	 * @param {string} filename - The OpenAPI file name to save.
	 * @returns {string} The unique `triggerTypeId` identifier for the file.
	 */
	async update(triggerTypeId, doc, filename) {
		const { _logger: logger } = this;

		const _filename = ensureExtension(filename);
		const filePath = this._definitionPaths[triggerTypeId];
		if (!filePath) {
			const name = getBasenameFromFile(_filename);
			throw new Error(`Cannot update an OpenAPI document that does not exist: ${name}`);
		} else {
			await afs.unlink(filePath);
		}

		const newName = renameExtname(filePath, path.extname(_filename));
		logger.trace('updating', newName);
		await fs.writeFile(newName, doc);
		return triggerTypeId;
	}

	/**
	 * Deletes the currently loaded specification.
	 * @param {string} triggerTypeId - The unique `triggerTypeId` to delete.
	 */
	async delete(triggerTypeId) {
		await fs.unlink(this._definitionPaths[triggerTypeId]);
	}

	/**
	 * Validates an OAS document.  The `doc` can be an object, a path to a file
	 * or a URL.
	 * @param {string|object} doc - The OAS document to load
	 * @returns {object} `{ valid, errors, warnings }`
	 */
	async validate(doc) {
		const { _logger: logger } = this;
		logger.trace('validate', doc);
		try {
			const spec = await loadOAS(doc);
			const { warnings, errors } = spec.validate();
			logger.trace(
				`validated OpenAPI specification with ${warnings.length} warning(s), ${errors.length} error(s)`);
			for (let i = 0; i < warnings.length; ++i) {
				logger.warn(`JSON schema validation warning[${i}]:`, warnings[i]);
			}
			for (let i = 0; i < errors.length; ++i) {
				logger.error(`JSON schema validation error[${i}]:`, errors[i]);
			}
			const res = checkSpec(spec, { logger });
			return {
				valid: !errors.length && res.valid
			};
		} catch (ex) {
			logger.error('Error validating OpenAPI specification', ex);
			return {
				valid: false
			};
		}
	}
}

/**
 * Gets a list of JSON or YAML files from the apidocs/openapi path.
 * @param {String} openapiPath - The path to openapi docs.
 * @param {Object} options - Additional options.
 * @param {Object} options.logger - The logger.
 * @returns {String[]} An array of openapi file names.
 */
async function getOpenAPIFileNames(openapiPath, { logger }) {
	const files = [];
	logger.trace('reading openapi files from:', openapiPath);
	try {
		const names = await fs.readdir(openapiPath);
		logger.trace('found openapi file names:', names);
		for (const name of names) {
			if (!JSON_YAML_EXP.test(name)) {
				continue;
			}
			files.push(path.join(openapiPath, name));
		}
	} catch (ex) {
		if (ex.code !== 'ENOENT') {
			logger.error('Failed to read', openapiPath, ex);
		}
	}
	logger.trace('openapi files:', files);
	return files;
}

/**
 * Ensures the necessary apidocs/openapi directories exist under the app folder.
 *
 * @param {string} appDir - The app directory.
 */
async function ensureOpenAPIDirectoryExists(appDir) {
	let dir = appDir;
	for (const part of [ 'apidocs', 'openapi' ]) {
		dir = path.join(dir, part);
		try {
			// Just try to make the directory
			await fs.mkdir(dir, 0o700);
		} catch (ex) {
			// if it already exists we get EEXIST. Just ignore it, otherwise throw the exception.
			if (ex.code !== 'EEXIST') {
				throw ex;
			}
		}
	}
}

/**
 * Run additional checks on the the `spec`.
 * @param {OAS} spec - The parsed OpenAPI document.
 * @returns {boolean} false if a path parameter is invalid.
 */
function checkSpec(spec, { logger }) {
	let count = 0;
	const link = 'https://expressjs.com/en/guide/routing.html#route-parameters';
	for (const operation of spec.operations) {
		const invalidPathParams = [];
		const method = operation.method;
		const pathName = operation.path;
		for (const parameter of operation.parameters) {
			const res = checkPathParameterName(parameter);
			if (res) {
				invalidPathParams.push(res);
			}
		}
		if (invalidPathParams.length) {
			const msg = `${method.toUpperCase()} ${pathName} contains invalid path parameter name(s)`;
			const names = JSON.stringify(invalidPathParams);
			const err = `${msg} ${names}`;
			logger.error(`Validation item[${count}]:`, `${err}, please see: ${link}.`);
			count++;
		}
	}
	return {
		valid: !count
	};
}

/**
 * Checks the path parameter name only contains characters: `A-Z a-z 0-9 _`.
 * @param {OASParameter} parameter - The parameter object to check.
 * @returns {string} The error message, if invalid, else `undefined`.
 */
function checkPathParameterName(parameter) {
	if (parameter.in === 'path') {
		const name = parameter.name;
		if (name.match(/\W/)) {
			return name;
		}
	}
}

/**
 * Constructs trigger type id. This is an important function that gets the
 * sanitized file name (e.g. user provided name with stripped symbols that would
 * result in invalid trigger id) and concatenates it with the spec type to
 * produce the trigger type id.
 *
 * @param {string} name - sanitized file name.
 * @returns {string} trigger type id.
 */
function getTriggerTypeId(name) {
	return `${SPEC_TYPE}-${name.toLowerCase()}`;
}

/**
 * Replace the OAS file extension.
 * @param {string} filePath - The existing OAS file path.
 * @param {string} ext - The extension of the updating OAS file.
 * @returns {string} The new filePath with changed file extension.
 */
function renameExtname(filePath, ext) {
	const newExt = path.extname(filePath);
	if (newExt !== ext) {
		return path.join(
			path.dirname(filePath),
			`${path.basename(filePath, newExt)}${ext}`
		);
	}
	return filePath;
}

module.exports = SpecManager;
