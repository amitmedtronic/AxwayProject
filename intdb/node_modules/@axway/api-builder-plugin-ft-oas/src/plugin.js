const path = require('path');
const YAML = require('js-yaml');
const oasFnPath = require.resolve('@axway/api-builder-oas-flow-node');
const exportSchema = require('@axway/api-builder-oas-flow-node/src/plugin/exportSchema');
const uriUtils = require('@axway/api-builder-uri-utils');
const { getCreateTrigger } = require('./trigger');
const SpecManager = require('./spec-manager');

async function getPlugin(scopedConfig, { service, logger, appDir }) {
	const oasIcon = path.resolve(path.dirname(oasFnPath), '..', '..', 'openapi.svg');
	logger.trace('loading icon', oasIcon);
	const icon = await uriUtils.iconFileToDataImageURI(oasIcon);

	const specManager = new SpecManager();
	specManager.apiPrefix = service.apiPrefix;
	specManager.appDir = appDir;
	specManager.logger = logger;
	specManager.port = service.port;
	specManager.sslPort = service.sslPort;
	specManager.security = service.security;
	specManager.overrides = service.overrides;

	logger.trace('initializing openapi');
	const specs = await specManager.load();
	if (!specs.length) {
		logger.trace('no spec file to load');
	}

	let schemas = [];
	const triggers = {};
	const openapiSpecs = [];
	for (const { oas, triggerTypeId, scope, parsedSpec, usePrefix, file } of specs) {
		logger.trace('loaded OAS', oas.oasVersion, file);

		const specSchemas = exportSchema(oas, scope, {
			allowUnknownFormats: true
		});
		schemas = schemas.concat(...specSchemas);
		logger.trace('exported', specSchemas.length, 'schema');

		// add a service spec (using tweaked parsedSpec)
		openapiSpecs.push({
			name: oas.title,
			type: 'openapi',
			description: oas.description || '',
			version: oas.version,
			definition: parsedSpec,
			triggerTypeId
		});

		const operationNames = oas.operations.map(a => a.name);

		triggers[triggerTypeId] = {
			name: oas.title,
			description: oas.description || `A flow-trigger for ${oas.title}`,
			icon,
			// NOTE: The `requestSchema` is purely informational
			requestSchema: {
				type: 'object',
				title: 'HTTP request',
				description: 'The HTTP request',
				additionalProperties: false,
				properties: {
					id: {
						type: 'string'
					},
					path: {
						type: 'object'
					},
					query: {
						type: 'object'
					},
					headers: {
						type: 'object'
					},
					cookies: {
						type: 'object'
					},
					body: {}
				},
				required: [ 'id', 'path', 'query', 'headers', 'cookies' ]
			},
			triggerParameters: {
				type: 'object',
				properties: {
					method: {
						type: 'string',
						title: 'API method',
						description: 'The API method as defined in the OAS spec.',
						enum: operationNames
					},
					lowerCaseAllHeaders: {
						type: 'string',
						title: 'Lower-case all headers',
						description: 'Enabling this option with "true" forces all headers in `$.request.headers`, including OpenAPI parameters names, to be lower-case when the flow is invoked. When disabled with "false", OpenAPI header parameters names will be written to `$.request.headers` with the original case of the parameter name.',
						default: 'false',
						enum: [
							'false',
							'true'
						]
					},
					flattenParams: {
						type: 'string',
						title: 'Flatten parameters',
						description: 'When enabled, all OpenAPI parameters will be accessible by name from $.request.params. If any parameter names clash, the last parameter defined in the OpenAPI specification will take priority over any previously defined parameter.',
						default: 'false',
						enum: [
							'false',
							'true'
						]
					},
					convertDateStringToObject: {
						type: 'string',
						title: 'Parse date parameters',
						description: 'Convert date strings to Date object when specification parameters or body are of type string with format date or date-time.',
						default: 'false',
						enum: [
							'false',
							'true'
						]
					},
					requestValidationMode: {
						type: 'string',
						title: 'Request validation',
						description: 'This option controls what happens when a request fails to validate. When this is "warn", a warning message will be logged to the console, but processing will continue. If the value is "error", then an error will be sent to the client. Required body and parameters are always enforced.',
						default: 'error',
						enum: [
							'error',
							'warn'
						]
					},
					responseValidationMode: {
						type: 'string',
						title: 'Response validation',
						description: 'This option controls what happens when a response from the flow does not match the OpenAPI specification. When this is "warn", warning messages will be logged to the console, but processing will continue. If the value is "error", then a generic error will be sent to the client and the problem will be logged to the console. "disabled" can result in a significant performance improvement.',
						default: 'error',
						enum: [
							'error',
							'warn',
							'disabled'
						]
					}
				},
				required: [ 'method' ],
				additionalProperties: false
			},
			createTrigger: getCreateTrigger({
				apiPrefix: usePrefix ? service.apiPrefix : '',
				oas,
				specSchemas
			})
		};
	}

	return {
		triggers,
		schema: schemas,
		apiSpecs: {
			openapi: {
				name: 'OpenAPI',
				specs: openapiSpecs,
				// To be used for improved UX on import in UI
				fileTypes: [
					'.yaml',
					'.yml',
					'.json'
				],
				validate: async (spec) => {
					const parsedSpec = specManager.parse(spec);
					const { valid } = await specManager.validate(parsedSpec);
					return {
						// parsedSpec is passed into UI for rendering
						parsedSpec,
						valid
					};
				},
				save: (spec, { filename }) => {
					return specManager.save(spec, filename);
				},
				update: (triggerTypeId, spec, { filename }) => {
					return specManager.update(triggerTypeId, spec, filename);
				},
				delete: (triggerTypeId) => {
					return specManager.delete(triggerTypeId);
				},
				serve: ({ triggerTypeId, config, pathManager }) => {
					const specInfo = specs.find(a => a.triggerTypeId === triggerTypeId);
					const spec = specInfo.parsedSpec;
					const jsonSpec = JSON.stringify(spec);
					const yamlSpec = YAML.safeDump(spec);

					// Would use specInfo.oas.oasVersion but we threw away everything except the
					// major version information so we can't use it. When we add 3.1 support we
					// should fix this.
					// const specificationVersion	= spec.swagger || spec.openapi;

					function sendJSON(req, resp) {
						resp.set('content-type', 'application/json; charset=utf-8');
						resp.status(200).send(jsonSpec);
					}
					function sendYAML(req, resp) {
						resp.set('content-type', 'text/yaml; charset=utf-8');
						resp.status(200).send(yamlSpec);
					}

					const links = [];
					const { name } = specInfo;

					const jsondoc = `${config.prefix}/openapi/${name}.json`;
					pathManager.bindPath('get', jsondoc, { cb: sendJSON });

					// now we want to expose more info but this is a breaking change since
					// it requires a higher minimum api builder version.
					links.push(jsondoc);
					// links.push({
					// 	url: jsondoc,
					// 	mimeType: 'application/json',
					// 	specificationVersion
					// });

					const yamldoc = `${config.prefix}/openapi/${name}.yaml`;
					pathManager.bindPath('get', yamldoc, { cb: sendYAML });

					// We want to expose more info but this is a breaking change since
					// it requires a higher minimum api builder version.
					links.push(yamldoc);
					// links.push({
					// 	url: yamldoc,
					// 	mimeType: 'text/yaml',
					// 	specificationVersion
					// });

					return links;
				},
				getOperationId: (triggerParameters) => {
					return triggerParameters.method;
				}
			}
		}
	};
}

module.exports = {
	getPlugin
};
