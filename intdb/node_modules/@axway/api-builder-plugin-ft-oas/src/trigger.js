const extract = require('./extract');
const SchemaManager = require('./schema-manager');
const Validator = require('./validator');
const response = require('./response');
const { getResponses, getAllResponseHeaders } = require('./operation');

/**
 * Gets a trigger factory function e.g. createTrigger.
 * @param {Object} options - Trigger options.
 * @param {String} options.apiPrefix - The apiPrefix that may come from API
 * Builder config, or can be an empty string if we chose to dedupe the basePath
 * when tweaking.
 * @param {OAS} options.oas - The OAS spec from @axway/api-builder-oas-flow-node.
 * @param {Object} options.specSchemas - The schemas exported from the spec.
 * @returns {function} A function used to create a trigger instance.
 */
function getCreateTrigger({ apiPrefix, oas, specSchemas }) {
	// createTrigger
	return async (triggerInfo, { logger, pathManager }) => ({
		async start(startInvoke) {
			const schemaManager = new SchemaManager();
			schemaManager.addSchemas(specSchemas);
			schemaManager.logger = logger;
			const validator = new Validator();
			validator.setSchemaManager(schemaManager);

			const {
				method,
				lowerCaseAllHeaders,
				flattenParams,
				convertDateStringToObject,
				requestValidationMode = 'error',
				responseValidationMode = 'error'
			} = triggerInfo.parameters;

			const errorOnInvalidRequest = requestValidationMode === 'error';
			const op = oas.operations.find(operation => operation.name === method);
			if (!op) {
				const names = oas.operations.map(a => a.name);
				logger.trace(
					`failed to find operationId "${triggerInfo.parameters.method}" in [${names}]`);
				throw new Error(`failed to find op: ${triggerInfo.parameters.method}`);
			}

			// Create a more useful map to replace the op.responses array
			// REFACTOR: the original op.responses should probably be this map format so we don't
			// have to restructure it here and can just pass around "op".
			const responses = getResponses(op);

			pathManager.bindOpenAPIPath(op.method, apiPrefix + op.path, {
				headers: getAllResponseHeaders(op),
				cb: (req, res) => {
					logger.trace('Starting invoke for request', req.method, req.path);
					// REFACTOR: consider using the async interface for startInvoke
					// for these types of triggers so we don't have to worry about
					// splitting up the response into a different area of code and
					// passing around req/res.
					const data = {
						req,
						res,
						op,
						validator,
						schemaManager,
						lowerCaseAllHeaders: lowerCaseAllHeaders === 'true',
						flattenParams: flattenParams === 'true',
						convertDateStringToObject: convertDateStringToObject === 'true',
						responses,
						errorOnInvalidRequest,
						responseValidationMode
					};
					startInvoke(data, {
						requestId: req.getId()
					});
				}
			});
		},
		async destroy() {}, // TODO?
		onInvoke
	});
}

/**
 * The `onInvoke` handler.
 *
 * @param {Object} options - options.
 * @param {Object} options.logger - The logger.
 * @param {function} options.invoke - The API Builder runtime function for
 * invoking a flow.
 * @param {Object} options.data - The data context created when the trigger
 * calls `startInvoke`.
 * @returns {Object} the execution flow
 */
async function onInvoke({ logger, invoke, data }) {
	const {
		req,
		res,
		op,
		validator,
		schemaManager,
		lowerCaseAllHeaders,
		flattenParams,
		convertDateStringToObject,
		errorOnInvalidRequest
	} = data;

	const requestId = req.getId();
	try {
		const params = await extract.params(op, req, {
			logger,
			validator,
			schemaManager,
			lowerCaseAllHeaders,
			flattenParams,
			convertDateStringToObject,
			errorOnInvalidRequest
		});
		if (params.errors.length) {
			return sendBadRequest(
				res,
				'Failed to validate request',
				params.errors,
				requestId,
				logger
			);
		}

		const bodyInfo = extract.body(req, { logger });
		if (bodyInfo.errors.length) {
			return sendBadRequest(
				res,
				'Invalid request',
				bodyInfo.errors,
				requestId,
				logger
			);
		}
		const result = validator.validateBody(op, bodyInfo, {
			logger,
			convertDateStringToObject,
			errorOnInvalidRequest
		});
		if (!result.valid) {
			return sendBadRequest(
				res,
				'Failed to validate body',
				result.errors,
				requestId,
				logger
			);
		}
		// This is the object we pass to the Flow. We want to ensure that
		// we pass in the "raw" request headers and the extracted request
		// headers that were converted to something usable by the schema.
		// We do not want to blat over the converted ones.
		const request = {
			...params.converted,
			headers: {
				...filterHeaders(req.headers, params.converted.headers),
				...params.converted.headers
			},
			body: bodyInfo.withFiles(result.coercedBody),
			id: requestId
		};
		if (flattenParams) {
			bodyInfo.flattenParameters(op, result.coercedBody, request);
		}

		const flowResponse = await invoke(request);
		logger.trace('Finished invoking flow, response:', flowResponse);

		response.handleResponse(logger, data, flowResponse);

	} catch (ex) {
		res.status(500).send({
			success: false,
			code: 500,
			'request-id': requestId,
			message: 'Internal Server Error'
		});
		// Let API Builder handle logging the error and "Finished"
		throw ex;
	}
}

/**
 * Note that we might have the same header represented in both - request headers
 * and converted headers. This function ensures that those are not added twice
 * to the combined array.
 * @param {Object} headers - the headers from the request.
 * @param {Object} convertedHeaders - the headers from the spec with coerced values.
 * @returns {Object} an object that contains the unique set of headers, removing the
 * duplicates.
 */
function filterHeaders(headers, convertedHeaders) {
	const headersLowerCased = Object.keys(convertedHeaders).map(b => {
		return b.toLowerCase();
	});
	return Object.keys(headers).reduce(
		(filteredHeaders, header) => {
			if (!headersLowerCased.includes(header)) {
				filteredHeaders[header] = headers[header];
			}
			return filteredHeaders;
		}, {}
	);
}

/**
 * Sends a JSON formatted 400 bad request.
 *
 * @param {Object} res - HTTP response object.
 * @param {string} message - The error message.
 * @param {string[]} errors - An array of errors.
 * @param {sting} requestId - The request id.
 * @param {Object} logger - The scoped trigger logger.
 */
function sendBadRequest(res, message, errors, requestId, logger) {
	logger.debug(message, errors);
	const response = JSON.stringify({
		success: false,
		code: 400,
		'request-id': requestId,
		message,
		errors
	});

	res.header('content-type', 'application/json')
		.status(400)
		.send(response);
}

module.exports = {
	getCreateTrigger,
	onInvoke
};
