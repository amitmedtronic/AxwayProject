const oasStyle = require('@axway/api-builder-oas-style');

/**
 * Validator class is used to validate client requests data against the exposed
 * service specification. It is used to validate bodies, parameters, and
 * responses.
 */
class Validator {
	constructor() {
		this._validators = {};
	}

	/**
	 * Sets an Ajv instance to use during validation.
	 * @param {SchemaManager} schemaManager - The schema manager instance.
	 */
	setSchemaManager(schemaManager) {
		this._schemaManager = schemaManager;
	}

	/**
	 * Validates the body.
	 *
	 * @param {OASOperation} op - the spec object that represents operation.
	 * @param {Object} bodyInfo - contains the extracted body data
	 * @param {Object} options - the options.
	 * @param {Object} options.logger - the logger
	 * @param {boolean} options.convertDateStringToObject - flag that denotes
	 * should we convert string date to Date object.
	 * @param {boolean} options.errorOnInvalidRequest - flag that denotes do we
	 * return 500 on invalid request or not. It is also used to decide about log
	 * level. When false we log at warn otherwise at debug level.
	 * @returns {Object} the result from the validation - true or false - and the
	 * errors. It returns empty errors array if validation succeeded.
	 */
	validateBody(op, bodyInfo, {
		logger,
		convertDateStringToObject,
		errorOnInvalidRequest
	}) {
		const result = {
			valid: true,
			errors: []
		};

		if (!op.requestBody) {
			// If the client sends a body, but the spec does not define one,
			// then this is an error. It is equivalent to when the spec defines
			// a body with content-type, and the client send an unexpected
			// content-type.
			if (bodyInfo.hasContentBody()) {
				result.errors.push('unexpected body');
				result.valid = false;
			}
			return result;
		}

		const required = !!op.requestBody.required;
		if (!bodyInfo.hasBodyToValidate()) {
			if (required) {
				result.errors.push('body is required');
				result.valid = false;
				return result;
			} else {
				logger.trace('no body to validate');
				return result;
			}
		}

		// validate body
		const { contentType, body } = bodyInfo;
		// REFACTOR: this `getMediaTypeSchema` should be moved to the new
		// SchemaManager, and ideally, Coercer should move to the trigger.
		const schemaInfo = this._getMediaTypeSchema(op.requestBody, {
			contentType,
			errors: result.errors,
			logger
		});
		logger.trace('schema info', schemaInfo);
		result.valid = schemaInfo.valid;
		if (schemaInfo.valid) {
			const schema = schemaInfo.schema;
			const coercer = new Coercer(body, contentType, logger);
			const needsCoercion = coercer.needsCoercion();

			if (needsCoercion) {
				try {
					// Coercion works with dereferenced schema. Note that we do
					// not want to dereference earlier than this point because
					// validation of draft 6 schema works only with references.
					const derefedSchema = this._schemaManager.dereference(schema);
					result.coercedBody = coercer.coerce(derefedSchema);

					// Date conversion should happen after validation so we need
					// to coerce second time when the flag is on and use the value
					// later.
					if (convertDateStringToObject) {
						result.coercedConvertedBody
							= coercer.coerce(derefedSchema, convertDateStringToObject);
					}
				} catch (ex) {
					logger.debug(ex);
					result.valid = false;
					result.errors.push(ex.message);
					return result;
				}
			}

			if (this._needsValidation(contentType)) {
				// The value to be validated
				const value = needsCoercion
					? bodyInfo.withFilesToValidate(result.coercedBody)
					: body;

				// it is not possible to tweak exported schema, so if `schema`
				// contains $ref to files, and they contain constraints, then
				// there is not a lot we can do.
				const tweakedSchema = bodyInfo.tweakSchemaWithFiles(schema);

				result.valid = this._validate(
					tweakedSchema,
					value,
					{
						type: 'request body',
						errors: result.errors,
						logger,
						failureLogLevel: errorOnInvalidRequest ? 'debug' : 'warn'
					}
				);
				if (!result.valid) {
					const message = `Failed to validate "${contentType}" body`;
					if (errorOnInvalidRequest) {
						result.errors.unshift(message);
					} else {
						result.errors = [];
						result.valid = true;
					}
				}
			}
			// We do coerce only when specific conditions are met. Those
			// conditions are the same on which we wnat to do Date conversion so
			// the flag `needsCoercion` is kind of reused. See `coercer.needsCoercion()`
			// for details.
			if (convertDateStringToObject && needsCoercion) {
				// Validation has happened so we need to use the converted bodies
				// after this point.
				result.coercedBody = result.coercedConvertedBody;
			}
		}

		return result;
	}

	/**
	 * Validates the parameters.
	 *
	 * @param {Object} param - the spec object that represents parameter.
	 * @param {Object} value - contains the extracted parameter value.
	 * @param {Object} options - the options.
	 * @param {Object} options.logger - the logger
	 * @param {boolean} options.errorOnInvalidRequest - flag that denotes do we
	 * return 500 on invalid request or not. It is also used to decide about log
	 * level. When false we log at warn otherwise at debug level.
	 * @returns {Object} the result from the validation - true or false - and the
	 * errors. It returns empty errors array if validation succeeded.
	 */
	validateParam(param, value, { logger, errorOnInvalidRequest }) {
		const result = {
			valid: true,
			errors: []
		};
		/* istanbul ignore else */
		if (param.schema) {
			logger.trace(
				`validating param "${param.in}.${param.name}"`,
				'against schema:',
				param.schema
			);
			result.valid = this._validate(
				param.schema,
				value,
				{
					type: 'parameter',
					paramName: param.name,
					paramIn: param.in,
					errors: result.errors,
					logger,
					failureLogLevel: errorOnInvalidRequest ? 'debug' : 'warn'
				}
			);
		} /*
			// TODO: https://jira.axway.com/browse/RDPP-7149
			// TODO: remove "istanbul ignore else" above
			// implement param.content[contentType]
			else if (param.content) {
			// const schemaInfo = this._getMediaTypeSchema(
			// 	param,
			// 	{ errors: result.errors, logger }
			// );
			// result.valid = schemaInfo.valid;
			// if (schemaInfo.valid) {
			// 	const validateInfo = this._validate(schemaInfo.schema, value, logger);
			// 	result.valid = validateInfo.valid;
			}
		} */

		return result;
	}

	/**
	 * Validates the response body.
	 *
	 * @param {Object} response - The response metadata from response.js
	 * @param {Object} options - The options.
	 * @param {Object} options.logger - The logger.
	 * @throws if the response body does not match the spec
	 */
	validateResponseBody(response, { logger }) {
		const { specContentTypes, isRawBody, specResponse, contentType } = response;

		if (response.body === undefined) {
			// Our OAS abstraction ensures that this list will only contain content-types for
			// possible payloads. In OAS2, responses without a schema will be considered to NOT have
			// a payload and their "produces" will not be included in this list.
			if (specContentTypes.all.length) {
				throw new Error('Response body is missing but is documented as required for this operation');
			}
			// Don't try to do any further validation
			return;
		}

		const isJSONContent = contentType && contentType.json;
		if (isJSONContent) {
			// validate the body as JSON
			let parsedBody;

			try {
				// Ensure that the body is encoded as JSON. We want to ensure that we are
				// validating the JSON payload and not the original javascript object since they
				// can differ.
				// Store the encoded body to avoid having to encode it again later.
				response.encodedBody = isRawBody ? response.body : JSON.stringify(response.body);
				// Parse the raw body as a JSON object. This doubles as validating that the
				// data is syntactically valid.
				parsedBody = JSON.parse(response.encodedBody);
			} catch (err) {
				throw new Error('Response body is not valid JSON');
			}

			const { matchedContentType } = response;
			if (!matchedContentType) {
				// If we got this far and there's no matchedContentType then there's
				// nothing we can validate. This can happen if response validation is
				// "warn", otherwise it would have thrown when failing to match a content-type.
				return;
			}

			// FIXME: RDPP-7183. We need to pick a valid content-type which may not match
			// the type exactly (wildcards, parameters).
			const mediaTypeObject = specResponse.content[matchedContentType];
			if (mediaTypeObject.schema) {
				const errors = [];
				const valid = this._validate(
					mediaTypeObject.schema,
					parsedBody,
					{
						type: 'response body',
						errors,
						logger
					}
				);

				if (!valid) {
					throw new Error(`Response body failed to validate against the "${matchedContentType}" schema for this operation: ${errors.join(', ')}`);
				}
			}
		}
	}

	/**
	 * Validates the responses status.
	 *
	 * @param {Object} response - The response metadata from response.js
	 * @throws if the status does not match the spec
	 */
	validateResponseStatus(response) {
		const { status, specResponse, specResponses } = response;
		// If we have a response for the status (including default or wildcard) then continue
		if (specResponse) {
			return;
		}

		// There must match at least one valid code or wildcard defined in the response.
		const validCodes = Object.keys(specResponses).join(', ');
		throw new Error(`Response HTTP status "${status}" is not documented for this operation. Expected one of ${validCodes}`);
	}

	/**
	 * Validates the response headers including content-type.
	 *
	 * @param {Object} response - The response metadata from response.js
	 * @throws if the response headers do not match the spec
	 */
	validateResponseHeaders(response) {
		const { headers, specHeaders } = response;

		// check if all headers are defined in the spec
		for (const header in headers) {
			// content-type is not defined in "headers" and the validation is handled elsewhere.
			if (header === 'content-type') {
				continue;
			}

			if (!specHeaders[header]) {
				const names = Object.keys(specHeaders);
				const additionalMsg = names.length ? `. Expected one of ${names.join(', ')}` : '';
				throw new Error(`Response header "${header}" is not documented for this operation${additionalMsg}`);
			}
		}

		// Check if a required header is missing from the response
		for (const header in specHeaders) {
			const spec = specHeaders[header];
			if (spec.required && !(header in headers)) {
				throw new Error(`Response header "${header}" is documented as required for this operation`);
			}
		}
	}

	/**
	 * Validates the response content-type.
	 * @param {Object} response - The response metadata from response.js
	 * @returns {string} the matched content-type from the spec or undefined.
	 * @throws if the content-type does not match the spec
	 */
	validateResponseContentType(response) {
		const { headers, specContentTypes, oasVersion, contentType } = response;
		// Check if the content-type is documented for this operation.
		// FIXME: RDPP-7183 There's a lot wrong with this. The content-types may have
		// wildcards and/or parameters like charset so it needs to be smarter.
		if (!specContentTypes.all.includes(contentType.type)) {
			let additionalMsg = specContentTypes.all.length
				? `. Expected one of ${specContentTypes.all.join(', ')}` : '';
			if (oasVersion === '2') {
				additionalMsg += '. This response may not document a schema, or may not document any "produces" mime-types';
			}
			const contentType = headers['content-type'];
			throw new Error(`Response Content-Type "${contentType}" is not documented for this operation${additionalMsg}`);
		}
		// FIXME: when we fix the code above, this needs to be the exact content key from the spec.
		return contentType.type;
	}

	/**
	 * Returns `true` if the `contentType` matches one of the types that can be
	 * parsed and/or validated.
	 * @param {string} contentType - The `content-type` header (minus options).
	 * @returns {boolean} `true` if the `contentType` can be validated.
	 */
	_needsValidation(contentType) {
		if (contentType.match(/^application\/(.*\+)?json$/)
			|| contentType === 'text/plain'
			|| contentType === 'application/x-www-form-urlencoded'
			|| contentType === 'multipart/form-data'
		) {
			return true;
		}
		return false;
	}

	/**
	 * This method handles MediaTypeObject (e.g. content property) for body,
	 * parameter and response.
	 * https://github.com/OAI/OpenAPI-Specification/blob/main/versions/3.0.0.md#mediaTypeObject
	 *
	 * @param {Object} componentSpec - the spec for requestBody, parameter or
	 * response.
	 * @param {Object} options - the options.
	 * @param {string} options.contentType - the contentType to select.
	 * @param {Object} options.errors - collection where errors are aggregated.
	 * @param {Object} options.logger - the logger.
	 * @returns {Object} response contains the following properties:
	 * valid - true if the media type object can be identified.
	 * schema - the associated schema with the media type object.
	 */
	_getMediaTypeSchema(componentSpec, { contentType, errors, logger }) {
		// TODO: mediaTypeObject selection would be more complex when wildcards
		// are implemented - https://jira.axway.com/browse/RDPP-7183
		const mediaTypeObject = componentSpec.content[contentType];
		const expectedMediaTypes = Object.keys(componentSpec.content).join(',');
		if (!mediaTypeObject) {
			const message
				= `Not an expected content-type: "${contentType}", expected: ${expectedMediaTypes}`;
			logger.trace(message);
			errors.push(message);
			return { valid: false };
		}
		// TODO: add support for mediaTypeObject.encoding
		// https://jira.axway.com/browse/RDPP-7184
		return {
			valid: true,
			schema: mediaTypeObject.schema || {}
		};
	}

	_validate(schema, value, {
		// failureLogLevel defaults to "debug" because it is not provided
		// during response validation.
		paramIn, paramName, type, errors, logger, failureLogLevel = 'debug'
	}) {
		logger.trace('validating', type, 'value', value);
		logger.trace('validating', type, 'against schema:', schema);
		// This is to optimize for memory
		const key = JSON.stringify(schema);
		if (!this._validators[key]) {
			logger.trace('adding validator for schema:', schema);
			// REFACTOR: The just-in-time schema compilation hides production issues.
			// For example if we use the wrong ajv version problems with the
			// schema will not be detected until a specific API is hit.
			this._validators[key] = this._schemaManager.ajv.compile(schema);
		}
		const validate = this._validators[key];
		const valid = validate(value);
		if (validate.errors) {
			for (const error of validate.errors) {
				if (type === 'parameter') {
					const message = [
						'Failed to validate',
						paramIn,
						'parameter',
						`"${paramName}",`
					];
					const msg = formatAjvError(error, message);
					errors.push(msg);
					logger[failureLogLevel](msg, error);
				} else {
					// body
					const msg = formatAjvError(error);
					errors.push(msg);
					logger[failureLogLevel](`failed to validate ${type}:`, msg, error);
				}
			}
		}
		return valid;
	}

}

/**
 * Formats an Ajv error.
 * @param {object} error - The Ajv error to format.
 * @param {string []} [message=[]] - An array of message parts that will be
 * prefixed before the Ajv error.
 * @returns {string} A formatted error message
 */
function formatAjvError(error, message = []) {
	error.dataPath && message.push(error.dataPath);
	message.push(error.message);
	// add allowed values for better error
	if (error.params && error.params.allowedValues) {
		message.push(JSON.stringify(error.params.allowedValues));
	}
	return message.join(' ');
}

class Coercer {
	/**
	 * Creates a coercer.
	 * @param {Object} body - Contains client data.
	 * @param {string} contentType - The content-type.
	 * @param {Object} logger - The logger.
	 */
	constructor(body, contentType, logger) {
		this.body = body;
		this.contentType = contentType;
		this.logger = logger;
	}

	/**
	 * Tests if `body` can be coerced based on `contentType`.
	 * @returns {boolean} `true` if the body can be coerced.
	 */
	needsCoercion() {
		const { body, contentType } = this;
		if (body instanceof Buffer || body === undefined) {
			return false;
		} else if (
			contentType === 'text/plain'
			|| contentType === 'application/x-www-form-urlencoded'
			|| contentType === 'multipart/form-data') {
			return true;
		}
		return false;
	}

	/**
	 * Coerces the `body` to a value described by `schema`.
	 * @param {Object} schema - A JSON schema.
	 * @param {boolean} convertDateStringToObject - Flag to denote do we convert to Date or not.
	 * @returns {*} The coerced `body`.
	 */
	coerce(schema, convertDateStringToObject) {
		const { contentType, logger } = this;
		let { body } = this;
		logger.trace('coercing form body using schema:', schema);
		let style;
		let explode;
		if (contentType === 'text/plain') {
			style = 'simple';
			explode = false;
		} else if (contentType === 'multipart/form-data') {
			style = 'deepObject';
			explode = false;
			// do a naive/simple convert of the object to be key: value.
			// probably needs work, and we need to handle whatever
			// `body-parser` is going to throw at us.
			const value = {};
			for (const key in body) {
				value[key] = body[key].value;
			}
			body = value;
		} else {
			// contentType === 'application/x-www-form-urlencoded'
			// typeof body === 'object'
			style = 'deepObject';
			explode = false;
		}
		// Note that `oasStyle.decode` can potentially throw errors but should
		// be safe enough with the styles above.  However, if that changes, then
		// these exceptions will need to be caught.
		const coerced = oasStyle.decode(body, {
			name: 'body',
			style,
			explode,
			schema
		}, undefined, { coerceDate: convertDateStringToObject });
		logger.trace('coerced form body (excluding files):', coerced.body);
		return coerced.body;
	}
}

module.exports = Validator;
