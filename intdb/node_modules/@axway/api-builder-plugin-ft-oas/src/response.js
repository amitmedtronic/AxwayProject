const utils = require('./utils');

/**
 * Handles sending a response returned from the flow.
 * Validation errors before execution, or internal server errors during execution are handled
 * in trigger.js (onInvoke)
 * @param {object} logger - the logger
 * @param {Object} data - The data context created when the trigger calls `startInvoke`.
 * @param {object} flowResponse - response from the flow
 * @param {number} flowResponse.status - the http status to send
 * @param {*} [flowResponse.body] - the http body to send
 * @param {object} [flowResponse.headers] - the http headers to send.
 * @throws any thrown exceptions will result in a 500 server error.
 */
function handleResponse(logger, data, flowResponse) {
	const { res, validator, responseValidationMode } = data;
	const response = getResponse(flowResponse, data);

	const validationOptions = { logger, responseValidationMode };

	validateResponse('Status', response, validator, validationOptions);
	validateResponse('Headers', response, validator, validationOptions);

	// Validate or ensure a content-type is set from the spec if sending a body
	validateContentType(response, validator, validationOptions);

	// Validate the body after matching a content-type from the spec
	validateResponse('Body', response, validator, validationOptions);

	const body = encodeBody(response);

	// set the status
	logger.trace('setting status code', response.status);
	res.status(response.status);

	// set the headers
	for (const header in response.headers) {
		logger.trace('setting header', header, response.headers[header]);
		res.set(header, response.headers[header]);
	}

	// send the response with optional body
	if (body !== undefined) {
		res.send(body);
	} else {
		res.end();
	}
}

/**
 * Normalises the response from the flow and pre-calculates metadata for subsequent logic.
 * @param {object} flowResponse - the response from the flow
 * @param {object} data - the data passed to startInvoke
 * @returns {object} response data object
 * @throws If the flow response is syntactically invalid
 */
function getResponse(flowResponse = {}, data) {
	const { body, status } = flowResponse;
	// Response syntax validation
	if (!Number.isInteger(status) || status < 100 || status > 599) {
		throw new Error('The flow did not respond with a valid HTTP status code between 100 and 599');
	}

	// Pick the response with the closest match for the returned status code.
	const specResponse = data.responses[status]
		|| data.responses[`${`${status}`.charAt(0)}XX`]
		|| data.responses.default;

	// Normalise headers by setting them to lowercase
	const headers = Object.keys(flowResponse.headers || {})
		.reduce((prev, next) => {
			prev[next.toLowerCase()] = flowResponse.headers[next];
			return prev;
		}, {});

	let contentType;
	if (headers['content-type']) {
		try {
			// parse the content-type to validate and remove charset.
			contentType = utils.parseContentType(headers['content-type']);
		} catch (err) {
			throw new Error(`Response Content-Type ${headers['content-type']} is not valid`);
		}
	}

	return {
		headers,
		status,
		body,
		oasVersion: data.op._oasVersion,
		isRawBody: typeof body === 'string' || Buffer.isBuffer(body),
		contentType,
		// Will be undefined if no response is defined
		specResponse,
		specHeaders: (specResponse && specResponse.headers) || {},
		specContentTypes: specResponse && specResponse.contentTypeMetadata || {
			all: [],
			json: [],
			parsed: {}
		},
		// set by validateContentType after ensuring a content-type
		matchedContentType: undefined,
		specResponses: data.responses
	};
}

/**
 * Validator or pick a content-type for the response. If a content-type is valid
 * and matches one defined in the spec, we set the match on response for use when
 * validating the body.
 * @param {object} response - response metadata returned from getResponse
 * @param {object} validator - validator class
 * @param {object} options - validator options
 * @param {object} options.logger - the logger
 * @param {object} options.responseValidationMode - response validation mode (error|warn|disabled)
 */
function validateContentType(response, validator, options) {
	let contentType;
	if (response.headers['content-type']) {
		contentType = validateResponse('ContentType', response, validator, options);
	} else {
		// Get content-type smartly. Returns a picked content-type or undefined if not picking.
		// May throw and result in 500 if a sensible content-type cannot be picked.
		contentType = pickContentType(response, options.logger);
		if (contentType) {
			// If pickContentType picks a content-type then set it and log.
			options.logger.debug('Automatically setting content-type header to', contentType);
			response.contentType = utils.parseContentType(contentType);
			response.headers['content-type'] = contentType;
		}
	}
	// matchedContentType should always be the exact key from the spec
	response.matchedContentType = contentType;
}

/**
 * Controls the configured "response validation" behavior by wrapping the validator
 * function.
 * @param {string} type - the type of validation. 'Body', 'Status', 'Headers' or 'ContentType'
 * @param {object} response - response metadata returned from getResponse
 * @param {object} validator - validator class
 * @param {object} options - validator options
 * @param {object} options.logger - the logger
 * @param {object} options.responseValidationMode - response validation mode (error|warn|disabled)
 * @returns {*} the result of the validation function
 */
function validateResponse(type, response, validator, options) {
	const { logger, responseValidationMode } = options;
	const validationFunction = `validateResponse${type}`;
	logger.trace(validationFunction, 'at level:', responseValidationMode);

	// Skip validation if the user disabled response validation
	if (responseValidationMode === 'disabled') {
		return;
	}

	try {
		return validator[validationFunction](response, options);
	} catch (err) {
		// Log the error message and continue if the user set response validation to warn
		if (responseValidationMode === 'warn') {
			logger.warn(err.message);
			return;
		}

		// Otherwise, throw the error and stop further processing
		throw err;
	}
}

/**
 * Can automatically pick a content-type from the spec based on the body format and optionally
 * also encode the body based on the available content-types.
 * content-type is picked based on the status code returned from the flow.
 * If content-type is provided by the flow we do not attempt to change it or modify the body.
 * @param {object} response - response metadata returned from getResponse
 * @param {object} logger - Logger
 * @returns {string} the "contentType" from the spec, if we pick one.
 */
function pickContentType(response, logger) {
	const { body, status, specContentTypes, oasVersion, isRawBody } = response;

	// If the user didn't set a body, then don't pick a content-type.
	if (body === undefined) {
		return;
	}

	// Get the content types for the status code returned, or fall back to default if the status
	// is not defined. Otherwise there's no content types.
	logger.trace(`Response content types documented for ${status} are: ${specContentTypes.all}`);

	if (!specContentTypes.all.length) {
		let additionalMsg = '';
		if (oasVersion === '2') {
			additionalMsg = '. This response may not document a schema, or may not document any "produces" mime-types';
		}
		throw new Error(`Cannot automatically set a content-type header. No response content-types are documented for this operation${additionalMsg}`);
	}

	// Try to determine the content-type to send from the spec based on the body,
	// and optionally encode the body. If the spec defines multiple content-types
	// then it's too ambiguous to pick one and it will result in a 500 error.
	if (isRawBody) {
		if (specContentTypes.all.length > 1) {
			// Content-type is ambiguous so can't choose one. Must be set in the flow.
			const types = specContentTypes.all.join(', ');
			throw new Error(`Cannot automatically set a content-type header. You must explicitly set a content-type header in the flow. Should be one of ${types}`);
		}

		// There's only one documented content-type so choose that.
		return specContentTypes.all[0];
	}

	// If the body isn't "raw", we will attempt to determine if it's suitable to be JSON.
	// We only support JSON, so if the spec documents a single JSON response type, we
	// pick it. All other cases result in a 500 and require the user to be more explicit
	// and provide a content-type or pre-encode the body themselves.

	if (!specContentTypes.json.length) {
		let specificType = '';
		if (specContentTypes.all.length === 1) {
			specificType = ` as ${specContentTypes.all[0]}`;
		}
		throw new Error(`Cannot encode ${typeof body} HTTP response body${specificType}. The flow must return a string or buffer`);
	}

	if (specContentTypes.json.length > 1) {
		const types = specContentTypes.json.join(', ');
		throw new Error(`Cannot automatically set a content-type header. You must explicitly set a content-type header in the flow. Should be one of ${types}`);
	}

	// There's only one documented JSON content-type so pick that.
	return specContentTypes.json[0];
}

/**
 * Encodes the body so it can be sent in the response
 * @param {object} response - response metadata returned from getResponse
 * @returns {*} Encoded response body
 * @throws If response body will not, or can not be encoded as JSON
 */
function encodeBody(response) {
	const { body, encodedBody, contentType, isRawBody } = response;

	// if we pre-encoded the body earlier on, use that to avoid doing it again.
	if (encodedBody) {
		return encodedBody;
	}

	if (!isRawBody && body !== undefined) {
		const isJSONContent = contentType && contentType.json;
		if (!isJSONContent) {
			throw new Error('Response body must be a buffer or a utf-8 encoded string unless using a JSON content-type');
		}

		// We only try to encode the body as JSON if the content-type is JSON-like
		return JSON.stringify(body);
	}

	return body;
}

module.exports = {
	handleResponse
};
