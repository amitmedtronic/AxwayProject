/**
 * @module axway-schema
 * @typicalname axway-schema
 * @exports axway-schema
 *
 * @example <caption>Quick start</caption>
 * ```javascript
 *  const schemas = require('axway-schema');
 *  schemas.add('./schemas/foo.json')
 *	  .add('./schemas/bar.json', 'schema://myservice/bar')
 *	  .add('./schemas/swagger-v2.0.json')
 *	  .loadSync();
 *  schemas.get('schema:///foo');
 *  schemas.validate('schema:///foo', foo);
 *  schemas.get('schema:///foo/myservice/bar');
 *  schemas.validate('schema:///foo/myservice/bar', bar);
 *  schemas.get('http://swagger.io/v2/schema.json#');
 *  schemas.validate('http://swagger.io/v2/schema.json#', swagger);
 *  schemas.dereference(swagger);
 *  schemas.dereference(swagger, { target: '#/definitions' });
 *  schemas.dereference(swagger, { target: '#/definitions', rename: (id) => { return 'foo'; } });
 * ```
 */
const fs = require('fs');
const path = require('path');
const Ajv = require('ajv');
const jsonpointer = require('@axway/json-pointer');
const jsonrefs = require('@axway/json-refs');
const URI = require('uri-js');
const encodeURIComponentRFC3986 = require('strict-uri-encode');
const draft04schema = require('ajv/lib/refs/json-schema-draft-04.json');
const draft06schema = require('ajv/lib/refs/json-schema-draft-06.json');

const MAX_RECURSION_DEPTH = 10;

// These are formats that are supported specifically for flow-node
// parameters, although we can't conditionally validate using these
// in some cases and not in others without creating multiple schema
// registries (multiple ajvs), so they're known formats for any schema
// that we register in axway-schema for now.
const knownFormats = [ 'multiline', 'mustache', 'xml', 'javascript' ];
// No custom validation logic for these formats - always treat them as valid.
const formatValidationFn = () => true;

/**
 * @private
 */
class Singleton {
	static declare(key, Clazz) {
		const globalSymbols = Object.getOwnPropertySymbols(global);
		const symbol = Symbol.for(key);
		const exists = (globalSymbols.indexOf(symbol) > -1);
		// no dupes
		if (!exists) {
			global[symbol] = new Clazz();
		}
		Object.defineProperty(Clazz, 'instance', {
			get: () => {
				return global[symbol];
			}
		});
		Object.freeze(Clazz);
	}

	static get(key) {
		const globalSymbols = Object.getOwnPropertySymbols(global);
		const symbol = Symbol.for(key);
		const exists = (globalSymbols.indexOf(symbol) > -1);
		// no dupes
		if (!exists) {
			throw new Error(`failed to find singleton: ${key}`);
		}
		return global[symbol];
	}
}

/**
 * A schema manager.
 * @public
 * @class
 */
class AxwaySchema {
	/**
	 * Constructs a schema manager.  The instance is a singleton.
	 * @public
	 */
	constructor() {
		this.scheme = 'schema://';
		this.global = [];
		this.clear();
	}

	/**
	 * Sets the Logger
	 * @param {Logger} logger - A logger.
	 * @public
	 */
	setLogger(logger) {
		this.logger = logger;
	}

	/**
	 * Adds an item to be loaded later by calling
	 * [loadSync]{@link #module_axway-schema..AxwaySchema+loadSync}.
	 * The `item` can be a `string`, in which case it is a schema file, and an optional `defaultId`
	 * will be used for the `id` if the file does not have an `id`.  If the file does not have an
	 * `id` and no `defaultId` is supplied, the function will throw.
	 *
	 * If the `item` is an object, it is a valid schema that has an `id` defined so that
	 * it can be referenced later.  In this case, `defaultId` is ignored.
	 *
	 * @example <caption>Add a schema</caption>
	 * ```javascript
	 *  const schemas = new AxwaySchema();
	 *  schemas.add('./schema1.json');
	 *  schemas.add('./schema2.json', 'schema://service/myapp/schema2.json');
	 *  schemas.add({id: 'http://axway.com/schemas/user.json'});
	 * ```
	 *
	 * @param {string|object} item - The item to add (a filename or schema).
	 * @param {string} [defaultId] - The item id if one not supplied.
	 * @return {AxwaySchema} The {@link AxwaySchema} object.
	 * @public
	 */
	add(item, defaultId) {
		const type = typeof item;
		// object schema
		if (type === 'object') {
			if (!item.id || item.id === 'schema:///') {
				throw new Error('schema that are added directly require an id so that it can be referenced later');
			} else if (item.id.startsWith('schema://') && !item.id.startsWith('schema:///')) {
				throw new Error(`schema that are added directly require an id that has no host: ${item.id}`);
			}
			this.items.push({ schema: item });
			return this;
		} else if (type !== 'string') {
			throw new TypeError('item must be a string or object');
		}
		// string (file)
		const stats = fs.statSync(item);
		if (stats.isFile()) {
			this.items.push({
				defaultId,
				path: item
			});
		} else {
			throw new Error(`not a file: '${item}'`);
		}
		return this;
	}

	/**
	 * Registers a global schema that will persist across calls to
	 * [clear]{@link #module_axway-schema..AxwaySchema+clear} operations.  Schemas registered with
	 * the same `id` will generate a warning but will be ignored.
	 *
	 * @param {object} schema - The schema.
	 * @return {AxwaySchema} The {@link AxwaySchema} object.
	 */
	register(schema) {
		const type = typeof(schema);
		// array
		if (type === 'object' && schema instanceof Array) {
			schema.forEach(item => this.register(item));
			return this;
		}

		if (type !== 'object') {
			throw TypeError('invalid parameter: schema');
		}
		const exists = this.global.find(a => a.id === schema.id);
		if (exists) {
			this.logger && this.logger.warn(`a schema already exists with this id: ${schema.id}`);
			return this;
		}
		this.global.push(schema);
		return this;
	}

	/**
	 * Loads all schemas previously added with calls to
	 * [add]{@link #module_axway-schema..AxwaySchema+add}.
	 *
	 * @example <caption>Load schemas</caption>
	 * ```javascript
	 *  const schemas = new AxwaySchema();
	 *  schemas
	 *	  .add('./schema1.json');
	 *	  .add('./schema2.json', 'service');
	 *	  .loadSync());
	 * ```
	 *
	 * @return {AxwaySchema} The {@link AxwaySchema} object.
	 * @public
	 */
	loadSync() {
		// reload global schemas if not already loaded
		let schemas = [];
		if (this.global.length) {
			schemas = schemas.concat(
				// ajv will store the id as lower-case
				this.global.filter(a => !this.ids.hasOwnProperty(a.id))
			);
		}

		this.items.forEach(item => {
			let schema;
			if (item.schema) {
				schema = JSON.parse(JSON.stringify(item.schema));
			} else {
				schema = this._loadSchemaFile(item.path, item.defaultId);
			}
			schemas.push(schema);
		});

		if (schemas.length) {
			this.logger && this.logger.debug(`loading ${schemas.length} schema`);
			// every schema will have an `id` when adding, otherwise there is no point in
			// it - it will be inaccessible.
			this.ajv.addSchema(schemas);
			// record all ids
			schemas.forEach(schema => {
				this.logger && this.logger.debug(`loaded: ${schema.id}`);
				this.ids[schema.id] = true;
			});
		} else {
			this.logger && this.logger.trace('no schemas to load');
		}
		// reset items to be loaded (this is faster than: `items = []`)
		// https://jsperf.com/array-destroy
		this.items.length = 0;
		return this;
	}

	/**
	 * Create a logger for AJV which uses our API Builder logger rather
	 * than the console.
	 * Will ignore any "unknown format" warnings that are printed out.
	 * @private
	 * @returns {object} Logger suitable for AJV
	 */
	_getAJVLogger() {
		return {
			log: (...params) => {
				this.logger && this.logger.info(...params);
			},
			warn: (...params) => {
				this.logger && this.logger.warn(...params);
			},
			error: (...params) => {
				this.logger && this.logger.error(...params);
			}
		};
	}

	/**
	 * Clears all schemas and resets state.  All registered schema will be
	 * automatically re-added on next load.
	 *
	 * @public
	 * @return {AxwaySchema} The {@link AxwaySchema} object.
	 */
	clear() {
		// axway schema treats schemas as draft-06 by default.
		// We do have support for registering and validating against
		// schemas which define themselves as draft 4 and draft 7
		this.ajv = new Ajv({
			unknownFormats: 'ignore',
			logger: this._getAJVLogger(),
			schemaId: 'auto'
		});
		this.ajv.addMetaSchema(draft04schema);
		this.ajv.addMetaSchema(draft06schema);
		for (const format of knownFormats) {
			this.ajv.addFormat(format, formatValidationFn);
		}
		this.ajv._opts.defaultMeta = draft06schema.$id;
		this.items = [];
		this.ids = {};
		return this;
	}

	/**
	 * Tests whether or not a schema is loaded, identified by `id`.
	 *
	 * @param {string} id - The schema identifier to test.
	 * @return {boolean} True if the schema exists.
	 * @public
	 */
	exists(id) {
		try {
			const schema = this.get(id);
			return !!schema;
		} catch (err) {
			// Existing schema can throw errors if there are issues with them.
			// We don't care about the error in this particular function, but log it anyway.
			this.logger && this.logger.trace(
				`Error while getting schema ${id}. Assuming it does exist`, err
			);
			return true;
		}
	}

	/**
	 * Gets a schema by `id`.  If `id` is not supplied, all schemas are returned.
	 *
	 * @param {string} [id] - The schema identifier.
	 * @return {object} Returns a schema identified by `id`.
	 * @public
	 */
	get(id) {
		this._ensureLoaded();
		try {
			// the object returned by `getSchema` is a function but it also has a
			// `schema` property. To avoid confusion, just return the schema.
			if (id) {
				const schema = this.ajv.getSchema(id);
				return schema && schema.schema;
			}
			return Object.keys(this.ids).map(sid => {
				return this.ajv.getSchema(sid).schema;
			});
		} catch (err) {
			// Errors can be thrown by AJV if the schema has references that cannot
			// be resolved. This isn't handled when the schema is registered.

			// id may be undefined if we're getting all schemas
			this.logger && this.logger.trace(
				`Error getting schema ${id || ''} ${err.message}`
			);
			// Errors thrown by ajv aren't very nice and don't have a stack
			// so add one and then rethrow the error
			err.stack = new Error(err.message).stack;
			throw err;
		}
	}

	/**
	 * Validates an object `obj` against a schema previously added with
	 * [add]{@link #module_axway-schema..AxwaySchema+add} or
	 * [register]{@link #module_axway-schema..AxwaySchema+register}
	 * and identified by `id`, or if `id` is a JSON schema object, `obj` is validated
	 * against that.
	 *
	 * @param {string|object} id - The schema identifier or object.
	 * @param {*} obj - The object to validate.
	 * @return {string} Returns an error string when not valid, undefined otherwise.
	 * @public
	 */
	validate(id, obj) {
		this._ensureLoaded();
		let validate;
		if (!obj || typeof (obj) !== 'object') {
			throw TypeError('invalid parameter: obj');
		}
		if (typeof (id) === 'string') {
			validate = this.ajv.getSchema(id);
			if (!validate) {
				throw Error(`schema not loaded: ${id}`);
			}
		} else if (id && typeof (id) === 'object') {
			try {
				validate = this.ajv.compile(id);
			} catch (err) {
				throw Error(`failed to compile schema: ${err}`);
			}
		} else {
			throw TypeError('invalid parameter: id');
		}
		const valid = validate(obj);
		if (!valid) {
			const name = (typeof (id) === 'object') ? '[object]' : path.basename(id);
			return this.getErrorString(validate.errors, name);
		}
	}

	_doderef(opts) {
		const {
			newdoc,
			target,
			rename,
			ref,
			refpath,
			derefed,
			allrefs,
			parentUri
		} = opts;

		// Note: We might want to check 'target' in the future to ensure that it
		// at least starts with '#'. We don't even know that it's a valid
		// pointer URI.

		if (!ref || !ref.uri) {
			throw new Error(`schema uri does not exist: ${refpath}`);
		}

		// It is possible for schema A to reference B, and for B to reference A.  In this
		// case, when A is dereferenced, it will write a new $ref to B, which is normal,
		// except that B references A, which can cause an infinite loop.  To avoid that,
		// check to see that when we process B, see if A has already been dereferenced and
		// if so, update B to use the existing, expanded reference.
		if (allrefs.hasOwnProperty(ref.uri)) {
			this._updateRef(newdoc, ref, refpath, allrefs[ref.uri]);
			return;
		}
		this.logger && this.logger.trace(`dereferencing ref ${ref.uri} for ${refpath}`);

		// AH (needs research). Untested and cannot reproduce. Either get a stack
		// overflow (if i have a self-referencing schema) or it works fine if i have
		// schemas 11 deep (max is 10);
		if (opts.depth > MAX_RECURSION_DEPTH) {
			throw new Error(`Exceeded maximum recursion depth of ${MAX_RECURSION_DEPTH}`);
		}

		// Check the reference. If it is a reference to an item in the same
		// document, then fetch the schema from Ajv, combining the local
		// fragment with the main URI of the parent document. Usually we have
		// local references on recursive calls when we have reference within a
		// reference.
		const localRef = ref.type === 'local';
		const uri = localRef
			? URI.serialize(Object.assign(
				{}, parentUri, { fragment: ref.uriDetails.fragment }
			))
			: ref.uri;
		const schema = this.get(uri);
		if (!schema) {
			const msg = localRef
				? `sub-schema does not exist: ${uri}`
				: `schema does not exist: ${uri}`;
			throw new Error(msg);
		}

		// Swagger does not like `id` and `$schema`, so remove them.
		const curatedSchema = JSON.parse(JSON.stringify(schema));
		delete curatedSchema.id;
		delete curatedSchema.$schema;
		if (!target) {
			// Inline dereference
			const reftarget = refpath.substring(1);
			if (!reftarget) {
				// if the refpath is `#` then this should become root /,
				// which is just replacing the whole object.

				// The following line has been commented after adding oneOf.
				// It is going to be done properly in RDPP-5606.
				// this.logger && this.logger.warn('inline deref at root /');
				Object.assign(newdoc, curatedSchema);
				delete newdoc.$ref;
			} else {
				// The following line has been commented after adding oneOf.
				// It is going to be done properly in in RDPP-5606.
				// this.logger && this.logger.warn(`inline deref at ${reftarget} when
				// dereferencing ${ref.uri}`);
				jsonpointer.set(newdoc, reftarget, curatedSchema);
			}
			derefed[ref.uri] = refpath;
		} else {
			// 1. Massage Definition Name

			// The `uri` is an RFC-3986 encoded URI-reference. The name might be
			// URL encoded and might be escaped according to JSON Pointer spec
			// (https://tools.ietf.org/html/rfc6901), so these need to be undone
			// to get a clean resource name. For example, our Endpoints are
			// valid Swagger files and their references are already escaped.
			const name = decodeURIComponent(jsonpointer.unescape(
				rename ? rename(uri) : path.basename(ref.uri, '.json')
			));
			// Build a JSON pointer compliant `name` where the slash "/" and
			// tilde "~" are escaped for re-use later.
			const escName = jsonpointer.escape(name);

			// 2. Update Definitions

			// Define the `target` (e.g. "#/definitions") and strip off '#'
			// because we need a JSON pointer, not a URI fragment.
			const updateTargetPtr = target.substring(1);

			// Define the entity to update within `target` by their name
			// (escaped because it is a JSON pointer).  E.g. if `name` is
			// "part1~part2", then use "part1~0part2".
			const updateTargetByNamePtr = `${updateTargetPtr}/${escName}`;
			if (jsonpointer.has(newdoc, updateTargetByNamePtr)) {
				// if `derefed` contains the `ref.uri`, then it was dereferenced
				// already in the same `refs` pass in `newdoc` (but the $ref
				// itself needs to be dereferenced). however, if `derefed` does
				// already contain the `ref.uri`, then it is being dereferenced
				// multiple times in one pass of the document, and should warn.
				if (this.logger && !derefed.hasOwnProperty(ref.uri)) {
					this.logger.warn(
						`updated existing data at ${updateTargetPtr}/${name} when dereferencing ${ref.uri}`);
				}
			} else {
				jsonpointer.set(newdoc, updateTargetByNamePtr, curatedSchema);
			}

			// 3. Update References

			// If the reference is local find it in the
			// target document and rewrite the $ref to the new target location.
			// If the reference type is remote, then change the reference to a
			// local one. The refs should be URI encoded.
			const encodedRef
				= `${target}/${encodeURIComponentRFC3986(escName)}`;

			this._updateRef(newdoc, ref, refpath, encodedRef);

			// Store deref to not hit infinite loop
			derefed[ref.uri] = encodedRef;
		}

		// Some schema have local definitions. E.g. our flow-schema references
		// #/definitions/node of the same schema. Those local definitions also
		// need to be recursively expanded into the target document.
		const subrefs = jsonrefs.findRefs(schema, { filter: [ 'local' ] });
		Object.keys(subrefs).forEach(subrefpath => this._doderef({
			newdoc,
			target,
			rename,
			ref: subrefs[subrefpath],
			refpath: subrefpath,
			parentUri: opts.parentUri || ref.uriDetails,
			derefed,
			allrefs,
			depth: opts.depth + 1
		}));
	}

	/**
	 * Updates the reference with its encoded equivalent.
	 *
	 * @param {Object} doc - the doc to be updated
	 * @param {Object} ref - reference details
	 * @param {string} refpath - the path to be replaced
	 * @param {string} encodedRef - the new path
	 */
	_updateRef(doc, ref, refpath, encodedRef) {
		if (ref.type === 'local') {
			const existingRefs = jsonrefs.findRefs(doc, {
				filter: eref => {
					return eref.uri === ref.def.$ref;
				}
			});
			Object.keys(existingRefs).forEach(eref => {
				existingRefs[eref].def.$ref = encodedRef;
			});
		} else {
			jsonpointer.set(
				doc, refpath.substring(1), { $ref: encodedRef }
			);
		}
	}

	/**
	 * Callback function to rename a target when used as a
	 * [dereference]{@link #module_axway-schema..AxwaySchema+dereference} target.
	 * For example, if your id is "schema://svc.foo/bar", then `bar` will be written
	 * to the dereference target as `bar`.  If you want to rename `bar`, then use
	 * this function.
	 * @public
	 * @callback targetRenameCallback
	 * @param {id} id - The schema id.
	 * @return {string} Return the renamed target.
	 */

	/**
	 * Dereferences non-local references in the supplied document.  The supplied
	 * document is not modified.  All non-local references (e.g `schema://`) will
	 * be replaced with the corresponding loaded schema.  If schema are not found,
	 * an error will be thrown.
	 *
	 * If `options.target` is not supplied, then references are expanded inline.  If
	 * `options.target` is supplied, then references are expanded in the location specified
	 * by `options.target` and any existing reference updated to point to the new target.
	 * For example, if the `options.target` is `#/definitions`, then the schema will be
	 * expanded to `$.definitions` with the name of the schema the trailing component
	 * (basename) of its `id`, or if `options.rename` is supplied, the name
	 * returned by that.
	 *
	 * @param {object} doc - A document
	 * @param {object} [options] - Options
	 * @param {string} [options.target] - A target
	 * @param {targetRenameCallback} [options.rename] - A callback to rename schema
	 * @return {object} Returns a document with `schema://` references expanded.
	 * @public
	 */
	dereference(doc, options) {
		this._ensureLoaded();
		if (!doc || typeof doc !== 'object') {
			throw TypeError('invalid parameter: doc');
		}
		if (options && typeof options !== 'object') {
			throw TypeError('invalid parameter: options');
		}
		const newdoc = JSON.parse(JSON.stringify(doc)); // deep copy
		let complete = false;
		const allrefs = {};
		// for every $ref identified, get the schema for it and replace it in `newdoc`, either by
		// replacing it inline, or if `target` is supplied, expanding it into the target location
		// and updating the $ref to point to the new target location.
		do {
			// filter and dereference all remote refs that are not local to the doc
			// (i.e. 'schema:///'). while `findRefs` does not resolve circulars, this is a loop, and
			// and each iteration of the loop can update `newdoc` with more remote refs, so we need
			// to prevent our own circular references. the `derefed` holds all the references that
			// were dereferenced for this loop, whereas `allrefs` hold all the references for the
			// doc since the start. this is important because we want to detect circulars in the
			// whole doc, but in the loop, it should be possible to dereference the same reference
			// multiple times as necessary.
			const refs = jsonrefs.findRefs(newdoc, { filter: [ 'remote' ] });
			const paths = Object.keys(refs);
			const target = options && options.target;
			const rename = options && options.rename;
			complete = !paths.length;
			const derefed = {};
			for (const refpath of paths) {
				this._doderef({
					newdoc,
					target,
					rename,
					ref: refs[refpath],
					refpath,
					derefed,
					allrefs,
					depth: 0
				});
			}
			Object.assign(allrefs, derefed);
		} while (!complete);
		return newdoc;
	}

	/**
	 * The ajv.errorsText is actually not very good.
	 *
	 * @param {array} errors - ajv errors object
	 * @param {string} objectType - The name of the object type that was validated
	 * @return {string} A formatted error string.
	 * @public
	 */
	getErrorString(errors, objectType) {
		return errors.map(err => {
			const dataPath = err.dataPath ? `$${err.dataPath}` : `${objectType} root`;
			return `at schema ${err.schemaPath}, ${dataPath} ${err.message} (${JSON.stringify(err.params)})`;
		}).join('. ');
	}

	/**
	 * Ensures [loadSync]{@link #module_axway-schema..AxwaySchema+loadSync} was called after
	 * [add]{@link #module_axway-schema..AxwaySchema+add} - throws if not loaded.
	 *
	 * @private
	 */
	_ensureLoaded() {
		if (this.items.length) {
			throw new Error('call `loadSync` to finish adding items.');
		}
	}

	/**
	 * Loads a schema from file.
	 * @param {string} fpath - The file path to load.
	 * @param {string} [defaultId] - An optional default id the schema.
	 * @return {object} A parsed JSON schema file.
	 * @private
	 */
	_loadSchemaFile(fpath, defaultId) {
		const contents = fs.readFileSync(fpath, 'utf8');
		const parsed = JSON.parse(contents);
		if (!parsed.id) {
			parsed.id = defaultId;
			if (!defaultId) {
				throw new Error(`schema id must be defined: ${fpath}`);
			}
		}
		this.logger && this.logger.trace(`loaded schema file: ${fpath} with id ${parsed.id}`);
		return parsed;
	}
}

Singleton.declare('axway-schema-singleton', AxwaySchema);

module.exports = Singleton.get('axway-schema-singleton');
