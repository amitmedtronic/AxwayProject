const fs = require('fs');
const util = require('util');
const path = require('path');
const http = require('http');
const EventEmitter = require('events');

const afs = {
	readdir: util.promisify(fs.readdir),
	writeFile: util.promisify(fs.writeFile)
};

function statusMessage(code) {
	return http.STATUS_CODES[String(code)];
}

/**
 * Makes a directory if it does not exist - async version.
 * @param {string} dir - The directory name.
 * @returns {Promise} the Promise that will be resolved/rejected on dir
 * creation.
 */
function mkdirIfNotExistsAsync(dir) {
	return new Promise((resolve, reject) => {
		fs.stat(dir, (err, stats) => {
			if (err) {
				if (err.code === 'ENOENT') {
					fs.mkdir(dir, 0o700, err => {
						if (err) {
							return reject(err);
						}
						resolve();
					});
				} else {
					reject(err);
				}
			} else if (!stats.isDirectory()) {
				reject(new Error(`${dir} is not a directory.`));
			} else {
				resolve();
			}
		});
	});
}

/**
 * Makes a directory if it does not exist.
 * @param {string} dir - The directory name.
 * @param {function} next - callback
 */
function mkdirIfNotExists(dir, next) {
	mkdirIfNotExistsAsync(dir).then(next, next);
}

/**
 * Makes a safe filename from `name`.
 * @param {string} name - the name of the file
 * @returns {string} the path to the file with a safe filename
 */
function safeFilename(name) {
	const camelCaseName = name.toLowerCase()
		.replace(/(?:\s)[a-z]/g, (match) => {
			return match.toUpperCase().trim();
		});
	const traversal = path.relative(path.sep, path.join(path.sep, camelCaseName));
	const safe = traversal.replace(/[/,?,<,>,\\,:,*,|,",',., ]/g, '');
	return path.relative(path.sep, path.join(path.sep, safe));
}

/**
 * Checks that `name` is a safe filename.  A filename is considered safe if it
 * doesn't contain any of the OS reserved characters.
 *
 * This function has no relationship with `safeFilename`.
 * @param {string} name - the name of the file
 * @returns {boolean} if the name is a safe file name
 */
function isSafeFilename(name) {
	return name.match(/[/?<>\\:*|"'.]/g) === null;
}

/**
 * Writes an object to a file at a given path
 *
 * @param {string} fn - file path
 * @param {object} data - object to stringify and write to file
 * @param {function} cb - callback
 */
function writeFile(fn, data, cb) {
	const opts = {
		flag: 'w',
		encoding: 'utf-8',
		mode: 0o644
	};

	fs.writeFile(fn, data, opts, cb);
}

/**
 * Returns an unique filename based on the existing files in the destination
 * directory. Only files with json|yaml|yml extensions are considered.
 * If a file already exist with that name, the filename will be incremented
 * and appended until a file no longer exist with that filename:
 * e.g. myFile1, myFile2, etc.
 *
 * @param {string} dir - The directory to check the filename against.
 * @param {string} name - The base filename, without extension, that is going
 * to be used as base for the unique name generated.
 * @throws {Error} - re-throws any fs.readdir errors.
 * @returns {string} A unique filename.
 */
async function getUniqueFilename(dir, name) {
	// This can throw
	const files = await afs.readdir(dir);

	let count = 0;
	let fileExists = true;
	let filename;
	while (fileExists) {
		filename = count ? `${name}${count}` : name;
		const re = new RegExp(`${filename}\\.(json|yaml|yml)$`);
		if (!files.filter(a => a.match(re)).length) {
			fileExists = false;
		} else {
			count += 1;
		}
	}

	return filename;
}

/**
 * Writes a file to disk.  If a file already exists at the specified location,
 * the file group name will be incremented and appended to the name, e.g.
 * name.1.json, name.2.json, etc.
 *
 * @param {string} dir - directory to write to
 * @param {string} name - filename
 * @param {string} ext - filename extension
 * @param {Object} data - encoded data to write to file
 * @returns {String} The full filename(including the path) we wrote to on disk.
 */
async function writeUniqueFile(dir, name, ext, data) {
	const uniqueFilename = await getUniqueFilename(dir, name);
	const fn = path.join(dir, `${uniqueFilename}.${ext}`);

	await afs.writeFile(fn, data, {
		flag: 'w',
		encoding: 'utf-8',
		mode: 0o644
	});

	return fn;
}

const arrowQueryOptions = [{
	in: 'query',
	name: 'limit',
	description: 'The number of records to fetch. The value must be greater than 0, and no greater than 1000.',
	required: false,
	type: 'number',
	minimum: 0,
	maximum: 1000
},
{
	in: 'query',
	name: 'skip',
	description: 'The number of records to skip. The value must not be less than 0.',
	required: false,
	type: 'number',
	minimum: 0
},
{
	in: 'query',
	name: 'where',
	description: 'Constrains values for fields. The value should be encoded JSON.',
	required: false,
	type: 'string',
	format: 'json'
},
{
	in: 'query',
	name: 'order',
	description: 'A dictionary of one or more fields specifying sorting of results. In general, you can sort based on any predefined field that you can query using the where operator, as well as on custom fields. The value should be encoded JSON.',
	required: false,
	type: 'string',
	format: 'json'
},
{
	in: 'query',
	name: 'sel',
	description: 'A JSON encoded dictionary of key-value pairs describing which fields to include in the query results. The field name is the key and the value is set to 1.',
	required: false,
	type: 'string',
	format: 'json'
},
{
	in: 'query',
	name: 'unsel',
	description: 'A dictionary of key-value pairs describing which fields to exclude in the query results. The field name is the key and the value is set to 1.',
	required: false,
	type: 'string',
	format: 'json'
}];

const arrowQueryParameter = arrowQueryOptions.reduce((acc, cur) => {
	acc[cur.name] = {
		type: cur.type,
		description: cur.description,
		default: cur.default
	};
	return acc;
}, {});

// Keep the pending requests outside the global scope
class ConcurrencyMiddleware {
	constructor() {
		this.pending = {};
	}

	getMiddleware(swagger, verb, endpoint) {
		return (req, res, next) => {
			const key = `${verb}:${endpoint}`;

			if (this.pending[key]) {
				return res.status(503).send('Cannot make concurrent requests to this API');
			}

			const method = swagger.paths[endpoint] && swagger.paths[endpoint][verb];
			if (method && method.tags && method.tags.includes('reloads')) {
				res.on('finish', () => {
					delete this.pending[key];
				});

				this.pending[key] = true;
			}
			next();
		};
	}
}

/**
 * Throttle an event emitter.
 */
class ThrottledEmitter extends EventEmitter {
	/**
	 * Create an event throttle.
	 * @param {string} event - The event to throttle.
	 * @param {number} [timeout=500] - The timeout.
	 */
	constructor(event, timeout = 500) {
		super();
		this.event = event;
		this.timeout = timeout;
		this._items = [];
	}

	/**
	 * Flushes the events.  The timer will reset.
	 */
	flush() {
		if (this._items.length) {
			this.emit(this.event, this._items);
		}
		this._items = [];
	}

	/**
	 * Stops the event timer if it has started.
	 */
	stop() {
		if (this._tid) {
			clearInterval(this._tid);
			this._tid = null;
		}
		this.flush();
	}

	/**
	 * Starts the event timer if not already started.
	 */
	start() {
		if (!this._tid) {
			this._tid = setInterval(() => this.flush(), this.timeout);
		}
	}

	/**
	 * Pushes data on to the queue.  It will be flushed after `timeout`.  If the
	 * event timer is not started, it will be started.
	 * @param {*} data - The data to queue.
	 */
	push(data) {
		this._items.push(data);
		if (!this._tid) {
			this.start();
		}
	}
}

module.exports = {
	statusMessage,
	mkdirIfNotExists,
	mkdirIfNotExistsAsync,
	safeFilename,
	isSafeFilename,
	getUniqueFilename,
	arrowQueryOptions,
	arrowQueryParameter,
	writeFile,
	writeUniqueFile,
	ConcurrencyMiddleware,
	ThrottledEmitter
};
