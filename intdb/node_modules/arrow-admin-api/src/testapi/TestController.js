const requester = require('@axway/requester');
const urljoin = require('url-join');
const qs = require('qs');
const WrappedResponse = require('./WrappedResponse');

class TestController {
	constructor(ctx) {
		this.ctx = ctx;
	}

	formatAPIUrl(wrappedRequest) {
		// Format the url
		let path = wrappedRequest.path;

		// Format the path params
		const pathParams = (wrappedRequest.params && wrappedRequest.params.path) || {};
		if (Object.keys(pathParams).length > 0) {
			path = path.replace(/:\w+\?*/g,
				(param) => {
					let optional = false;
					let name = param.substring(1);
					if (name[name.length - 1] === '?') {
						name = name.substring(0, name.length - 1);
						optional = true;
					}

					const value = pathParams[name] !== undefined
						&& pathParams[name] !== null ? pathParams[name] : '';

					if (!optional && !value) {
						throw new Error(`${name} required.`);
					}
					return value;
				}
			);
		}

		// Remove duplicate and trailing slashes
		path = path.replace(/\/{2,}/g, '/').replace(/\/$/g, '');

		// Format the query string
		const queryParams = (wrappedRequest.params && wrappedRequest.params.query) || {};
		if (Object.keys(queryParams).length > 0) {
			// Omit empty params
			Object.keys(queryParams)
				.filter((key) => (queryParams[key] === undefined || queryParams[key] === null || queryParams[key] === ''))
				.forEach(key => { delete queryParams[key]; });
			path = urljoin(path, `?${qs.stringify(queryParams)}`);
		}

		// Connect to local apibuilder
		return `http://127.0.0.1:${this.ctx.apibuilder.port}${path}`;
	}

	async testApi(httpOptions, options, resolve) {
		const ts = Date.now();

		// Make the request
		const response = await requester.request(httpOptions, options);
		const duration = Date.now() - ts;

		let { body } = response;
		if (Buffer.isBuffer(body)) {
			body = body.toString();
		}
		// allow the auth plugin to handle the response too and potentially change it
		if (this.ctx.apibuilder.authStrategy) {
			body = this.ctx.apibuilder.authStrategy.applyResponseForTest(response, body);
		}

		const responseFields = {
			httpVersion: response.httpVersion,
			headers: response.headers,
			url: response.url,
			statusCode: response.status
		};

		resolve(new WrappedResponse({
			success: true,
			response: responseFields,
			result: body,
			responseTime: duration,
			responseSize: (response.headers['content-length']) || 0
		}));
	}

	invoke(wrappedRequest, headers) {
		const { logger } = this.ctx.apibuilder;

		return new Promise(async (resolve) => {
			// Verify the API exists
			const api = this.ctx.apibuilder.getAPI(wrappedRequest.path, wrappedRequest.method);

			if (!api) {
				logger.error(`No api found for ${wrappedRequest.method} ${wrappedRequest.path}`);
				resolve(new WrappedResponse({
					success: false,
					response: {
						statusCode: 400
					},
					responseTime: 0
				}));
				return;
			}
			let url;
			try {
				url = this.formatAPIUrl(wrappedRequest);

				const httpOptions = {
					method: wrappedRequest.method || 'GET',
					url,
					headers: {
						cookie: headers.cookie
					}
				};

				// Pass the request body as a buffer so that the requester does
				// not re-encode it.
				if (wrappedRequest.params && wrappedRequest.params.body) {
					httpOptions.body = Buffer.from(wrappedRequest.params.body);
				}

				// Configure the request settings
				const requestOptions = {
					// FIXME: where do these wrappedRequest options exist?
					followRedirects: !!wrappedRequest.followRedirect
				};

				// Configure the headers
				if (wrappedRequest.headers) {
					Object.keys(wrappedRequest.headers).forEach(name => {
						httpOptions.headers[name] = wrappedRequest.headers[name];
					});
				}
				httpOptions.headers['Content-Type']
					= httpOptions.headers['Content-Type'] || 'application/json';
				httpOptions.headers['User-Agent']
					= httpOptions.headers['User-Agent'] || 'API Builder Tester/1.0';

				// Add our authentication as required by the authentication plugin
				if (this.ctx.apibuilder.authStrategy) {
					const applyOptions = { ...httpOptions };
					this.ctx.apibuilder.authStrategy.applyCredentialsForTest(applyOptions);
					if (applyOptions.auth) {
						// need to normalize all headers because they are case
						// sensitive.
						const headers = {};
						for (const name in applyOptions.headers) {
							const value = applyOptions.headers[name];
							// undefined header values can cause problems
							if (value !== undefined) {
								headers[name.toLowerCase()] = applyOptions.headers[name];
							}
						}
						applyOptions.headers = headers;

						const user = applyOptions.auth.username || applyOptions.auth.user || '';
						const pass = applyOptions.auth.password || applyOptions.auth.pass || '';
						const { bearer } = applyOptions.auth;
						if (user || pass) {
							// node http client will base64 for us, but seems
							// to conflict with `nock`, so do it manually
							httpOptions.headers.authorization
								= 'Basic ' + Buffer.from(`${user}:${pass}`).toString('base64');
						} else if (bearer) {
							applyOptions.headers.authorization = `Bearer ${bearer}`;
						}
					}
					httpOptions.headers = {
						...httpOptions.headers,
						...applyOptions.headers
					};
				}

				// Make the request & resolve the promise
				await this.testApi(httpOptions, requestOptions, resolve);
			} catch (err) {
				logger.error('Failed test API:', err);
				resolve(new WrappedResponse({
					success: false,
					response: {
						statusCode: 400
					},
					result: err.message,
					responseSize: 0,
					responseTime: 0
				}));
				return;
			}
		});
	}
}

module.exports = TestController;
