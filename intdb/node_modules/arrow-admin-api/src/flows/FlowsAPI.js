const strictUriEncode = require('strict-uri-encode');
const APIProvider = require('../APIProvider');
const {
	getUniqueFilename,
	mkdirIfNotExistsAsync
} = require('../util');

// https://techweb.axway.com/jira/browse/RDPP-2086
// FIXME: Swagger 2.0 only supports a limited subset of JSON schema draft 04.
// See: https://github.com/OAI/OpenAPI-Specification/blob/master/versions/2.0.md#schema-object
// This means that it is not possible to represent our flow schema in a Swagger 2.0
// document because we use things like (oneOf, allOf).  The only choice here is to
// upgrade to use Swagger 3.0, which allegedly supports them
// See: https://blog.readme.io/an-example-filled-guide-to-swagger-3-2/#formatchanges
// When fixed, replace with:
const flowSchema = {
	// $ref: 'http://axway.com/schemas/flowschema.json#/flow-schema'
	type: 'object'
};

const flowsSummariesSchema = {
	type: 'array',
	items: {
		properties: {
			flowId: {
				type: 'string'
			},
			status: {
				type: 'string'
			},
			name: {
				type: 'string'
			},
			description: {
				type: 'string'
			},
			labels: {
				type: 'array',
				items: {
					type: 'string'
				}
			}
		},
		required: [
			'flowId',
			'status',
			'name',
			'labels'
		],
		additionalProperties: false
	}
};

const triggerDetailsSchema = {
	type: 'object',
	properties: {
		triggers: {
			type: 'array',
			items: {
				properties: {
					type: {
						type: 'string'
					},
					icon: {
						type: 'string'
					},
					id: {
						type: 'string'
					},
					enabled: {
						type: 'boolean'
					},
					flowId: {
						type: 'string'
					},
					status: {
						type: 'object',
						properties: {
							state: {
								type: 'string'
							},
							details: {
								type: 'string'
							}
						}
					},
					description: {
						type: 'string'
					},
					instanceDescription: {
						type: 'string'
					},
					typeName: {
						type: 'string'
					},
					instanceName: {
						type: 'string'
					},
					parameters: { type: 'object' },
					parametersSchema: { type: 'object' },
					channelId: {
						type: 'string'
					},
					channelFriendlyName: {
						type: 'string'
					},
					channelParameters: { type: 'object' },
					channelParametersSchema: { type: 'object' },
					requestSchema: { type: 'object' },
					flowInputsMap: { type: 'object' }
				}
			}
		},
		endpoints: {
			type: 'array',
			items: {
				properties: {
					status: {
						type: 'object',
						properties: {
							state: {
								type: 'string'
							},
							details: {
								type: 'string'
							}
						}
					},
					summary: {
						type: 'string'
					}
				}
			}
		}
	}
};

/**
 * API for interacting with the Endpoints.
 * @public
 */
class FlowsAPI extends APIProvider {
	/**
	 * Bind the paths to the controller methods.
	 *
	 * @param {EndpointsController} controller - The main controller providing
	 * the implementation for this API.
	 */
	static bind(controller) {
		const swagger = controller.ctx.swagger;

		swagger.schema('FlowValidateResponse', {
			type: 'object'
		});

		swagger
			.post('/flows')
			.operationId('createFlow')
			.tag('flow')
			.tag('reloads')
			.summary('Creates a flow.')
			.parameter({
				in: 'body',
				name: 'flow',
				schema: flowSchema,
				description: 'The flow to create.'
			})
			.response(201, 'Flow successfully created', null, null, {
				Location: {
					description: 'The flowId of the newly created flow.',
					type: 'string'
				}
			})
			.response(400)
			.response(500)
			.action(async (req, res) => {
				try {
					const flow = req.body;
					let flowId = null;
					if (flow) {
						// sanitized name cleans up the friendly flow name.
						// This doesn't modify the friendly name, but provides
						// a base for generating a unique flowId that is
						// recognisable by the user.
						let sanitizedName = flow.info && flow.info.name
							.replace(/[/?<>\\:*|"'. ]/g, '') || '';

						if (!sanitizedName.length) {
							sanitizedName = 'NewFlow';
						}
						await mkdirIfNotExistsAsync(controller.flowsDir);
						flowId = await getUniqueFilename(
							controller.flowsDir,
							sanitizedName,
							'json'
						);
					}
					// The saveFlow will verify the flowId and if it is valid
					await controller.saveFlow(flowId, flow);
					const encodedId = strictUriEncode(flowId);
					res.setHeader('Location', encodedId);
					res.status(201).send();
					controller.ctx.apibuilder.emit('reload');
				} catch (err) {
					APIProvider.handleError(err, res, 400, 500);
				}
			});

		swagger
			.get('/flows/:flowId')
			.operationId('getFlow')
			.tag('flow')
			.summary('Gets a flow.')
			.parameter({
				in: 'path',
				name: 'flowId',
				type: 'string',
				description: 'The unique id of the flow to retrieve.'
			})
			.response(200, 'OK', flowSchema)
			.response(404)
			.response(500)
			.action(async (req, res) => {
				// Express decodes parameters to match them to routes, so if
				// there was anything wrong with the parameter, the decoding
				// would have failed at Express level. No need for try/catch.
				const flowId = decodeURIComponent(req.params.flowId);
				try {
					const flow = await controller.getFlow(flowId);
					res.status(200).send(flow);
				} catch (err) {
					APIProvider.handleError(err, res, 404, 500);
					return;
				}
			});

		swagger
			.delete('/flows/:flowId')
			.operationId('deleteFlow')
			.tag('flow')
			.tag('reloads')
			.summary('Deletes a flow and all bound triggers')
			.parameter({
				in: 'path',
				name: 'flowId',
				type: 'string',
				description: 'The unique id of the flow to delete.'
			})
			.response(204, 'No content')
			.response(400)
			.response(404)
			.response(500)
			.action(async (req, res) => {
				const flowId = decodeURIComponent(req.params.flowId);
				try {
					await controller.deleteFlow(flowId);
					res.status(204).send();
					controller.ctx.apibuilder.emit('reload');
				} catch (err) {
					APIProvider.handleError(err, res, 400, 404, 500);
					return;
				}
			});

		swagger
			.get('/flows')
			.operationId('getFlowsSummaries')
			.tag('flows')
			.summary('Gets the summaries of all existing flows.')
			.response(200, 'OK', flowsSummariesSchema)
			.response(500)
			.action(async (req, res) => {
				try {
					const flows = await controller.getFlowsSummaries();
					res.status(200).send(flows);
				} catch (err) {
					APIProvider.handleError(err, res, 500);
					return;
				}
			});

		swagger
			.get('/flows/:flowId/bindings')
			.operationId('getFlowBindings')
			.tag('flow')
			.tag('flow-trigger')
			.summary('Returns all flow-triggers bound to this flow.')
			.parameter({
				in: 'path',
				name: 'flowId',
				type: 'string',
				description: 'The unique id of the flow to retrieve.'
			})
			.response(200, 'OK', triggerDetailsSchema)
			.response(404)
			.response(500)
			.action(async (req, res) => {
				// Express decodes parameters to match them to routes, so if
				// there was anything wrong with the parameter, the decoding
				// would have failed at Express level. No need for try/catch.
				const flowId = decodeURIComponent(req.params.flowId);

				try {
					const flowTriggers = await controller.getFlowBindings(flowId);
					res.status(200).send(flowTriggers);
				} catch (err) {
					APIProvider.handleError(err, res, 404, 500);
					return;
				}
			});

		swagger
			.put('/flows/validate')
			.operationId('validateFlow')
			.tag('flow')
			.summary('Validates a flow and returns a validation response. The property `valid` indicates whether or not the flow is valid or not.')
			.parameter({
				in: 'body',
				name: 'flow',
				schema: flowSchema,
				description: 'The flow to validate.'
			})
			.response(200, 'OK', 'FlowValidateResponse')
			.response(400)
			.response(500)
			.action(async (req, res) => {
				const flow = req.body;
				try {
					const result = await controller.validateFlow(flow);
					res.status(200).send(result);
				} catch (err) {
					APIProvider.handleError(err, res, 400, 500);
					return;
				}
			});

		swagger
			.post('/flows/:flowId')
			.operationId('updateFlow')
			.tag('flow')
			.tag('reloads')
			.summary('Updates a flow, or creates it if it does not exist.')
			.parameter({
				in: 'path',
				name: 'flowId',
				type: 'string',
				description: 'The unique id of the flow to update.'
			})
			.parameter({
				in: 'body',
				name: 'flow',
				schema: flowSchema,
				description: 'The flow to update.'
			})
			.response(204)
			.response(400)
			.response(500)
			.action(async (req, res) => {
				// Express decodes parameters to match them to routes, so if
				// there was anything wrong with the parameter, the decoding
				// would have failed at Express level. No need for try/catch.
				const flowId = decodeURIComponent(req.params.flowId);
				const flow = req.body;
				try {
					await controller.saveFlow(flowId, flow);
					res.status(204).send();
					controller.ctx.apibuilder.emit('reload');
				} catch (err) {
					APIProvider.handleError(err, res, 400, 500);
					return;
				}
			});
	}
}

module.exports = FlowsAPI;
