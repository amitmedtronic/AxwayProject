const path = require('path');
const afs = require('../afs');
const BadRequestError = require('../errors/BadRequestError');
const NotFoundError = require('../errors/NotFoundError');
const InternalServerError = require('../errors/InternalServerError');
const { mkdirIfNotExistsAsync, isSafeFilename } = require('../util');

// sorts objects `a` and `b` by `name` property using locale-compare.
function sortByName(a, b) {
	return a.name.localeCompare(b.name);
}

/**
 * The controller implementing the actions for interacting with Flows.
 * @public
 */
class FlowsController {
	/**
	 * Create a ProjectController.
	 *
	 * @param {object} ctx - The context for this controller.
	 * @param {express} ctx.app - The express application.
	 * @param {string} ctx.prefix - The prefix bound to.
	 * @param {APIBuilder} ctx.apibuilder - The API Builder server.
	 * @param {Swagger} ctx.swagger - openapi-doc instance.
	 */
	constructor(ctx) {
		this.ctx = ctx;
		this.flowsDir = path.resolve(
			path.join(this.ctx.apibuilder.config.dir || process.cwd(), 'flows')
		);
		this.logger = this.ctx.apibuilder.logger;
		this.flowManager = this.ctx.apibuilder.flowManager;
	}

	/**
	 * Retrieves a flow by name.
	 *
	 * @param {string} flowId - The name of the Flow to get
	 * @returns {Promise} Resolves to a flow on success.
	 */
	getFlow(flowId) {
		this.logger.trace(`Getting flow: ${flowId}`);
		return new Promise((resolve, reject) => {
			if (!flowId) {
				return reject(new BadRequestError());
			}
			const flow = this.ctx.apibuilder.getFlow(flowId);
			if (!flow) {
				return reject(new NotFoundError());
			}
			return resolve(flow);
		});
	}

	/**
	 * Returns the summary of all existing flows. The flow summary includes:
	 *  * id - The flow id.
	 *  * status - The flow status: enabled|error.
	 *  * name - The friendly name of the Flow.
	 *  * description - The description of the Flow.
	 *  * labels - A list of all flow-trigger types that invoke this flow.
	 *
	 * @returns {array} A list of all flows in their summarized form.
	 */
	async getFlowsSummaries() {
		const flows = this.ctx.apibuilder.getFlows();
		const info
			= this.ctx.apibuilder._internal.getTriggerManager().getInfo();
		const endpoints
			= this.ctx.apibuilder._internal.getEndpointTriggers();

		// labelsMap['flowId']['timer']: true
		const labelsMap = {};
		// flowHasInvalidTrigger['timer']: true
		const flowHasInvalidTrigger = {};
		for (const type in info.triggers) {
			for (const id in info.triggers[type]) {
				const { flowId } = info.triggers[type][id];
				labelsMap[flowId] = labelsMap[flowId] || {};
				labelsMap[flowId][type] = true;
				// if multiple triggers invoke the same flow, then this
				// ensures that if any of them are invalid, the flow is too.
				if (!info.triggers[type][id].status.valid) {
					flowHasInvalidTrigger[flowId] = true;
				}
			}
		}

		// labelsMap['flowId']['endpoint']: true
		// flowHasInvalidEndpoint['flowId']: true
		const flowHasInvalidEndpoint = {};
		for (const { flowId, errors } of endpoints) {
			labelsMap[flowId] = labelsMap[flowId] || {};
			labelsMap[flowId].endpoint = true;
			// if multiple endpoints invoke the same flow, then this
			// ensures that if any of them are invalid, the flow is too.
			if (errors.length) {
				flowHasInvalidEndpoint[flowId] = true;
			}
		}

		return Object.keys(flows)
			.map((flowId) => {
				const flow = flows[flowId];
				const labels = labelsMap[flowId]
					? Object.keys(labelsMap[flowId]).sort() : [];
				let status = 'enabled';
				if (flowHasInvalidEndpoint[flowId]
					|| flowHasInvalidTrigger[flowId]
					|| !flow['x-validation'].valid) {
					status = 'error';
				}

				return {
					status,
					flowId,
					name: flow.info.name,
					description: flow.info.description,
					labels
				};
			})
			.sort(sortByName);
	}

	/**
	 * Returns a list of all flow-triggers bound to a flow.
	 *
	 * @param {string} flowId - The name of the Flow.
	 * @returns {array} A list of plugin and endpoint triggers for that flow.
	 */
	async getFlowBindings(flowId) {
		const flow = this.ctx.apibuilder.getFlow(flowId);
		// Check if a flow exist with that flowId
		if (!flow) {
			throw new NotFoundError(`Flow '${flowId}' not found.`);
		}

		// Gets the triggers info from the TriggerManager.  The info is
		// roughly: { definitions: {}, triggers: {} }, where definitions
		// are trigger plugin type definitions (by type), and triggers are
		// by type and then by id.
		const triggersInfo
			= this.ctx.apibuilder._internal.getTriggerManager().getInfo();
		const flowTriggers = {
			endpoints: [],
			triggers: {}
		};

		// Filter the TM's triggersInfo into `triggers` used by the flow
		// FIXME: it would be good to move this to the TM.  The only reason
		// it is not done now is because of the error translation, which is
		// a UI presentation issue.
		const { triggers } = flowTriggers;
		for (const type in triggersInfo.triggers) {
			for (const id in triggersInfo.triggers[type]) {
				const trigger = triggersInfo.triggers[type][id];
				if (trigger.flowId !== flowId) {
					continue;
				}
				triggers[type] = triggers[type] || {};
				triggers[type][id] = trigger;
				// copy the status (might modify it)
				triggers[type][id].status = {
					valid: trigger.status.valid,
					error: trigger.status.error
				};

				if (!trigger.status.valid
					&& trigger.status.error.includes('Invalid flow')) {
					// The invalid flow is a special case, where we want to
					// replace the provided error('Invalid flow:<FlowName>').
					// This is required so we can do a better job at informing
					// the user that the trigger state would be fixed AFTER
					// they fix and save the flow.
					triggers[type][id].status = {
						valid: false,
						error: 'Invalid flow: Fix the flow and apply the changes to restore the triggers state.'
					};
				}
			}
		}

		const endpoints = this.ctx.apibuilder._internal.getEndpointTriggers();
		for (const endpoint of endpoints) {
			if (flowId === endpoint.flowId) {
				let status;
				if (endpoint.enabled) {
					status = {
						valid: true
					};
				} else if (endpoint.errors.length) {
					// The only errors endpoints can be are related to the flow.
					// Either Invalid or Not found(we can't be in the flow editor
					// if the flow was not found so we can ignore that use case).
					//
					// The invalid flow is a special case, where we want to
					// replace the provided error('Invalid flow: <FlowName>').
					// This is required so we can do a better job at informing
					// the user that the trigger state would be fixed AFTER
					// they fix and save the flow.
					status = {
						valid: false,
						error: 'Invalid flow: Fix the flow and apply the changes to restore endpoints state.'
					};
				} else {
					// No errors means it was disabled at source
					status = {
						valid: true,
						error: 'Disabled at source.'
					};
				}

				flowTriggers.endpoints.push({
					enabled: !!endpoint.enabled,
					summary: `${endpoint.method.toUpperCase()} ${endpoint.path}`,
					status
				});
			}
		}
		return flowTriggers;
	}

	/**
	 * Checks to see if `flowId` already exists.
	 *
	 * @param {string} flowId - The flow to check.
	 * @returns {Promise<boolean>} True if the flow exists.
	 */
	exists(flowId) {
		this.logger.trace(`Getting flow: ${flowId}`);
		return new Promise((resolve, reject) => {
			if (!flowId) {
				return reject(new BadRequestError());
			}
			return resolve(!!this.ctx.apibuilder.getFlow(flowId));
		});
	}

	/**
	 * Deletes a flow and all bound triggers
	 *
	 * @param  {string} flowId - name of the flow file.
	 * @async
	 */
	async deleteFlow(flowId) {
		this.logger.trace(`Deleting flow: ${flowId}`);

		if (!this.ctx.apibuilder.getFlow(flowId)) {
			throw new NotFoundError(`Flow '${flowId}' not found`);
		}

		try {
			// Delete all triggers bound to the flow
			const triggerManager = this.ctx.apibuilder._internal.getTriggerManager();
			await triggerManager.deleteTriggersForFlow(flowId);

			// Finally delete the flow
			const flowFilePath = path.join(this.flowsDir, `${flowId}.json`);
			await afs.unlink(flowFilePath);
		} catch (err) {
			this.logger.error(err);
			// security - do not throw with err.message
			throw new InternalServerError();
		}
	}

	/**
	 * Validates a flow.
	 *
	 * @param {object} flow - The flow to validate.
	 * @returns {Promise} Resolves a validation response.
	 */
	async validateFlow(flow) {
		this.logger.trace('Validating flow', flow);
		if (!flow) {
			throw new BadRequestError('Missing parameter: flow');
		}
		let errors = [];

		try {
			await this.flowManager.validate(flow, {
				graph: true,
				schema: true
			});
		} catch (ex) {
			if (ex instanceof Error) {
				// json-schema validation can reject by throwing an Error
				errors.push({
					type: 'invalidFlow',
					code: 'INVALID_FLOW',
					location: '/',
					detail: {
						error: ex.message
					}
				});
			} else {
				// a graph validation error
				errors = ex.errors;
			}
		}

		// Extract the flow input parameters schema as we'll need it for
		// validating the trigger to flow mapping.
		const flowInputSchema = flow.parameter;
		const tmErrors = this.ctx.apibuilder._internal.getTriggerManager()
			.validateTriggerUpdates(flow.triggers, flowInputSchema);
		errors = [
			...errors,
			...tmErrors.errors
		];

		return {
			valid: !errors.length,
			errors
		};
	}

	/**
	 * Saves a flow and the corresponding bound flow-triggers.
	 *
	 * @param  {string} flowId - name of the flow file (x-flow).
	 * @param {Object} flow - The flow to save.
	 */
	async saveFlow(flowId, flow) {
		this.logger.trace(`Saving flow: ${flowId}`);
		if (!flowId) {
			throw new BadRequestError('Missing parameter: flowId');
		}
		if (!flow) {
			throw new BadRequestError('Missing parameter: flow');
		}
		if (!isSafeFilename(flowId)) {
			// Reject the request if the flowId is not a valid (safe) id.
			throw new BadRequestError('Invalid parameter: flowId');
		}

		// The triggers are optional
		const { triggers } = flow;

		const validation = await this.validateFlow(flow);
		if (!validation.valid) {
			this.logger.error(
				`invalid flow: ${flowId}`,
				JSON.stringify(validation.errors)
			);
			this.logger.trace('data:', JSON.stringify(flow));
			throw new BadRequestError('Invalid parameter: flow');
		}

		try {
			await mkdirIfNotExistsAsync(this.flowsDir);

			// We need to trim the friendly name
			flow.info.name = flow.info.name.trim();
			if (!flow.info.name) {
				flow.info.name = 'New Flow';
			}
			// The description is an optional field in info
			if (flow.info.description) {
				flow.info.description = flow.info.description.trim();
			}

			// We need to delete the triggers as we don't want to persist them
			// with the flow. Deleted down here as we might want to add the
			// validation of these triggers as part of the flow above.
			delete flow.triggers;

			const flowFilePath = path.join(this.flowsDir, `${flowId}.json`);

			await this.flowManager.saveFlow(flowId, flowFilePath, flow);

			// Passes the trigger updates to the TM that would process all
			// the ones that it knows about.
			if (triggers) {
				await this.ctx.apibuilder._internal.getTriggerManager()
					.processTriggerUpdates(flowId, triggers);
			}
		} catch (err) {
			this.logger.error(err);
			throw new InternalServerError();
		}
	}
}

module.exports = FlowsController;
