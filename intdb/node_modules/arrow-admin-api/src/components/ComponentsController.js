const staticComponents = require('./components.json');

const getFriendlyName = pkg => {
	// [a-z]{2} filters out common prefixes like -fn- -dc- or custom ones
	// that happen to follow a similar convention to us (like -gm-)
	const match = /(?:@.*\/)?api-builder-plugin-(?:[a-z]{2}-)?(.*)/.exec(pkg);
	const name = match[1];
	return `${name[0].toUpperCase()}${name.substring(1)}`;
};

class ComponentsController {
	constructor(ctx) {
		this.ctx = ctx;
	}

	/**
	 * Returns a single flow-node from a set of flow-nodes. If the set of
	 * flow-nodes does not have a single flow-node, or if it has more than
	 * one, it will return `undefined`.
	 * @param {Object} flownodes A set of plugin's flow-nodes.
	 * @returns {Object|undefined} A single flow-node or `undefined`.
	 */
	static getSingleFlownode(flownodes = {}) {
		const keys = Object.keys(flownodes);
		if (keys.length !== 1) {
			return undefined;
		}
		return flownodes[keys[0]];
	}

	/**
	 * Builds the information on the component we would like to make available
	 * to the UI.
	 *
	 * Handles the choosing of the friendly name and the descriptions for the
	 * component's info.  We would like to use the plugin's flow-node
	 * name/description if it is avaiable and it has only one node. Othewise
	 * we'd like to fall back to the hardcoded list. If it is an installed
	 * plugin that is not part of the static list use what we have in the
	 * plugin itself.
	 * @param {Object} component The hardcoded static component.
	 * @param {Object} plugin The registered plugin details. Fallbacks to these
	 * 		details if we don't have anything else.
	 * @param {Object} [node={}] The plugin's single flow-node if it exists.
	 *
	 * @returns {Object} The component's information.
	 */
	static buildComponentInfo(component, plugin, node = {}) {
		// Initialize empty if we don't have a hardcoded static component
		component = component || {};
		// The priority is single flow-node > component > plugin
		component.name = component.name || node.name || getFriendlyName(plugin.name);
		component.description = component.description || node.description || plugin.description;
		component.type = component.type || plugin.type;
		component.docs = component.docs || plugin.repository || '';
		component.installed = true;
		component.currentVersion = plugin.version;
		component.tags = component.tags || plugin.tags;
		component.support = component.support || plugin.support || '';
		ComponentsController.buildComponentUsage(component, plugin);
		return component;
	}

	/**
	 * Builds component usage report from runtime plugin usage.
	 * @param {Object} component The component
	 * @param {Object} plugin The plugin
	 */
	static buildComponentUsage(component, plugin) {
		const usage = plugin.usage;
		component.usage = {
			used: false,
			uninstallable: true,
			modelAutogen: null,
			in: ''
		};
		if (!usage) {
			return;
		}

		const report = [];
		if (usage.apis && Object.keys(usage.apis).length) {
			component.usage.used = true;
			report.push('API:');
			for (const [ api, reason ] of Object.entries(usage.apis)) {
				component.usage.uninstallable = true;
				report.push(`\t'${api}' => '${reason}' model`);
			}
			report.push('');
		}

		if (usage.connectors && Object.keys(usage.connectors).length) {
			component.usage.used = true;
			report.push('Connectors:');
			for (const connectorInstance in usage.connectors) {
				component.usage.uninstallable = true;
				if (!component.usage.modelAutogen) {
					component.usage.modelAutogen = [];
				}
				component.usage.modelAutogen.push(connectorInstance);
				report.push(`\tAPIs are auto-generated from the '${connectorInstance}' connector`);
			}
			report.push('');
		}

		if (usage.flows && Object.keys(usage.flows).length) {
			component.usage.used = true;
			report.push('Flows:');
			for (const reason of Object.values(usage.flows)) {
				component.usage.uninstallable = false;
				const { name, instance, fn } = reason;
				report.push(`\t${fn}`);
				report.push(`\t\t'${instance}' => '${name}' flow-node`);
			}
			report.push('');
		}

		if (usage.endpoints && Object.keys(usage.endpoints).length) {
			component.usage.used = true;
			report.push('Endpoints:');
			for (const [ endpoint, reason ] of Object.entries(usage.endpoints)) {
				component.usage.uninstallable = false;
				const { name, instance } = reason;
				report.push(`\t${endpoint}`);
				report.push(`\t\t'${instance}' => '${name}' flow-node`);
			}
			report.push('');
		}

		if (usage.models && Object.keys(usage.models).length) {
			component.usage.used = true;
			report.push('Models:');
			for (const [ model, reason ] of Object.entries(usage.models)) {
				component.usage.uninstallable = false;
				if (reason.model) {
					report.push(`\t'${model}' => '${reason.model}'`);
				} else {
					report.push(`\t'${model}' => '${reason.connector}' connector`);
				}
			}
			report.push('');
		}
		component.usage.in = report.join('\n');
	}

	/**
	 * @returns {Array} A list of all available components.
	 */
	getComponents() {
		// flownodes - Runtime's plugins.js automatically defines flownodes: {}
		// on import. So it can't be undefined.
		const plugins = this.ctx.apibuilder.apibuilderPlugins;
		// Cloning the static components object
		const components = JSON.parse(JSON.stringify(staticComponents));
		// Augment static components with install information and add new
		// plugins which are not in the list
		for (const plugin of Object.values(plugins)) {
			const pluginName = plugin.name;
			// If the plugin has a single flow-node - retrieve that
			const singleFlowNode = ComponentsController.getSingleFlownode(
				plugin.components.flownodes
			);
			// Updates the components list
			components[pluginName] = ComponentsController.buildComponentInfo(
				components[pluginName], plugin, singleFlowNode
			);
		}
		// Convert the map into an array of components sorted by install
		// status then name.
		return Object.keys(components).map(pkg => {
			const component = components[pkg];
			component.package = pkg;
			component.installed = !!component.installed;
			return component;
		}).sort(sortComponents);
	}
}

function sortComponents(a, b) {
	if (a.installed !== b.installed) {
		return a.installed ? -1 : 1;
	}
	const asupported = a.tags.includes('axway');
	const bsupported = b.tags.includes('axway');
	if (asupported !== bsupported) {
		return asupported ? -1 : 1;
	}
	return a.name.localeCompare(b.name);
}

module.exports = ComponentsController;
