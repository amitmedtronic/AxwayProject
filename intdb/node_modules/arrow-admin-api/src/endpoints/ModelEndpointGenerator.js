const strictUriEncode = require('strict-uri-encode');
const Swagger = require('openapi-doc');
const YAML = require('js-yaml');
const jsonpointer = require('@axway/json-pointer');
const OpenAPIUtils = require('../openapi-utils');
const NotFoundError = require('../errors/NotFoundError');
const { safeFilename } = require('../util');
const modelflows = require('./modelflows');
const modelEndpoints = require('./modelendpoints');
const apiBuilderConfig = require('@axway/api-builder-config');

const ACTION_MAP = {
	findById: 'findByIDAPI',
	findOne: 'findByIDAPI'
};

const MODE_ENDPOINTS = 1;
const MODE_OPENAPI = 2;

/**
 * Helper for generating standard Endpoints from a Model definition.
 * @public
 */
class ModelEndpointGenerator {
	constructor(apibuilder, modelName) {
		const { _internal } = apibuilder;
		this.mode = _internal.endpointsEnabled ? MODE_ENDPOINTS : MODE_OPENAPI;
		this.apibuilder = apibuilder;
		this.logger = apibuilder.logger;
		this.model = apibuilder.getModel(modelName);
		if (!this.model) {
			throw new NotFoundError(`Model ${modelName} not found`);
		}
		const lcModelName = modelName.toLowerCase();
		const encodedModelName = lcModelName.replace(/^.*?\//, '');
		if (apiBuilderConfig.flags.enableModelNameEncodingInSwagger) {
			// new RFC-3986 standard way of encoding model names.  this strips off the connector
			// prefix by the way (e.g. oracle/*)
			this.encodedModelName = strictUriEncode(encodedModelName);
		} else {
			// old way of encoding model names
			this.encodedModelName = encodedModelName;
		}
		this.triggerTypeId = lcModelName.replace(/[^A-Z0-9-_.~]/ig, '');
		this.modelSchema = apibuilder.modelToSchema(this.model);
		this.supportedAPIs = this.getSupportedAPIDefs();
	}

	/**
	 * Get the APIs that are supported by the model.
	 * @returns {object} sipported api definitions
	 */
	getSupportedAPIDefs() {
		const defs = {};
		const apiOrder = [
			'findAllAPI',
			'deleteAllAPI',
			'countAPI',
			'queryAPI',
			'upsertAPI',
			'findAndModifyAPI',
			'distinctAPI',
			'createAPI',
			'findByIDAPI',
			'updateAPI',
			'deleteAPI'
		];

		// Reusing the existing CRUD->API support here to get the metadata for
		// Endpoint creation. The order of the API is important to be defined
		// so that paths with parameters come after paths without.
		for (const key in this.model) {
			// Limiting to CRUD APIs defined in Model base and not extended
			// APIs added by custom models/connectors.
			if (this.model[key] && key.slice(-3) === 'API') {
				// Some connectors use old mappings, to maintain support remap to the standard
				// action.
				const name = key.slice(0, -3);
				if (this.model[name] && Object.getPrototypeOf(this.model).hasOwnProperty(name)) {
					// Check to see if the underlying connector has the necessary methods to
					// support this API.
					const apiDef = this.model[key]();
					const reqConnectorMethods = apiDef.dependsOnAny || apiDef.dependsOnAll
						|| [ name ];
					const connectorMethods = reqConnectorMethods.filter(
						method => !!this.model.getConnector()[method]
					);

					if (connectorMethods.length
						>= (apiDef.dependsOnAll ? reqConnectorMethods.length : 1)) {
						const action = ACTION_MAP[name] || key;
						defs[action] = apiDef;
					} else {
						this.logger.warn(`API not supported on Connector: ${name}`);
					}
				} else {
					this.logger.warn(`API not supported on Model: ${name}`);
				}
			}
		}
		return apiOrder.reduce((acc, cur) => {
			if (defs[cur]) {
				acc[cur] = defs[cur];
			}
			return acc;
		}, {});
	}

	/**
	 * Generate the standard endpoints for the model.
	 * @param {string} name - The endpoint name.
	 * @param {string} description - The endpoint description.
	 * @return {object} - The swagger object for the model endpoints.
	 */
	generateEndpoint(name, description) {
		// Create the Swagger for each API supported by the model
		const swagger = new Swagger();
		const modelName = this.model.singular || this.model.name;
		swagger.info(
			name || `${modelName} API`,
			'1.0.0',
			description || `The ${name} REST API`
		);
		swagger.basePath('/endpoints');
		const schemaRef = this.getSchemaRefs();

		Object.keys(this.supportedAPIs).forEach((apiName) => {
			if (modelEndpoints[apiName]) {
				const operationId = this.getOperationId(
					this.model,
					this.getAPIPath(apiName),
					this.supportedAPIs[apiName]);
				const flow = this.getFlowName(name, apiName);
				swagger.merge(modelEndpoints[apiName]({
					flow,
					operationId,
					schemaRef,
					model: this.model,
					encodedModelName: this.encodedModelName
				}), {
					// swagger merge option `express` is to *not* format :name to express
					// parameters.
					express: false
				});
				if (this.mode === MODE_ENDPOINTS) {
					swagger.extension('x-flow', flow);
				}
			}
		});

		// Add schema definitions
		if (this.mode === MODE_OPENAPI) {
			for (const schema of this.modelSchema) {
				if (schema.id.endsWith('-fullex')) {
					// don't need fullex
					continue;
				}
				// the model name in in axway schema is already a valid JSON
				// $ref (i.e. it is URI encoded)
				const refName = schema.id.split('schema:///model/').pop();
				const decodedName = decodeURIComponent(refName); // mysql/blah
				const name = decodedName.split('/').pop();

				const clone = { ...schema };
				// sanitize
				delete clone.id;
				delete clone.$id;
				delete clone.$schema;
				swagger.schema(name, clone);
			}
		}

		return swagger.apidoc();
	}

	generateTriggers() {
		let count = 0;
		const triggers = {};
		for (const apiName in this.supportedAPIs) {
			const api = this.supportedAPIs[apiName];
			const id = `openapi-${this.triggerTypeId}-${++count}`;
			const operationId = this.getOperationId(
				this.model,
				this.getAPIPath(apiName),
				api);
			const flowName = this.getFlowName(this.model.name, apiName);

			triggers[id] = {
				name: operationId,
				parameters: {
					method: operationId
				},
				enabled: true,
				invoke: {
					flow: flowName,
					parameters: {
						request: '$.request',
						config: '$.config',
						env: '$.env'
					}
				}
			};
		}
		return YAML.dump({
			triggers
		});
	}

	/**
	 * Generate the standard flows for the model apis.
	 * @param {string} endpointName - The name of the endpoint.
	 * @return {object} - The map of flows to support the endpoint apis.
	 */
	generateFlows(endpointName) {
		const flows = {};
		const schemaRef = this.getSchemaRefs();
		const options = {
			errorOutputs: apiBuilderConfig.flags.enableModelErrorOutputs,
			withParams: this.mode === MODE_ENDPOINTS
		};
		Object.keys(this.supportedAPIs).forEach((apiName) => {
			const flowName = this.getFlowName(endpointName, apiName);

			if (modelflows.hasOwnProperty(apiName)) {
				flows[flowName] = modelflows[apiName](
					flowName, schemaRef, this.model, options);
			}
		});
		return flows;
	}

	/**
	 * Fetch schemas and refs for the current model
	 * @returns {object} object containing schemas and refs
	 */
	getSchemaRefs() {
		let pkType = this.model.getPrimaryKeyType();
		// Swagger does not support "date" as a type, so it needs to be coerced to "string"
		// (see RDPP-5819).
		if (pkType === 'date') {
			pkType = 'string';
		}

		if (this.mode === MODE_ENDPOINTS) {
			return {
				model: this.apibuilder.getModelSchemaId(this.model),
				modelEx: this.apibuilder.getModelSchemaExId(this.model),
				full: this.model.hasPrimaryKey()
					? this.apibuilder.getModelSchemaFullId(this.model)
					: this.apibuilder.getModelSchemaId(this.model),
				fullEx: this.model.hasPrimaryKey()
					? this.apibuilder.getModelSchemaFullExId(this.model)
					: this.apibuilder.getModelSchemaExId(this.model),
				pkType
			};
		} else {
			// These are regular $ref, not the axway schema:/// $ref, which is
			// why these need to be encoded and escaped to make safe.
			const rfc3986Name = strictUriEncode(
				this.model.name.replace(/^.*?\//, ''));
			const escName = jsonpointer.escape(rfc3986Name);

			const schemaRefs = this.modelSchema.reduce((refs, schema) => {
				if (schema.id.endsWith('-ex')) {
					refs.modelEx = `#/definitions/${escName}-ex`;
				} else if (schema.id.endsWith('-full')) {
					refs.full = `#/definitions/${escName}-full`;
				} else {
					refs.model = `#/definitions/${escName}`;
				}
				return refs;
			}, { pkType });
			return schemaRefs;
		}
	}

	/**
	 * Get the appropriate name to use for the flow by slicing the "API" from
	 * the `apiName` (e.g. "createAPI" => "create") and prefixing with the
	 * endpoint name (e.g. "banana-create").
	 * @param {string} endpointName - the name of the endpoint
	 * @param {string} apiName - the name of the API
	 * @returns {string} the safe name of the flow
	 */
	getFlowName(endpointName, apiName) {
		return `${safeFilename(endpointName)}-${apiName.slice(0, -3)}`;
	}

	/**
	 * Get the path for the model api.
	 * @param {string} apiName - The api to get the path for.
	 * @return {string} - The api path.
	 */
	getAPIPath(apiName) {
		const apiDetail = this.supportedAPIs[apiName];
		const name = this.model.name.replace(/^.*?\//, '').toLowerCase();
		let apiPath = `/${name}`;
		if (apiDetail.path) {
			if (apiDetail.path.startsWith('./')) {
				apiPath += apiDetail.path.substr(1);
			} else {
				apiPath += apiDetail.path;
			}
		}
		return apiPath;
	}

	/**
	 * Get the operation id.
	 * @param {Model} model - The model the endpoints are being generated for.
	 * @param {string} apiPath - The path the endpoint is going to advertise.
	 * @param {object} apiDetail - The API details for the model method.
	 * @return {string} - The operation id.
	 */
	getOperationId(model, apiPath, apiDetail) {
		return OpenAPIUtils.generateFunctionName(apiPath, apiDetail.method);
	}
}

module.exports = ModelEndpointGenerator;
