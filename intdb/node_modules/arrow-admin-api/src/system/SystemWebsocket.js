const childProcess = require('child_process');
const util = require('../util');
const isWindows = process.platform === 'win32';

function handleException(ex, operation, componentName, ws, req, throttler = null) {
	if (throttler) {
		throttler.stop();
	}
	req.logger.error(ex);
	ws.sendData('status', {
		operation,
		name: componentName,
		code: -1,
		status: 'failed',
		log: ex.stack
	});
	ws.close();
}

const operations = {
	install: {
		command: 'install',
		events: {
			inprogress: 'installing',
			completed: 'installed'
		}
	},
	uninstall: {
		command: 'uninstall',
		events: {
			inprogress: 'uninstalling',
			completed: 'uninstalled'
		}
	}
};

class SystemWebsocket {
	/**
	 * @param {object} ctx - The api context
	 * @param {controllers} controllers - The controllers.
	 */
	constructor(ctx, controllers) {
		this.ctx = ctx;
		this.controllers = controllers;
	}

	bind() {
		this._bind('install');
		this._bind('uninstall');
	}

	_bind(operation) {
		const opConfig = operations[operation];
		const { app, prefix, apibuilder } = this.ctx;
		app.ws(`${prefix}/system/${opConfig.command}`, (ws, req) => {
			req.logger.trace(`Starting ${opConfig.command} session`);
			ws.on('start', (data) => {
				try {
					if (!data) {
						throw new Error('invalid parameters');
					}
					const components = this.controllers.componentsController.getComponents();
					this._start(ws, req, components, data.componentName, opConfig, apibuilder);
				} catch (ex) {
					handleException(
						ex,
						opConfig.command,
						data && data.componentName,
						ws,
						req
					);
				}
			});
		});
	}

	_start(ws, req, components, componentName, opConfig, apibuilder) {
		const component = components.find(a => a.package === componentName);
		// Allow only the installation of the components that are part of our
		// whitelisted static list.
		if (!component) {
			ws.sendData('status', {
				operation: opConfig.command,
				name: componentName,
				code: -1,
				status: 'failed',
				log: `Not an ${opConfig.command}able component\n`
			});
			ws.close();
			return;
		}

		let throttler;
		try {
			const spawnOpts = {
				cwd: process.cwd(),
				shell: isWindows,
				env: {
					...process.env,
					// Do not show npm update prompts that can cause the cmd to hang.
					NO_UPDATE_NOTIFIER: true
				}
			};
			throttler = new util.ThrottledEmitter('timeout');
			throttler.on('timeout', (data) => {
				const event = opConfig.events.inprogress;
				req.logger.trace(`sending "${event}" event (${data.length} messages)`);
				ws.sendData('status', {
					operation: opConfig.command,
					name: componentName,
					status: event,
					log: data.join('')
				});
			});

			if (opConfig.command === 'install') {
				throttler.push('Checking plugin requirements...\n');
				// Flush the logs to ensure the UI quickly gets an "inprogress" event.
				throttler.flush();

				// Since we're querying the engines, may as well query the version too.
				// In older versions of npm, if only one field is matched, the result
				// will just be the matched value (version), rather than an object
				// so query the name as well since that's also guaranteed.
				const output = childProcess.spawnSync('npm',
					[ 'info', componentName, 'engines.apibuilder', 'version', 'name', '--json' ],
					spawnOpts
				);

				// Handle issues with spawn
				if (output.error) {
					throw output.error;
				}

				const info = JSON.parse(output.stdout);
				// Handle errors from NPM. They are nice enough to format the error as JSON
				if (info.error) {
					throw new Error(`${info.error.summary} - ${info.error.detail}`);
				}

				let engine = info['engines.apibuilder'];
				const version = info.version;

				if (engine) {
					// Will throw if the plugin engine is incompatible with the current runtime.
					apibuilder._internal.validatePackageEngine(componentName, engine);
				}

				// Give some info about the version that's being installed
				throttler.push(`${componentName}@${version} will be installed\n\n`);
			}

			req.logger.trace(`starting ${opConfig.command}`, componentName);
			const child = childProcess.spawn('npm', [ opConfig.command, componentName ], spawnOpts);
			child.on('close', sendFinalStatus);
			child.on('error', sendFinalStatus);
			child.stdout.on('data', (data) => throttler.push(data));
			child.stderr.on('data', (data) => throttler.push(data));

			// Emitted when user cancel installation
			ws.on('cancelInstall', () => {
				req.logger.trace(`Cancel ${opConfig.command} initiated by the user!`);
				child.kill('SIGINT');
			});

			// Initiate the communication
			throttler.push(`> npm ${opConfig.command} ${componentName}\n`);
			throttler.flush();

			function sendFinalStatus(code, signal) {
				try {
					let status;
					let log;
					if (code === 0) {
						status = opConfig.events.completed;
						log = `\nSuccessfully ${opConfig.events.completed} ${componentName}.\n`;
					} else if (signal) {
						status = 'cancelled';
						log = `\n${opConfig.events.inprogress} was cancelled.\n`;
					} else {
						status = 'failed';
						log = `\n${componentName} failed to ${opConfig.command}.\n`;
					}
					throttler.stop();

					req.logger.trace('finished:', status);
					ws.sendData('status', {
						operation: opConfig.command,
						name: componentName,
						code,
						status,
						configFile: component.configFile,
						log
					});
					ws.close();
				} catch (ex) {
					handleException(ex, opConfig.command, componentName, ws, req, throttler);
				}
			}
		} catch (ex) {
			handleException(ex, opConfig.command, componentName, ws, req, throttler);
		}
	}

}

module.exports = SystemWebsocket;
