const fs = require('fs');
const path = require('path');
const parseJson = require('parse-json');
const YAML = require('js-yaml');
const schemas = require('axway-schema');
const openAPIUtils = require('@axway/openapi-utils')();
const apiBuilderConfig = require('@axway/api-builder-config');
const uriUtils = require('@axway/api-builder-uri-utils');
const swaggerMiddleware = require('./swagger-middleware');

const EXTENTION_PATTERN = new RegExp(/^x-/);

class Endpoints {
	/**
	 * Endpoint information.
	 * @typedef {Object} Endpoints~EndpointInfo
	 * @property {string} name - The endpoint group name.
	 * @property {object} swagger - The loaded swagger document.
	 * @property {string} filename - The endpoint filename.
	 * @property {string} format - The endpoint filename format (one of: yaml | json).
	 * @property {object} endpoint - The dereferenced, Swagger validated, and flow validated
	 * endpoint.
	 */

	/**
	 * Loads and validates an endpoint from a given file directory
	 *
	 * @async
	 * @static
	 * @param {string} file - File path of the endpoint to be loaded.
	 * @param {object} flows - the map of available flows (used in validation).
	 * @returns {Promise<EndpointInfo>} The loaded endpoint.
	 *
	 * @memberOf Endpoints
	 */
	static load(file, flows, { logger }) {
		return new Promise((resolve, reject) => {
			return fs.readFile(file, async (err, data) => {
				if (err) {
					return reject(err);
				}
				let swagger;
				let format = 'json';
				const name = path.basename(file).replace(/(.json|.yaml|.yml)$/, '');

				try {
					if (file.endsWith('.yaml') || file.endsWith('.yml')) {
						swagger = YAML.safeLoad(data.toString());
						format = 'yaml';
					} else {
						// the "default" file type is JSON
						swagger = parseJson(data.toString(), file);
					}
				} catch (ex) {
					return reject(
						new Error(`Unable to load endpoint ${path.basename(file)}. ${ex.message}`)
					);
				}

				openAPIUtils.validateSwagger(swagger, { logger })
					.then((dereferencedSwagger) =>
						Endpoints.validateEndpoint(dereferencedSwagger, flows))
					.then((endpoint) => {
						resolve({
							name,
							swagger,
							filename: file,
							format,
							endpoint
						});
					})
					.catch(reject);
			});
		});
	}

	/**
	 * validates a given endpoint for internal errors. Flows are required in validation.
	 *
	 * @static
	 * @param {object} endpoint - an endpoint's definition
	 * @param {object} flows - a map of the available flows (used in validation)
	 * @returns {object} endpoint - validated endpoint's definition
	 *
	 * @memberOf Endpoints
	 */
	static async validateEndpoint(endpoint, flows) {
		const xEnabled = endpoint['x-enabled'] = endpoint['x-enabled'] || { enabled: true };
		let disabled = 0;
		let invalid = 0;
		let total = 0;

		xEnabled.warnings = [];
		xEnabled.errors = [];

		Object.keys(endpoint.paths).forEach((path) => {
			if (EXTENTION_PATTERN.test(path)) {
				return;
			}
			Object.keys(endpoint.paths[path]).forEach((methodName) => {
				if (methodName === 'parameters' || EXTENTION_PATTERN.test(methodName)) {
					return;
				}
				const method = endpoint.paths[path][methodName];

				Endpoints.validateMethod(method, flows);
				if (!Endpoints.isEnabled(method)) {
					if (!Endpoints.isValid(method)) {
						xEnabled.warnings.push(
							`Problem in ${methodName.toUpperCase()} ${path}: ${method['x-enabled'].errors.join()}`
						);
						invalid++;
					} else {
						disabled++;
					}
				}
				total++;

				// If the group is manually disabled, disable each method
				if (!Endpoints.isEnabled(endpoint)) {
					Endpoints.disableEndpointMethod(method);
				}
			});
		});

		// If the group is manually disabled, do not apply additional validation and bail
		if (!Endpoints.isEnabled(endpoint)) {
			return endpoint;
		}

		// if all methods are disabled, disable the whole group
		if (disabled === total) {
			Endpoints.disableEndpoint(endpoint);
		} else if (invalid === total - disabled) {
			// if all the methods are invalid (contain error), invalidate the whole group
			Endpoints.disableEndpoint(endpoint, 'All methods contain errors');
		}
		return endpoint;
	}

	/**
	 * Validates a given method against flow related errors.
	 *
	 * @static
	 * @param {object} method - a single operation object of a valid swagger doc.
	 * https://github.com/OAI/OpenAPI-Specification/blob/master/versions/2.0.md#operationObject
	 * @param {object} flows - a map of the available flows (used in validation)
	 * @memberof Endpoints
	 */
	static validateMethod(method, flows) {
		// start with existing value to support manual enable/disable
		const xEnabled = method['x-enabled'] = method['x-enabled'] || { enabled: true };
		xEnabled.warnings = [];
		xEnabled.errors = [];
		const flowName = method['x-flow'];
		const flow = flows[flowName];
		if (!flowName) {
			Endpoints.disableEndpointMethod(method);
			delete xEnabled.errors;
		} else if (!flow) {
			Endpoints.disableEndpointMethod(method, `Flow not found: ${flowName}`);
		} else if (!flow['x-validation'] || !flow['x-validation'].valid) {
			Endpoints.disableEndpointMethod(method, `Invalid flow: ${flowName}`);
		}
	}

	/**
	 * marks a given endpoint invalid with a given error message. No error means its just disabled
	 *
	 * @static
	 * @param {object} endpoint - an endpoint's definition
	 * @param {string} [error] - optional error message to set
	 * @returns {object} endpoint - the given endpoint's definition marked invalid
	 *
	 * @memberOf Endpoints
	 */
	static disableEndpoint(endpoint, error) {
		if (!endpoint || !endpoint.paths) {
			throw new Error('invalid argument: endpoint');
		}
		const xEnabled = endpoint['x-enabled'] = endpoint['x-enabled'] || {};
		const errors = xEnabled.errors = xEnabled.errors || [];

		// If we're disabling an endpoint, disable all the methods
		Object.keys(endpoint.paths).forEach(path => {
			if (EXTENTION_PATTERN.test(path)) {
				return;
			}
			Object.keys(endpoint.paths[path]).forEach((methodName) => {
				if (methodName === 'parameters' || EXTENTION_PATTERN.test(methodName)) {
					return;
				}
				const method = endpoint.paths[path][methodName];
				Endpoints.disableEndpointMethod(method);
			});
		});

		xEnabled.enabled = false;
		error && errors.push(error);
		return endpoint;
	}

	/**
	 * Marks a given endpoint method invalid with a given error message. No error means
	 * it is just disabled.
	 *
	 * @static
	 * @param {object} endpointMethod - an endpoint's method definition
	 * @param {string} [error] - optional error message to set
	 * @returns {object} endpoint - the given endpoint's definition marked invalid
	 *
	 * @memberOf Endpoints
	 */
	static disableEndpointMethod(endpointMethod, error) {
		const xEnabled = endpointMethod['x-enabled'] = endpointMethod['x-enabled'] || {};
		const errors = xEnabled.errors = xEnabled.errors || [];
		xEnabled.enabled = false;
		error && errors.push(error);
		return endpointMethod;
	}

	/**
	 * Confirms a given endpoint's active status. Could've been manually disabled w/o any error
	 *
	 * @static
	 * @param {object} endpoint - an endpoint's definition
	 * @returns {boolean}
	 *
	 * @memberOf Endpoints
	 */
	static isEnabled(endpoint) {
		return (endpoint['x-enabled'] && endpoint['x-enabled'].enabled);
	}

	/**
	 * Confirms a given endpoint's validity. Based on the presence of any error.
	 *
	 * @static
	 * @param {object} endpoint - an endpoint's definition
	 * @returns {boolean}
	 *
	 * @memberOf Endpoints
	 */
	static isValid(endpoint) {
		return (!Endpoints.isEnabled(endpoint)
			&& (!endpoint['x-enabled'].errors || endpoint['x-enabled'].errors.length === 0));
	}

	/**
	 * Binds the given endpoints to the apibuilder's express app.
	 *
	 * @static
	 * @param {object} apibuilderInstance - the running apibuilder instance to be bound with
	 * @param {object} endpoints - the endpoints to be bound
	 * @param {targetRenameCallback} [rename] - a callback function to rename swagger definitions
	 *
	 * @memberOf Endpoints
	 */
	static bind(apibuilderInstance, endpoints, rename) {
		Object.keys(endpoints).forEach((endpointName) => {
			const ep = endpoints[endpointName].endpoint;
			if (!Endpoints.isEnabled(ep)) {
				const errors = ep['x-enabled'] && ep['x-enabled'].errors;
				errors && errors.length && errors.forEach((errorMessage) => {
					apibuilderInstance.logger.error(`${endpointName} - ${errorMessage}`);
				});
				return;
			}
			const endpoint = schemas.dereference(ep, {
				target: '#/definitions',
				rename
			});
			const basePath = Endpoints.getRuntimeBasePath(apibuilderInstance, endpoint);
			const middlewareMetadata = swaggerMiddleware.middlewareMetadata(basePath, endpoint);
			Object.keys(endpoint.paths).sort((pathA, pathB) => {
				// Parameterized paths last
				const aParamCount = (pathA.match(/{/g) || []).length;
				const bParamCount = (pathB.match(/{/g) || []).length;

				// Sort by parameter count, lowest to highest
				if (aParamCount !== bParamCount) {
					return aParamCount < bParamCount ? -1 : 1;
				}

				// If they have the same param count, sort by path alphabetically for
				// consistency.  The paths will never be identical here because the
				// paths are the keys.
				return pathA > pathB ? 1 : -1;
			}).forEach((path) => {
				if (EXTENTION_PATTERN.test(path)) {
					return;
				}
				const bindPath = uriUtils.oasPathToExpress(basePath + path);
				let bound = false;
				Object.keys(endpoint.paths[path]).forEach((method) => {
					if (EXTENTION_PATTERN.test(method) || method === 'parameters') {
						return;
					}

					// Bind to the express path and apply middlewares
					const EPdefinition = endpoint.paths[path][method];
					if (!Endpoints.isEnabled(EPdefinition)) {
						apibuilderInstance.logger
							.debug(`binding api failed for (${method})`, bindPath);
						return;
					}

					// Register endpoint as used
					apibuilderInstance._internal.pluginUse.registerEndpoint(
						`${method.toUpperCase()} ${bindPath}`, EPdefinition['x-flow']
					);

					const headers = Endpoints.getResponseHeaders(
						method, endpoint.paths[path]);

					try {
						apibuilderInstance._internal.getPathManager().bindPath(
							method,
							bindPath,
							{
								headers,
								cb: [
									// ---
									// The following two middlewares
									// must be invoked one after the other in this order
									middlewareMetadata,
									swaggerMiddleware.middlewareParameters,
									// ---
									Endpoints.invokeFlow(apibuilderInstance, endpoint, EPdefinition)
								]
							}
						);
						bound = true;
					} catch (ex) {
						// bind failed due to a clash with other paths bound by the pathManager,
						// the path has been cached and the clash warning
						// will be logged independently later in the `checkPaths` task.
					}
				});

				if (!bound) {
					return;
				}
				// Bind the error handler
				// eslint-disable-next-line
				apibuilderInstance.app.use(bindPath, (err, req, res, next) => {
					// jjp: we trust that the above middleware functions are doing their jobs
					// to not leak unexpected errors.  they were specifically written that way.
					// the purpose of this method is to log and send the "clean" error back to
					// the client.  this is intentional.  the default response is 200, so unless
					// the status code is already set to an error condition, explicitly set it.
					if (res.statusCode < 400) {
						res.status(500);
					}
					res.send({ error: err.message });
				});
			});
		});
	}

	/**
	 * Returns methods and headers for the path.
	 *
	 * @static
	 * @param {string} method - the method.
	 * @param {Object} endpointPathItem - the endpoint's path item object
	 * containing the path information.
	 * @returns {Object} methods and headers for the path.
	 *
	 * @memberOf Endpoints
	 */
	static getResponseHeaders(method, endpointPathItem) {
		const headers = new Set();
		// extract headers from the response definition. 'responses' is required
		// by swagger spec.
		const { responses } = endpointPathItem[method];
		for (const response in responses) {
			const hdrs = responses[response].headers;
			if (!hdrs) {
				continue;
			}
			Object.keys(hdrs).forEach(h => headers.add(h.toLowerCase()));
		}
		return Array.from(headers);
	}

	/**
	 * Sends the HTTP response body.
	 * @param {object} res - Response object
	 * @param {object|string|number|null|boolean|Buffer} body - The response body
	 * @throws Error if the body is an invalid type.
	 */
	static sendBody(res, body) {
		if (body === undefined) {
			res.send();
			return;
		}
		const type = typeof body;
		if (![ 'object', 'string', 'number', 'null', 'boolean' ].includes(type)) {
			throw new TypeError(`Unsupported body type: ${type}`);
		}
		if (!apiBuilderConfig.flags.enableOverrideEndpointContentType) {
			// `res.json` does not set the charset from node-mocks-http
			// so to be very safe, keep the old way of sending json
			res.set('content-type', 'application/json; charset=utf-8');
			res.send(JSON.stringify(body));
			return;
		}

		// allow endpoint override
		if (res.get('content-type')) {
			// content-type override (already set)
			if (body instanceof Buffer || type === 'string') {
				res.send(body);
			} else {
				// body is Object
				res.json(body);
			}
			return;
		}
		// choose content-type
		if (body instanceof Buffer) {
			res.set('content-type', 'application/octet-stream');
			res.send(body);
		} else {
			res.json(body);
		}
	}

	/**
	 * Returns an Express middleware to invoke flow
	 *
	 * @static
	 * @param {object} apibuilderInstance - the apibuilder instance
	 * @param {object} endpoint - the endpoint's swagger definition
	 * @param {object} EPdefinition - the specific path/method from the endpoint
	 * @returns {function} Express middleware
	 *
	 * @memberOf Endpoints
	 */
	static invokeFlow(apibuilderInstance, endpoint, EPdefinition) {
		const produces = EPdefinition.produces || endpoint.produces;
		const flowName = EPdefinition['x-flow'];

		// A middleware closure to invoke flow
		return (req, res, next) => {
			if (produces && !req.accepts(produces)) {
				res.status(406);
				return next();
			} else if (!req.swagger) {
				// req.swagger is set by swagger-tools metadata middleware which is called
				// in advance of this. There's a chance that req.swagger will not be set,
				// but this only happens in a tiny, barely reproducable window when the
				// server starts. If the flow is invoked then, we really don't want the
				// flow to invoke without the provided parameters, so allow it to fail
				// and be called again once swagger-tools has initialised.
				res.status(503);
				return next();
			} else {
				apibuilderInstance._internal.countTransaction();

				const flow = apibuilderInstance.flowManager.getFlow(flowName);
				const data = Endpoints.getFlowInput(req, flow, apibuilderInstance);

				apibuilderInstance.flowManager
					.flow(flowName, data, { logger: req.logger })
					.then(
						(result) => {
							const status = (+(result && result.status) || 200);
							const body = result && result.body;
							const headers = result && result.headers;

							if (headers) {
								(Object.keys(headers)).forEach((key) => {
									res.setHeader(key, headers[key]);
								});
								// expose the new headers added by the flow
								let exposeHeaders = res.get('Access-Control-Expose-Headers');
								exposeHeaders = exposeHeaders ? exposeHeaders.split(/\s*,\s*/) : [];
								exposeHeaders = new Set([
									...exposeHeaders,
									...Object.keys(headers)
								]);
								exposeHeaders = [ ...exposeHeaders ].join(', ');
								res.setHeader('Access-Control-Expose-Headers', exposeHeaders);
							}

							res.status(status);
							Endpoints.sendBody(res, body);
						}
					)
					.catch((err) => {
						// Unexpected error processing the flow response
						req.logger.error(err);
						res.status(500).send({ error: 'Server Error' });
					});
			}
		};
	}

	/**
	 * Helper to get flow parameters from the swagger context on the request.
	 *
	 * @static
	 * @param {object} req - the Express request object.
	 * @param {object} flow - The flow.
	 * @param {object} apibuilder - the API Builder instance
	 * @returns {object} A map of the deserialized parameters.
	 *
	 * @memberOf Endpoints
	 */
	static getFlowInput(req, flow, apibuilder) {
		// Just to call it out - we're not using `flow` here.  Not yet.  Ideally, we would
		// only copy over those swagger parameters that are also on the flow.  However, we
		// do not have an explicit schema saying that flow must have `params`, `request`,
		// `config`, and `env`, or even that `params` must be an object.  It would be
		// incorrect to select swagger parameters that are not actually direct flow inputs
		// (they would only be properties on the flow parameter `params`, e.g.
		// $.params.username).
		const params = {};

		for (const paramName in req.swagger.params) {
			const param = req.swagger.params[paramName];
			params[paramName] = param.value;
		}
		return {
			params,
			request: req,
			config: apibuilder.config,
			env: process.env
		};
	}

	/**
	 * Get the runtime basepath.
	 *
	 * @static
	 * @param {APIBuilder} apibuilder - the API Builder instance.
	 * @param {object} endpoint - the endpoint.
	 * @returns {string} - the runtime basePath.
	 *
	 * @memberOf Endpoints
	 */
	static getRuntimeBasePath(apibuilder, endpoint) {
		let basePath = apibuilder.config.apiPrefix || '';

		if (endpoint.basePath) {
			basePath += endpoint.basePath;
		}

		return basePath;
	}

	/**
	 * Validate a swagger document - delegates to openapi-utils.
	 *
	 * @static
	 * @param {object} swagger - swagger document
	 * @param {object} logger - APIBuilder logger Instance
	 * @returns {Promise<object>} the valid swagger document (dereferenced)
	 */
	static async validateSwagger(swagger, { logger }) {
		return openAPIUtils.validateSwagger(swagger, { logger });
	}

}

module.exports = Endpoints;
